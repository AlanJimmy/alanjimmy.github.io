<p><strong>Note：均有可能存在更优或更优美的算法，欢迎各位联系菜鸡出题人，QQ：352912432</strong></p>
<h2 id="树上的数"><a href="#树上的数" class="headerlink" title="树上的数"></a>树上的数</h2><p>做法一</p>
<p>按照 $O(n^2)$ 的暴力做法，每次修改暴力递归子树统计，标记每一个访问到的节点，如果遇到访问过的节点，说明该节点的整棵子树都已经被标记过了，可以直接返回。可以证明这样做的复杂度是 $O(n+m)$ 的。</p>
<p>做法二</p>
<p>相当于每次对dfs序一个区间染色，可以用并查集实现，即把相邻的已被染色的位置连到一个联通块内， 时间复杂度为$O(n\alpha(n))$或$O(n\log n)$，实际效率和做法一差不多。</p>
<h2 id="时代的眼泪"><a href="#时代的眼泪" class="headerlink" title="时代的眼泪"></a>时代的眼泪</h2><p>可以交换求和顺序，询问$u$就相当于考虑以$u$为根时每个点$x$的子树内有多少个点的$w$小于该点，记这个值为$h_x$,答案为所有$h_i$的总和。</p>
<p>先考虑如何求$u=1$时的答案，以$1$为根dfs，同时维护一个数据结构用来查询到根路径上有多少个点的$a_i$大于当前点。</p>
<p>然后通过换根dp求出每个$u$的答案，可以发现当根从点$x$变为$x$的儿子$y$时，$y$的子树会变为所有点，$x$的子树会变为不“在以$1$为根时$y$子树内”的所有点。</p>
<p>此做法时间复杂度$O(n\log n)$。</p>
<h2 id="传统艺能"><a href="#传统艺能" class="headerlink" title="传统艺能"></a>传统艺能</h2><p>首先对于没有修改的情况，有一个显然的 $dp$ 转移：</p>
<pre><code class="lang-cpp">if(!last[i]) dp[i] = dp[i - 1] * 2 + 1;
if(last[i]) dp[i] = dp[i - 1] * 2 - dp[last[i] - 1];
</code></pre>
<p>其中 <code>dp[i]</code> 表示考虑前 $i$ 位的方案数，<code>last[i]</code> 表示最近的与 <code>a[i]</code> 相同的字符的位置，如果 <code>a[i]</code> 第一次出现，则 <code>last[i]</code> 为 $0$</p>
<hr>
<p>现在我们考虑矩阵。</p>
<p>设状态矩阵 $A$，其中 <code>A[i][j]</code> 表示以 $i$ 开头，在结尾预支一个 $j$ 的方案数，其中 $i,j$ 为 $0$ 时表示一个空序列。</p>
<p>对于一个数 $i$ 的初始矩阵，对于对角线的元素，显然方案数为 $1$，而对于第 $i$ 行，显然都为 $1$。</p>
<p>比如对于数字 $1$ 的初始矩阵为 $\begin{bmatrix}<br>1\ 0\ 0\ 0\<br>1\ 1\ 1\ 1\<br>0\ 0\ 1\ 0\<br>0\ 0\ 0\ 1\<br>\end{bmatrix}$。</p>
<p>容易发现两个状态矩阵的合并就是矩阵乘法，即 $C<em>{i,j}=\sum\limits</em>{k=0}^3A<em>{i,k}\times B</em>{k,j}$</p>
<p>用线段树支持查询和修改即可，时间复杂度$O(4^3 m\log n)$。</p>
<h2 id="铺设道路"><a href="#铺设道路" class="headerlink" title="铺设道路"></a>铺设道路</h2><p>先令$b<em>i=d_i-d</em>{i-1}$ 那么我们相当于每次选取$l<r$，令$b_l-1$，$b_r+1$，代价$(r-l)^2$，令所有$b$变成$0$。
容易发现最短时间为$\sum_i max(b_i,0)$，达到最短时间需要我们每次每次选择的$b_l>0$,$b_r&lt;0$。</p>
<p>考虑一种贪心策略，遍历$b_i$，若有$b_i&gt;0$将其压入队列中，$b_i&lt;0$则</p>
<p>若使得代价最大，与最靠左的$b_l$配对。</p>
<p>若使得代价最小，与最靠右的$b_l$配对。</p>
<p>注意到$d_i \geq 0$，所以我们一定能找到数字配对。</p>
<p>可以用交换法证明贪心的正确性。时间复杂度$O(n)$。</p>
