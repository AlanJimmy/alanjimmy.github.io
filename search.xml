<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>[AFOI]区间与除法</title>
    <url>/2020/09/16/AFOI-%E5%8C%BA%E9%97%B4%E4%B8%8E%E9%99%A4%E6%B3%95/</url>
    <content><![CDATA[<h1 id="AFOI-区间与除法"><a href="#AFOI-区间与除法" class="headerlink" title="[AFOI]区间与除法"></a><a href="https://www.luogu.com.cn/problem/P5629" target="_blank" rel="noopener">[AFOI]区间与除法</a></h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意:"></a>题目大意:</h2><p>给定一个序列$A$, 叫操作序列, 序列$B$, 叫原序列</p>
<p>给定一个除数$d$, 若$A_i$能够通过不断整除$d$变成$B_j$, 那么就称作$A_i$可以被$B_j$消除</p>
<p>有$q$次询问, 每次询问给定一个区间$[l,r]$</p>
<p>求在区间$[l,r]$中至少需要多少个原数才能消除$A_l\sim A_r$</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h2><p>拿着题的第一想法是把所有的$A$去操作一下, 得到可行的原数, 然后就能得到一个二进制数表示分别能被那些原数消除, 然后再贪心的求得答案</p>
<p>显然这样做是不好实现的</p>
<p><del>于是看看题解</del></p>
<p>真的是绝了!</p>
<p>那么久转化一下思路, 我们似乎可以把所有的数看成一个$d$进制的数</p>
<p>似乎这样就简单多了, 只要原数是$A_i$的某个前缀就可以了</p>
<p>如果某个原数是某个原数的<strong>真</strong>前缀, 那么我们只需要被包含的那个前缀即可</p>
<p>所以, 我们最后得到的每个$A_i$对应的原数一定是唯一的</p>
<p>那么这个时候, 直接或起来, 求这个二进制数有多少个$1$即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> ll __read()</span><br><span class="line">&#123;</span><br><span class="line">    ll x(0), t(1);</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">'0'</span> || o &gt; <span class="string">'9'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">'-'</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">'0'</span> &amp;&amp; o &lt;= <span class="string">'9'</span>; o = getchar()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll n, m, d, q;</span><br><span class="line">ll a[maxn], ys[maxn];</span><br><span class="line">ll f[maxn][<span class="number">22</span>], log_[maxn] = &#123;<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> Ch[maxn][<span class="number">15</span>], end[maxn], id;</span><br><span class="line"><span class="keyword">int</span> stk[maxn], top, cnt;</span><br><span class="line"><span class="keyword">bool</span> t[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">cf</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x) &#123;</span><br><span class="line">        stk[++top] = x % d;</span><br><span class="line">        x /= d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cf(x);</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">root</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = top; i; --i) &#123;</span><br><span class="line">        <span class="keyword">int</span> now = stk[i];</span><br><span class="line">        <span class="keyword">if</span> (!Ch[root][now]) Ch[root][now] = ++id;</span><br><span class="line">        root = Ch[root][now];</span><br><span class="line">        <span class="keyword">if</span> (end[root]) <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    end[root] = ++cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Query</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cf(x);</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">root</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = top; i; --i) &#123;</span><br><span class="line">        <span class="keyword">int</span> now = stk[i];</span><br><span class="line">        <span class="keyword">if</span> (!Ch[root][now]) <span class="keyword">break</span>;</span><br><span class="line">        root = Ch[root][now];</span><br><span class="line">        <span class="keyword">if</span> (end[root]) <span class="keyword">return</span> end[root]; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = __read(), m = __read(), d = __read(), q = __read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[i] = __read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) ys[i] = __read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) Insert(ys[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> k = Query(a[i]);</span><br><span class="line">        log_[i] = log_[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (~k) f[i][<span class="number">0</span>] = (<span class="number">1l</span>l &lt;&lt; k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= log_[n]; ++j)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= n; ++i)</span><br><span class="line">            f[i][j] = f[i][j - <span class="number">1</span>] | f[i + (<span class="number">1</span> &lt;&lt; j - <span class="number">1</span>)][j - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = __read(), r = __read();</span><br><span class="line">        <span class="keyword">int</span> len = log_[r - l + <span class="number">1</span>];</span><br><span class="line">        ll ans = f[l][len] | f[r - (<span class="number">1</span> &lt;&lt; len) + <span class="number">1</span>][len];</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">cnt</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (ans) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ans &amp; <span class="number">1</span>) ++cnt;</span><br><span class="line">            ans &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"%d\n"</span>, cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>字典树</tag>
        <tag>贪心</tag>
        <tag>RMQ</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title>CF920G List of Integers</title>
    <url>/2020/09/25/CF920G-List-of-Integers/</url>
    <content><![CDATA[<h1 id="List-of-Intergers"><a href="#List-of-Intergers" class="headerlink" title="List of Intergers"></a><a href="https://www.luogu.com.cn/problem/CF920G" target="_blank" rel="noopener">List of Intergers</a></h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>求第$k$大的大于等于 $x$ 且与 $p$ 互质的数</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>即，求最小的 $y$ 使：</p>
<script type="math/tex; mode=display">
\sum_{i=1}^y[i\perp p]-\sum_{i=1}^x[i\perp p]=k</script><h2 id="莫比乌斯反演"><a href="#莫比乌斯反演" class="headerlink" title="莫比乌斯反演"></a>莫比乌斯反演</h2><p>那么看见这个形式，自然而然地会想到这个东西：$\mu*1=\epsilon$</p>
<p>所以就可以把 $[i\perp p]$ 写成：</p>
<script type="math/tex; mode=display">
\sum_{d|\gcd(i,p)}\mu(d)</script><p>那么交求和顺序，先枚举 $p$ 的因子 $d$，可以得到:</p>
<script type="math/tex; mode=display">
\begin{align*}
\sum_{i=1}^y[i\perp p]&=\sum_{i=1}^y\sum_{d|\gcd(i,p)}\mu(d)\\
&=\sum_{d|p}\mu(d)\sum_{i=1}^\left\lfloor\frac y d\right\rfloor1
\\&=\sum_{d|p}\mu(d)\left\lfloor\frac y d\right\rfloor
\end{align*}</script><p>那么，这个时候，后面这一块，已经是十分好求的了，可以直接枚举 $\sqrt y$ 范围内 $y$ 的因子(顺便得到 $&gt;\sqrt y$ )的因子，按照这个直接加就可以了</p>
<h2 id="容斥"><a href="#容斥" class="headerlink" title="容斥"></a>容斥</h2><p>还是考虑$[i\perp p]$，换一种写法呢就是$[\gcd(i,p)==1]$</p>
<p>那么就是说，不合法的就是$\gcd(i,p) &gt; 1$</p>
<p>那么按照套路，还是应该用总共的减去不合法的，</p>
<p>那么就要枚举$p$的每个因子对答案的贡献</p>
<p>同样的，还是可以得到容斥系数就是$\mu$</p>
<p>那么还是能够得到同一个式子：</p>
<script type="math/tex; mode=display">
\sum_{i=1}^y[i\perp p]=\sum_{d|p}^y\mu(d)\left\lfloor\frac y d\right\rfloor</script><p>当然，这并不是巧合，有兴趣的同学可以自行了解一下(<del>我也说不清</del>)</p>
<p>时间复杂度为$O(n\log n\sqrt n)$</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e7</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> __read()</span><br><span class="line">&#123;</span><br><span class="line">    int x(0), t(1);</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">'0'</span> || o &gt; <span class="string">'9'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">'-'</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">'0'</span> &amp;&amp; o &lt;= <span class="string">'9'</span>; o = getchar()) &#123;</span><br><span class="line">        x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mu[maxn], pr[maxn], cnt, line;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxn; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) pr[++cnt] = i, mu[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; i * pr[j] &lt; maxn; ++j) &#123;</span><br><span class="line">            vis[i * pr[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % pr[j]) mu[i * pr[j]] = -mu[i];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ans</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l * l &lt;= x; ++l) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x % l) <span class="keyword">continue</span>;</span><br><span class="line">        ans += mu[l] * (n / l);</span><br><span class="line">        <span class="keyword">if</span> (l * l &lt; x) ans += mu[x / l] * (n / (x / l));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Init();</span><br><span class="line">    <span class="keyword">int</span> T = __read();</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = __read(), p = __read(), k = __read();</span><br><span class="line">        int l(1), r(1e7), ans(0);</span><br><span class="line">        line = Query(x, p);</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (Query(mid, p) - line &gt;= k) ans = mid, r = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>UPT：</strong>有位机房巨佬认为我写的这个是有点小问题的，我觉得这个可以解释一下</p>
<p>他的意思是按照样例给的$7\;22\;1$，我的$Query$函数求得的$9$和$10$的答案都是$5$，那么为什么我取得的是$9$而不是$10$，然后$10$与$22$并不互质，为什么对$10$还有答案呢？</p>
<p>回到最开头，有这样一个东西：</p>
<script type="math/tex; mode=display">
\sum_{i=1}^y[i\perp p]-\sum_{i=1}^x[i\perp p]=k</script><p>会发现，我们求得的值，并不是说$y$是第几个，我们求得的值是在$[1,y]$有几个</p>
<p>令：</p>
<script type="math/tex; mode=display">
f(x)=\sum_{i=1}^x[i\perp p]</script><p>当$f(y)-f(y-1)=1$时，当且仅当$[y\perp p]=1$，所以，我们二分答案要取的是第一个满足条件的数</p>
]]></content>
      <tags>
        <tag>莫比乌斯反演</tag>
        <tag>容斥</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>CF932D Tree</title>
    <url>/2020/09/04/CF932D/</url>
    <content><![CDATA[<h1 id="CF932D-Tree"><a href="#CF932D-Tree" class="headerlink" title="CF932D Tree"></a><a href="https://www.luogu.com.cn/problem/CF932D" target="_blank" rel="noopener">CF932D Tree</a></h1><h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><ul>
<li>首先，我们有$Q$次操作</li>
</ul>
<blockquote>
<ul>
<li>操作$1$：在节点$R$下面再加一个权值为$W$的点</li>
<li>操作$2$：询问从点$X$开始往上走，（每次遇到权值大于当前选过的最后一个点的点必定会选），问最多能选多少点</li>
</ul>
</blockquote>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>我们可以很容易的发现，我们选中的点一定是一个单调不下降序列</p>
<p>那么就是说，我们可以稍微改动一下操作一，让每一条链都一定是单调不上升的（从根出发的链）</p>
<p>然后，我们每次加入的点必定不会是已经存在的某个点的祖先，所以我们改变他的位置对原来的树是没有影响的</p>
<p>若有节点成为了这个被我们认为操作的节点的儿子，它的值依赖于我们人为操作的那个点，所以这个答案也不会因为我们的操作出现问题</p>
<p>那么我们就可以在加入节点的时候，找到第一个权值大于该节点的点做为这个点的父节点</p>
<p>顺便跟新一下前缀和</p>
<p>这个用倍增实现就好了</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddPoint</span><span class="params">(ll u, ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll v = ++cnt;</span><br><span class="line">    wight[v] = p;</span><br><span class="line">    <span class="keyword">if</span> (wight[u] &gt;= wight[v]) &#123;</span><br><span class="line">        father[v][<span class="number">0</span>] = u;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (ll i = <span class="number">19</span>; ~i; --i)</span><br><span class="line">            <span class="keyword">if</span> (wight[father[u][i]] &lt; wight[v])</span><br><span class="line">                u = father[u][i];</span><br><span class="line">        father[v][<span class="number">0</span>] = father[u][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    sum[v][<span class="number">0</span>] = wight[father[v][<span class="number">0</span>]]; </span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt; <span class="number">20</span>; ++i) &#123;</span><br><span class="line">        father[v][i] = father[father[v][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (sum[v][i - <span class="number">1</span>] &lt; inf &amp;&amp; father[v][i]) &#123;</span><br><span class="line">            sum[v][i] = sum[v][i - <span class="number">1</span>] + sum[father[v][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后查询的话，能跳就跳，每次向上跳了更新一下限制即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Query</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (wight[x] &gt; limit) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="function">ll <span class="title">ans</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    limit -= wight[x];</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">19</span>; ~i; --i)</span><br><span class="line">        <span class="keyword">if</span> (sum[x][i] &lt;= limit) &#123;</span><br><span class="line">            ans += (<span class="number">1</span> &lt;&lt; i);<span class="comment">//向上跳了2的i次方层，那就有2的i次方个点</span></span><br><span class="line">            limit -= sum[x][i];</span><br><span class="line">            x = father[x][i];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll maxn = <span class="number">4e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> ll inf = <span class="number">0x6f6f6f6f6f6f6f6f</span>;</span><br><span class="line"></span><br><span class="line">ll father[maxn][<span class="number">20</span>], wight[maxn], cnt(<span class="number">1</span>);</span><br><span class="line">ll sum[maxn][<span class="number">20</span>], lastans, limit;</span><br><span class="line">ll Q, Opt, X, Y;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddPoint</span><span class="params">(ll u, ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll v = ++cnt;</span><br><span class="line">    wight[v] = p;</span><br><span class="line">    <span class="keyword">if</span> (wight[u] &gt;= wight[v]) &#123;</span><br><span class="line">        father[v][<span class="number">0</span>] = u;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (ll i = <span class="number">19</span>; ~i; --i)</span><br><span class="line">            <span class="keyword">if</span> (wight[father[u][i]] &lt; wight[v])</span><br><span class="line">                u = father[u][i];</span><br><span class="line">        father[v][<span class="number">0</span>] = father[u][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    sum[v][<span class="number">0</span>] = wight[father[v][<span class="number">0</span>]]; </span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt; <span class="number">20</span>; ++i) &#123;</span><br><span class="line">        father[v][i] = father[father[v][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (sum[v][i - <span class="number">1</span>] &lt; inf &amp;&amp; father[v][i]) &#123;</span><br><span class="line">            sum[v][i] = sum[v][i - <span class="number">1</span>] + sum[father[v][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Query</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (wight[x] &gt; limit) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="function">ll <span class="title">ans</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    limit -= wight[x];</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">19</span>; ~i; --i)</span><br><span class="line">        <span class="keyword">if</span> (sum[x][i] &lt;= limit) &#123;</span><br><span class="line">            ans += (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">            limit -= sum[x][i];</span><br><span class="line">            x = father[x][i];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ll <span class="title">x</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">o</span><span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">'0'</span> || o &gt; <span class="string">'9'</span>) o = getchar();</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">'0'</span> &amp;&amp; o &lt;= <span class="string">'9'</span>; o = getchar()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span> (sum, <span class="number">0x6f</span>, <span class="keyword">sizeof</span> sum);</span><br><span class="line">    wight[<span class="number">0</span>] = inf;</span><br><span class="line">    Q = Read();</span><br><span class="line">    <span class="keyword">while</span> (Q--)</span><br><span class="line">    &#123;</span><br><span class="line">        Opt = Read(), X = Read() ^ lastans, Y = Read() ^ lastans;</span><br><span class="line">        <span class="keyword">if</span> (Opt == <span class="number">1</span>) AddPoint(X, Y);</span><br><span class="line">        <span class="keyword">else</span> limit = Y, <span class="built_in">printf</span> (<span class="string">"%lld\n"</span>, lastans = Query(X));</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title>[CQOI2017]小Q的表格</title>
    <url>/2020/09/21/CQOI2017-%E5%B0%8FQ%E7%9A%84%E8%A1%A8%E6%A0%BC/</url>
    <content><![CDATA[<h1 id="CQOI2017-小Q的表格"><a href="#CQOI2017-小Q的表格" class="headerlink" title="[CQOI2017]小Q的表格"></a><a href="https://www.luogu.com.cn/problem/P3700" target="_blank" rel="noopener">[CQOI2017]小Q的表格</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个表格，满足：</p>
<ul>
<li>$\forall a,b\;f(a,b)=f(b,a)$</li>
<li>$\forall a,b\;b\cdot f(a,a+b)=(a+b)\cdot f(a,b)$</li>
</ul>
<p>有$m$次操作</p>
<ul>
<li>每次操作修改$f(a,b)$的值，为了使整个表满足条件，所以要修改的点还挺多的</li>
<li>然后让你输出$k*k$的范围内的数的和</li>
</ul>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>对于性质$\forall a,b\;b\cdot f(a,a+b)=(a+b)\cdot f(a,b)$，观察发现它可以转化一下：</p>
<script type="math/tex; mode=display">
\begin{align*}
b\cdot f(a,a+b)&=(a+b)\cdot f(a,b)\\
\Leftrightarrow ab\cdot f(a,a+b)&=a(a+b)\cdot f(a,b)\\
\Leftrightarrow\quad\;\frac{f(a,a+b)}{a(a+b)}&=\frac{f(a,b)}{ab}\\
\Leftrightarrow\qquad\;\;\;\frac{f(a,b)}{a,b}&=\frac{f(\gcd(a,b), \gcd(a,b))}{\gcd^2(a,b)}
\end{align*}</script><p>所以可以得到一个结论：</p>
<script type="math/tex; mode=display">
\begin{align*}
f(a,b)&=f(gcd(a,b),gcd(a,b))\times\frac{ab}{\gcd^2(a,b)}\\
&=g(d)\times\frac{ab}{d^2}
\end{align*}</script><p>那么就得到了一个线性的表了</p>
<p>那么再回头看看题目要求的问题</p>
<script type="math/tex; mode=display">
\begin{align*}
ans&=\sum_{d=1}^ng(d)\sum_{i=1}^n\sum_{j=1}^n\frac{ij}{\gcd^2(i,j)}[\gcd(i,j)=d]\\
&=\sum_{d=1}^ng(d)\sum_{i=1}^{\left\lfloor\frac nd\right\rfloor}\sum_{j=1}^{\left\lfloor\frac md\right\rfloor}ij[\gcd(i,j)=1]\\
&=\sum_{d=1}^ng(d)\sum_{i=1}^{\left\lfloor\frac nd\right\rfloor}i\sum_{j=1}^{\left\lfloor\frac nd\right\rfloor}j[\gcd(i,j)=1]\\
\end{align*}</script><p>考虑:</p>
<script type="math/tex; mode=display">
\sum_{i=1}^ni[\gcd(i,n)=1]=\frac{n\times\varphi(n)}{2}</script><p>所以原式可以化为:</p>
<script type="math/tex; mode=display">
ans= \sum_{d=1}^ng(d)\sum_{i=1}^{\left\lfloor\frac nd\right\rfloor}i^2\varphi(i)</script><p>那么这个时候我们发现，后面的是可以直接$O(1)$求解的（先预处理，就可以直接查询）</p>
<p>然而前面那个$g(d)$是会发生改变的</p>
<p>这个可以用树状数组或者是分块来维护</p>
<p>这两个理论上是可以过的，实测再<a href="loj.ac">loj</a>是可以过的</p>
<p>洛谷似乎有点卡常，要$TLE$一两个点</p>
<p><a href="https://loj.ac/submission/937220" target="_blank" rel="noopener">树状数组实现</a>，<a href="https://loj.ac/submission/937110" target="_blank" rel="noopener">分块实现</a></p>
<h3 id="Code-树状数组"><a href="#Code-树状数组" class="headerlink" title="Code(树状数组)"></a>Code(树状数组)</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll maxn = <span class="number">4e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> ll __read() &#123;</span><br><span class="line">    <span class="function">ll <span class="title">x</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">o</span><span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">'0'</span> || o &gt; <span class="string">'9'</span>) o = getchar();</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">'0'</span> &amp;&amp; o &lt;= <span class="string">'9'</span>; o = getchar()) x = ((x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>)) % mod;</span><br><span class="line">    <span class="keyword">return</span> x % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll size, n, q, len;</span><br><span class="line">ll pr[maxn], phi[maxn], f[maxn], cnt;</span><br><span class="line">ll id[maxn], st[maxn], ed[maxn];</span><br><span class="line">ll val[maxn], sum[maxn], Sum[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">inc</span><span class="params">(ll &amp;x, ll y)</span> </span>&#123;</span><br><span class="line">    x += y;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= mod)</span><br><span class="line">        x -= mod;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; <span class="number">0</span>)</span><br><span class="line">        x += mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">add</span><span class="params">(ll x, ll y)</span> </span>&#123;</span><br><span class="line">    ll temp = x + y;</span><br><span class="line">    <span class="keyword">if</span> (temp &gt;= mod)</span><br><span class="line">        temp -= mod;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (temp &lt; <span class="number">0</span>)</span><br><span class="line">        temp += mod;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll x, ll y)</span> </span>&#123;</span><br><span class="line">    <span class="function">ll <span class="title">ans</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (y) &#123;</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">1</span>)</span><br><span class="line">            ans = ans * x % mod;</span><br><span class="line">        x = x * x % mod;</span><br><span class="line">        y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Gcd</span><span class="params">(ll x, ll y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!y)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> Gcd(y, x % y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Update</span><span class="params">(ll x, ll val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x &lt;= n) &#123;</span><br><span class="line">        inc(sum[x], val);</span><br><span class="line">        x += lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Query</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="function">ll <span class="title">ans</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (x) &#123;</span><br><span class="line">        inc(ans, sum[x]);</span><br><span class="line">        x -= lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Query</span><span class="params">(ll l, ll r)</span> </span>&#123; <span class="keyword">return</span> add(Query(r), <span class="number">-1l</span>l * Query(l - <span class="number">1</span>)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i])</span><br><span class="line">            pr[++cnt] = i, phi[i] = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (ll j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; i * pr[j] &lt;= n; ++j) &#123;</span><br><span class="line">            vis[i * pr[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % pr[j]) &#123;</span><br><span class="line">                phi[i * pr[j]] = phi[i] * phi[pr[j]];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                phi[i * pr[j]] = phi[i] * pr[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; ++i) f[i] = (f[i - <span class="number">1</span>] + i * i % mod * phi[i] % mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    q = __read(), n = __read();</span><br><span class="line">    init();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        val[i] = <span class="number">1l</span>l * i * i % mod;</span><br><span class="line">        Update(i, val[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        ll a = __read(), b = __read(), x = __read(), k = __read(), d = Gcd(a, b);</span><br><span class="line"></span><br><span class="line">        ll upt = x * d % mod * d % mod * Pow(<span class="number">1l</span>l * a * b % mod, mod - <span class="number">2</span>) % mod;</span><br><span class="line">        Update(d, add(upt, -val[d]));</span><br><span class="line">        val[d] = upt;</span><br><span class="line"></span><br><span class="line">        <span class="function">ll <span class="title">ans</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (ll l = <span class="number">1</span>, r; l &lt;= k; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">            r = k / (k / l);</span><br><span class="line">            inc(ans, f[k / l] * Query(l, r) % mod);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Code-分块"><a href="#Code-分块" class="headerlink" title="Code(分块)"></a>Code(分块)</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll maxn = <span class="number">4e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> ll __read() &#123;</span><br><span class="line">    <span class="function">ll <span class="title">x</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">o</span><span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">'0'</span> || o &gt; <span class="string">'9'</span>) o = getchar();</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">'0'</span> &amp;&amp; o &lt;= <span class="string">'9'</span>; o = getchar()) x = ((x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>)) % mod;</span><br><span class="line">    <span class="keyword">return</span> x % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll size, n, q, len;</span><br><span class="line">ll pr[maxn], phi[maxn], f[maxn], cnt;</span><br><span class="line">ll id[maxn], st[maxn], ed[maxn];</span><br><span class="line">ll val[maxn], sum[maxn], Sum[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">inc</span><span class="params">(ll &amp;x, ll y)</span> </span>&#123;</span><br><span class="line">    x += y;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= mod)</span><br><span class="line">        x -= mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">add</span><span class="params">(ll x, ll y)</span> </span>&#123;</span><br><span class="line">    ll temp = x + y;</span><br><span class="line">    <span class="keyword">if</span> (temp &gt;= mod)</span><br><span class="line">        temp -= mod;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll x, ll y)</span> </span>&#123;</span><br><span class="line">    <span class="function">ll <span class="title">ans</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (y) &#123;</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">1</span>)</span><br><span class="line">            ans = ans * x % mod;</span><br><span class="line">        x = x * x % mod;</span><br><span class="line">        y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Gcd</span><span class="params">(ll x, ll y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!y)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> Gcd(y, x % y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Get_sum</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> add(Sum[id[x] - <span class="number">1</span>], sum[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Get_sum</span><span class="params">(ll l, ll r)</span> </span>&#123; <span class="keyword">return</span> ((Get_sum(r) - Get_sum(l - <span class="number">1</span>)) % mod + mod) % mod; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i])</span><br><span class="line">            pr[++cnt] = i, phi[i] = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (ll j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; i * pr[j] &lt;= n; ++j) &#123;</span><br><span class="line">            vis[i * pr[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % pr[j]) &#123;</span><br><span class="line">                phi[i * pr[j]] = phi[i] * phi[pr[j]];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                phi[i * pr[j]] = phi[i] * pr[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; ++i) f[i] = (f[i - <span class="number">1</span>] + i * i % mod * phi[i] % mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Update</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == st[id[x]])</span><br><span class="line">        sum[x] = val[x];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        sum[x] = sum[x - <span class="number">1</span>] + val[x];</span><br><span class="line">    <span class="keyword">for</span> (ll i = x + <span class="number">1</span>; i &lt;= ed[id[x]]; ++i) sum[i] = add(sum[i - <span class="number">1</span>], val[i]);</span><br><span class="line">    <span class="keyword">for</span> (ll i = id[x]; i &lt;= len; ++i) Sum[i] = add(Sum[i - <span class="number">1</span>], sum[ed[i]]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    q = __read(), n = __read();</span><br><span class="line">    size = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    init();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        id[i] = i / size + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (i % size)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        st[id[i]] = i, ed[id[i] - <span class="number">1</span>] = i - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    len = id[n], ed[id[n]] = n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; ++i) val[i] = <span class="number">1l</span>l * i * i % mod;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= len; ++i) &#123;</span><br><span class="line">        sum[st[i]] = val[st[i]];</span><br><span class="line">        <span class="keyword">for</span> (ll j = st[i] + <span class="number">1</span>; j &lt;= ed[i]; ++j) sum[j] = add(sum[j - <span class="number">1</span>], val[j]);</span><br><span class="line">        Sum[i] = add(Sum[i - <span class="number">1</span>], sum[ed[i]]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        ll a = __read(), b = __read(), x = __read(), k = __read(), d = Gcd(a, b);</span><br><span class="line"></span><br><span class="line">        val[d] = x * d % mod * d % mod * Pow(<span class="number">1l</span>l * a * b % mod, mod - <span class="number">2</span>) % mod;</span><br><span class="line"></span><br><span class="line">        Update(d);</span><br><span class="line"></span><br><span class="line">        <span class="function">ll <span class="title">ans</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (ll l = <span class="number">1</span>, r; l &lt;= k; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">            r = k / (k / l);</span><br><span class="line">            inc(ans, f[k / l] * Get_sum(l, r) % mod);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="进一步考虑"><a href="#进一步考虑" class="headerlink" title="进一步考虑"></a>进一步考虑</h2><p>我们每次修改的值其实是$f(\gcd(a,b))$，所以真时要改的值并不多</p>
<ul>
<li><p>那么我们可以先求出原表中$k*k$范围内的值</p>
</li>
<li><p>再求出修改的值对答案贡献相对原来的偏移量</p>
</li>
</ul>
<script type="math/tex; mode=display">
\Delta ans=\sum_{i=1}^{cnt}(改(i)-原^2(i))\sum_{j=1}^{\left\lfloor\frac ki\right\rfloor}j^2\varphi(j)</script><p>所以这个就是$O(cnt)$的复杂度</p>
<p>然后又是可以证明对于所有的$\gcd(n,m)$的个数时处于$\log n\sim\sqrt n$这个级别的</p>
<p>所以修改大概就是$O(m\log n)\sim O(m\sqrt n)$</p>
<p>然而实际跑下来要比这快得多</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll maxn = <span class="number">4e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> ll __read() &#123;</span><br><span class="line">    <span class="function">ll <span class="title">x</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">o</span><span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">'0'</span> || o &gt; <span class="string">'9'</span>) o = getchar();</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">'0'</span> &amp;&amp; o &lt;= <span class="string">'9'</span>; o = getchar()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll size, n, q, len;</span><br><span class="line">ll pr[maxn], phi[maxn], f[maxn], cnt;</span><br><span class="line">ll stk[maxn], upt[maxn], top;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn], che[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i])</span><br><span class="line">            pr[++cnt] = i, phi[i] = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (ll j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; i * pr[j] &lt;= n; ++j) &#123;</span><br><span class="line">            vis[i * pr[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % pr[j]) &#123;</span><br><span class="line">                phi[i * pr[j]] = phi[i] * phi[pr[j]];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                phi[i * pr[j]] = phi[i] * pr[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; ++i) f[i] = (f[i - <span class="number">1</span>] + i * i % mod * phi[i] % mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">sum</span><span class="params">(ll x)</span> </span>&#123; <span class="keyword">return</span> x * (x + <span class="number">1</span>) / <span class="number">2</span> % mod; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll x, ll y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!y)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> gcd(y, x % y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    q = __read(), n = __read();</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        ll a = __read(), b = __read(), x = __read(), k = __read(), d = gcd(a, b);</span><br><span class="line"></span><br><span class="line">        upt[d] = x / (a / d) / (b / d) % mod;</span><br><span class="line">        <span class="keyword">if</span> (!che[d]) &#123;</span><br><span class="line">            stk[++top] = d;</span><br><span class="line">            che[d] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">ll <span class="title">ans</span><span class="params">(sum(k))</span></span>;</span><br><span class="line">        ans = ans * ans % mod;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= top; ++i) &#123;</span><br><span class="line">            d = stk[i];</span><br><span class="line">            ans = (ans + ((upt[d] - d * d % mod) % mod + mod) % mod * f[k / d] % mod) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>莫比乌斯反演</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>Closest Equals</title>
    <url>/2020/09/15/Closest-Equals/</url>
    <content><![CDATA[<h1 id="Closest-Equals"><a href="#Closest-Equals" class="headerlink" title="Closest Equals"></a><a href="https://ac.nowcoder.com/acm/problem/110867" target="_blank" rel="noopener">Closest Equals</a></h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意:"></a>题目大意:</h2><p>给你一串数,有$m$次询问,每次求问一个区间$[l,r]$,问在区间内最近的两个相同的数的距离是多少</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h2><p>第一反应就是记录一下这个值上一次出现的位置,这就可以记录一次答案了</p>
<p>然后可以构造出一个新的序列,因为当某两个可行的数在另外两个可行的数内时,外面的数是没有贡献的</p>
<p>然后就可以找到第一个$prev[i]\ge l$的$i$, 然后再找到最后一个$last[i]\le r$</p>
<p>这就构成了一个新的可行区间</p>
<p>那么如果找到的新的$r &lt; l$那么这就是无解的, 直接输出$-1$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> __read()</span><br><span class="line">&#123;</span><br><span class="line">    int x(0), t(1);</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">'0'</span> || o &gt; <span class="string">'9'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">'-'</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">'0'</span> &amp;&amp; o &lt;= <span class="string">'9'</span>; o = getchar()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, cnt, cur;</span><br><span class="line"><span class="keyword">int</span> a[maxn], d[maxn], p[maxn], f[maxn][<span class="number">25</span>];</span><br><span class="line"><span class="keyword">int</span> __prev[maxn],  __last[maxn], __log[maxn] = &#123;<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="built_in">map</span> &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; Vis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> _lower_bound(<span class="keyword">int</span> x)</span><br><span class="line">&#123;</span><br><span class="line">    int l(1), r(cur), ans(cur + 1);</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">mid</span><span class="params">((l + r) &gt;&gt; <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (__prev[mid] &lt; x) l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> ans = mid, r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> _upper_bound(<span class="keyword">int</span> x)</span><br><span class="line">&#123;</span><br><span class="line">    int l(1), r(cur), ans(cur + 1);</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">mid</span><span class="params">((l + r) &gt;&gt; <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (__last[mid] &lt;= x) l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> ans = mid, r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">min__</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &lt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = __read(), m = __read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i(<span class="number">1</span>); i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = __read();</span><br><span class="line">        <span class="keyword">if</span> (!Vis[temp]) Vis[temp] = ++cnt;</span><br><span class="line">        a[i] = Vis[temp];</span><br><span class="line">        <span class="keyword">int</span> j = p[a[i]];</span><br><span class="line">        p[a[i]] = i;</span><br><span class="line">        <span class="keyword">if</span> (__prev[cur] &gt;= j) <span class="keyword">continue</span>;</span><br><span class="line">        __prev[++cur] = j, __last[cur] = i, d[cur] = i - j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i(<span class="number">1</span>); i &lt;= cur; ++i)</span><br><span class="line">        f[i][<span class="number">0</span>] = d[i], __log[i] = __log[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j(<span class="number">1</span>); (<span class="number">1</span> &lt;&lt; j) &lt;= cur; ++j)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i(<span class="number">1</span>); i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= cur; ++i)</span><br><span class="line">            f[i][j] = min__(f[i][j - <span class="number">1</span>], f[i + (<span class="number">1</span> &lt;&lt; j - <span class="number">1</span>)][j - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = _lower_bound(__read()), y = _upper_bound(__read());</span><br><span class="line">        <span class="keyword">if</span> (y &lt; x) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = __log[y - x + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"%d\n"</span>, min__(f[x][len], f[y - (<span class="number">1</span> &lt;&lt; len) + <span class="number">1</span>][len]));</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>RMQ</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>HAOI2015树上染色</title>
    <url>/2020/07/21/HAOI2015%E6%A0%91%E4%B8%8A%E6%9F%93%E8%89%B2/</url>
    <content><![CDATA[<h1 id="HAOI2015-树上染色"><a href="#HAOI2015-树上染色" class="headerlink" title="[HAOI2015]树上染色"></a><a href="https://loj.ac/problem/2124" target="_blank" rel="noopener">[HAOI2015]树上染色</a></h1><p>简单的说, 就是求树上所有边对答案的贡献之和</p>
<p>我们可以用$Dp[i][j]$表示以$i$为根的子树内, 有$j$个点为黑点的情况下, 这个子树中的边对答案的贡献之和</p>
<p>每次新加入一个$i$的子节点时, 另新节点中有$k$个黑点, 那么:</p>
<script type="math/tex; mode=display">
Dp[i][j]=max(Dp[i][j],\; Dp[i][j-k]+Dp[i_{new}]+W_{new}*Times);\\
其中Times=子树内的黑点*子树外的黑点+子树内的白点*子树外的白点</script><p>所以这道题就算是做完了</p>
<p>$Dp$一定要考虑好状态的<strong>表示, 转移和初始化</strong></p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">2e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> N, K, U, V, W, Size[Maxn];</span><br><span class="line"><span class="keyword">int</span> Head[Maxn], E[Maxn &lt;&lt; <span class="number">1</span>], Cost[Maxn &lt;&lt; <span class="number">1</span>], Next[Maxn &lt;&lt; <span class="number">1</span>], Cur;</span><br><span class="line">ll Dp[Maxn][Maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> U, <span class="keyword">int</span> V, <span class="keyword">int</span> W)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Next[++Cur] = Head[U];</span><br><span class="line">    Head[U] = Cur;</span><br><span class="line">    E[Cur] = V;</span><br><span class="line">    Cost[Cur] = W;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> U, <span class="keyword">int</span> _F)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Size[U] = <span class="number">1</span>;</span><br><span class="line">    Dp[U][<span class="number">0</span>] = Dp[U][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = Head[U]; i; i = Next[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> V = E[i];</span><br><span class="line">        <span class="keyword">if</span> (V == _F) <span class="keyword">continue</span>;</span><br><span class="line">        DFS(V, U);</span><br><span class="line">        Size[U] += Size[V];</span><br><span class="line">        <span class="keyword">int</span> W = Cost[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = min(K, Size[U]); i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= min(i, Size[V]); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (Dp[U][i - j] == <span class="number">-1</span>) <span class="keyword">continue</span>;<span class="comment">//不成立的直接跳过</span></span><br><span class="line">                ll Val = W * ((ll)j * (K - j) + (ll)(Size[V] - j) * (N - K + j - Size[V]));</span><br><span class="line">                Dp[U][i] = max(Dp[U][i], Dp[U][i - j] + Dp[V][j] + Val);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(Dp, <span class="number">-1</span>, <span class="keyword">sizeof</span> Dp);<span class="comment">//初始化, 因为有些状态是不会成立的</span></span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%d %d"</span>, &amp;N, &amp;K);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">"%d %d %d"</span>, &amp;U, &amp;V, &amp;W);</span><br><span class="line">        AddEdge (U, V, W), AddEdge(V, U, W);</span><br><span class="line">    &#125;</span><br><span class="line">    DFS (<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"%lld\n"</span>, Dp[<span class="number">1</span>][K]);</span><br><span class="line">    system (<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>树型Dp</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU6035 Colorful Tree</title>
    <url>/2020/07/21/HDU6035%20Colorful%20Tree/</url>
    <content><![CDATA[<h1 id="Colorful-Tree"><a href="#Colorful-Tree" class="headerlink" title="Colorful Tree"></a><a href="https://vjudge.net/problem/HDU-6035" target="_blank" rel="noopener">Colorful Tree</a></h1><p>简言之, 求总权值减去不合法的权值</p>
<p>即对于每种颜色, 求不经过这种颜色的边的个数</p>
<p>考虑删除这种颜色, 那么剩下的点会构成几个连通块, 对于每个连通块的权值都为$Size*(Size-1)/2$</p>
<p>一遍$DFS$貌似可以解决了</p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> Head[Maxn], E[Maxn &lt;&lt; <span class="number">1</span>], Next[Maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> N, U, V, Tot, Cur, C[Maxn];</span><br><span class="line"><span class="keyword">bool</span> Vis[Maxn];</span><br><span class="line">ll Sum[Maxn], Size[Maxn];</span><br><span class="line">ll Res;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> U, <span class="keyword">int</span> V)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Next[++Cur] = Head[U];</span><br><span class="line">    Head[U] = Cur;</span><br><span class="line">    E[Cur] = V;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> U, <span class="keyword">int</span> _F)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Size[U] = <span class="number">1</span>;</span><br><span class="line">    ll X = Sum[C[U]], Y = X;<span class="comment">//这一步很妙啊</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = Head[U]; i; i = Next[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> V = E[i];</span><br><span class="line">        <span class="keyword">if</span> (V == _F) <span class="keyword">continue</span>;</span><br><span class="line">        DFS (V, U);</span><br><span class="line">        Size[U] += Size[V];</span><br><span class="line">        ll Temp = Size[V] - Sum[C[U]] + X;<span class="comment">//好好想为啥</span></span><br><span class="line">        Res += (Temp - <span class="number">1</span>) * Temp / <span class="number">2</span>;</span><br><span class="line">        X = Sum[C[U]];</span><br><span class="line">    &#125;</span><br><span class="line">    Sum[C[U]] += Size[U] - (Sum[C[U]] - Y);<span class="comment">//简直妙哉</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span> (Head, <span class="number">0</span>, <span class="keyword">sizeof</span> Head);</span><br><span class="line">    <span class="built_in">memset</span> (Sum, <span class="number">0</span>, <span class="keyword">sizeof</span> Sum);</span><br><span class="line">    <span class="built_in">memset</span> (Vis, <span class="number">0</span>, <span class="keyword">sizeof</span> Vis);</span><br><span class="line">    Tot = Res = Cur = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Case</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span> (<span class="string">"%d"</span>, &amp;N) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        Init();</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">Cnt</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span> (<span class="string">"%d"</span>, C + i);</span><br><span class="line">            <span class="keyword">if</span> (!Vis[C[i]]) ++Cnt, Vis[C[i]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span> (<span class="string">"%d %d"</span>, &amp;U, &amp;V);</span><br><span class="line">            AddEdge(U, V), AddEdge(V, U);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DFS(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        ll Ans = <span class="number">1l</span>l * N * (N - <span class="number">1</span>) * Cnt / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">            <span class="keyword">if</span> (Vis[i])</span><br><span class="line">            &#123;</span><br><span class="line">                ll Temp = N - Sum[i];</span><br><span class="line">                Ans -= Temp * (Temp - <span class="number">1</span>) / <span class="number">2</span>;<span class="comment">//这个是最后一个连通块</span></span><br><span class="line">            &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"Case #%d: %lld\n"</span>, ++Case, Ans - Res);</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>树型Dp</tag>
      </tags>
  </entry>
  <entry>
    <title>[HEOI]2015公约数序列</title>
    <url>/2020/09/25/HEOI-2015%E5%85%AC%E7%BA%A6%E6%95%B0%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h1 id="HEOI2015-公约数数列"><a href="#HEOI2015-公约数数列" class="headerlink" title="[HEOI2015]公约数数列"></a><a href="https://www.luogu.com.cn/problem/P4108" target="_blank" rel="noopener">[HEOI2015]公约数数列</a></h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定一个序列，有两种操作</p>
<ul>
<li>修改第 $id$ 个数，让它变成$x$</li>
<li>查询最小的$id$，让他满足<script type="math/tex; mode=display">
(\otimes_{i=0}^{id}a_i)*\gcd(a_0,a_1\cdots a_{id})=x</script></li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这个$\gcd$有点东西，是这只可能不断变小的</p>
<p>所以这个是单调的，没鸟用</p>
<p>所以直接暴力分块乱搞，练练代码能力还是不错的选择</p>
<p>只是说有地方时可以优化的</p>
<p>比如说，当前$\gcd$前缀不是查询的$x$的约数，就可以直接跳过的</p>
<p>还有，如果说这个块对答案没有$\gcd$没有贡献，就可以直接二分查找异或前缀和了</p>
<p>然后似乎就完了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> ll __read()</span><br><span class="line">&#123;</span><br><span class="line">    ll x(0), t(1);</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">'0'</span> || o &gt; <span class="string">'9'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">'-'</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">'0'</span> &amp;&amp; o &lt;= <span class="string">'9'</span>; o = getchar()) &#123;</span><br><span class="line">        x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll x, ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (y == <span class="number">0</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> gcd(y, x % y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll n, p, q, a[maxn], l[<span class="number">505</span>], r[<span class="number">505</span>], id[maxn];</span><br><span class="line">ll gd[maxn], xr[maxn], map_id[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xr[x] == xr[y]) <span class="keyword">return</span> x &lt; y;</span><br><span class="line">    <span class="keyword">return</span> xr[x] &lt; xr[y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span><span class="params">(ll pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pos &gt; l[id[pos]]) &#123;</span><br><span class="line">        gd[pos] = gcd(gd[pos - <span class="number">1</span>], a[pos]);</span><br><span class="line">        xr[pos] = xr[pos - <span class="number">1</span>] ^ a[pos];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        gd[pos] = xr[pos] = a[pos];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = pos + <span class="number">1</span>; i &lt;= r[id[pos]]; ++i) &#123;</span><br><span class="line">        gd[i] = gcd(gd[i - <span class="number">1</span>], a[i]);</span><br><span class="line">        xr[i] = xr[i - <span class="number">1</span>] ^ a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(map_id + l[id[pos]], map_id + r[id[pos]] + <span class="number">1</span>, cmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Find</span><span class="params">(ll l, ll r, ll val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ll <span class="title">ans</span><span class="params">(l)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="function">ll <span class="title">mid</span> <span class="params">((l + r) &gt;&gt; <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (xr[map_id[mid]] &gt;= val) ans = mid, r = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Query</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans(-1), q_gd(a[1]), q_xr(0);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= id[n] &amp;&amp; ans == <span class="number">-1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x % gcd(q_gd, gd[r[i]])) &#123;</span><br><span class="line">            q_gd = gcd(q_gd, gd[r[i]]);</span><br><span class="line">            q_xr ^= xr[r[i]];</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (gcd(q_gd, gd[r[i]]) == q_gd) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x % q_gd == <span class="number">0</span>) &#123;</span><br><span class="line">                ll targer = (x / q_gd) ^ q_xr;</span><br><span class="line">                ll pos = Find(l[i], r[i], targer);</span><br><span class="line">                <span class="keyword">if</span> (xr[map_id[pos]] == targer) ans = map_id[pos];</span><br><span class="line">            &#125;</span><br><span class="line">            q_xr ^= xr[r[i]];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = l[i]; j &lt;= r[i]; ++j) &#123;</span><br><span class="line">                q_gd = gcd(q_gd, a[j]);</span><br><span class="line">                q_xr = q_xr ^ a[j];</span><br><span class="line">                <span class="keyword">if</span> (q_gd * q_xr == x) &#123;</span><br><span class="line">                    ans = j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> Opt[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = __read();</span><br><span class="line">    p = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        a[i] = __read();</span><br><span class="line">        id[i] = (i - <span class="number">1</span>) / p + <span class="number">1</span>;</span><br><span class="line">        map_id[i] = i;</span><br><span class="line">        <span class="keyword">if</span> (!l[id[i]]) l[id[i]] = i;</span><br><span class="line">        r[id[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= id[n]; ++i) Update(l[i]);</span><br><span class="line"></span><br><span class="line">    q = __read();</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">"%s"</span>, Opt);</span><br><span class="line">        <span class="keyword">if</span> (*Opt == <span class="string">'M'</span>) &#123;</span><br><span class="line">            ll pos = __read() + <span class="number">1</span>, x = __read();</span><br><span class="line">            a[pos] = x;</span><br><span class="line">            Update(pos);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ll x = __read();</span><br><span class="line">            ll ans = Query(x);</span><br><span class="line">            <span class="keyword">if</span> (ans == <span class="number">-1</span>) <span class="built_in">puts</span>(<span class="string">"no"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span> (<span class="string">"%lld\n"</span>, ans - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>[HEOI2014]南园满地推轻絮</title>
    <url>/2020/09/03/HEOI2014-%E5%8D%97%E5%9B%AD%E6%BB%A1%E5%9C%B0%E6%8E%A8%E8%BD%BB%E7%B5%AE/</url>
    <content><![CDATA[<h1 id="HEOI2014-南园满地推轻絮"><a href="#HEOI2014-南园满地推轻絮" class="headerlink" title="[HEOI2014]南园满地推轻絮"></a><a href="https://www.luogu.com.cn/problem/P4105" target="_blank" rel="noopener">[HEOI2014]南园满地推轻絮</a></h1><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>就是二分去找$\max(x)$, 满足$|a_i-b_i|\le x$</p>
<p>那么就是要让$b_i$尽可能小的满足$a_i-b_i&lt;x$，然后在保证$b_i$单调不下降的情况下，不等式是否成立</p>
<blockquote>
<p>  易证：</p>
<p> 当$x &gt; y$时，若$b_i$数组满足条件$a_i-b_i\le y$且$b_i$单调不下降，那么$b_i$数组也一定满足$a_i-b_i\le y$且$b_i$单调不下降</p>
<p> 那么有了这个性质就可以二分答案了，因为当小的取值成立时，大的取值一定成立</p>
</blockquote>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, sa, sb, sc, sd, p;</span><br><span class="line"><span class="keyword">int</span> l, r, ans, a[maxn], b[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1l</span>l * sa * x  % p * x % p * x % p + <span class="number">1l</span>l * sb * x % p * x % p + <span class="number">1l</span>l * sc * x % p + sd) % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Check</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b[<span class="number">1</span>] = max(<span class="number">0</span>, a[<span class="number">1</span>] - x);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        b[i] = max(b[i - <span class="number">1</span>], a[i] - x);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(b[i] - a[i]) &gt; x) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%d %d %d %d %d %d %d"</span>, &amp;n, &amp;sa, &amp;sb, &amp;sc, &amp;sd, a + <span class="number">1</span>, &amp;p);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) a[i] = (f(a[i - <span class="number">1</span>]) + f(a[i - <span class="number">2</span>])) % p, r = max(r, a[i]);</span><br><span class="line">    r = max(a[<span class="number">1</span>], r);</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (Check(mid)) ans = mid, r = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>CF703D Mishaka and Interesting sum</title>
    <url>/2020/09/15/Mishaka-and-Interesting-sum/</url>
    <content><![CDATA[<h1 id="CF703D-Mishka-and-Interesting-sum"><a href="#CF703D-Mishka-and-Interesting-sum" class="headerlink" title="CF703D Mishka and Interesting sum"></a><a href="https://www.luogu.com.cn/problem/CF703D" target="_blank" rel="noopener">CF703D Mishka and Interesting sum</a></h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意:"></a>题目大意:</h2><p>给定一个序列, 有$m$次询问</p>
<p>每次询问会给你一个$[l, r]$, 让你求区间内出现偶数次的数的异或和</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><p>首先我们可以想到异或的某些性质:$x\otimes y \otimes x = y$</p>
<p>那么我们可以转化一下题目的意思, 我们可以先求一次区间的异或和, 再去异或一个东西, 可能就是我们想要的答案了</p>
<p>那么抑或什么呢, 按照由题意, 要异或一个能让奇数变成偶数的东西, 简单地说, 就是异或这个区间所有出现的数的异或和, 而并非整个区间的异或和</p>
<p>那么这个就和$\text{HH}$的项链有点类似了</p>
<p>时间复杂度就是一个$O(n\log n)$的了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> __read()</span><br><span class="line">&#123;</span><br><span class="line">    int x(0), t(1);</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">'0'</span> || o &gt; <span class="string">'9'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">'-'</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">'0'</span> &amp;&amp; o &lt;= <span class="string">'9'</span>; o = getchar()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[maxn], sum[maxn], ans[maxn];</span><br><span class="line"><span class="keyword">int</span> n, m, cnt, tree[maxn];</span><br><span class="line"><span class="keyword">int</span> __prev[maxn], __last[maxn];</span><br><span class="line"><span class="built_in">map</span> &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; T;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, id;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp; T) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> r &lt; T.r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Que[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Update</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> val)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (p &lt;= n) &#123;</span><br><span class="line">        tree[p] ^= val;</span><br><span class="line">        p += lowbit(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ans</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        ans ^= tree[p];</span><br><span class="line">        p -= lowbit(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Query(r) ^ Query(l - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = __read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i(<span class="number">1</span>); i &lt;= n; i++) &#123;</span><br><span class="line">        a[i] = __read();</span><br><span class="line">        <span class="keyword">if</span> (!T[a[i]]) T[a[i]] = ++cnt;</span><br><span class="line">        <span class="keyword">int</span> p = T[a[i]];</span><br><span class="line">        __last[i] = __prev[p];</span><br><span class="line">        __prev[p] = i;</span><br><span class="line">        sum[i] = sum[i - <span class="number">1</span>] ^ a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    m = __read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i(<span class="number">1</span>); i &lt;= m; ++i)</span><br><span class="line">        Que[i].l = __read(), Que[i].r = __read(), Que[i].id = i;</span><br><span class="line">    sort (Que + <span class="number">1</span>, Que + m + <span class="number">1</span>);</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">p</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i(<span class="number">1</span>); i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (p &lt;= Que[i].r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (__last[p]) Update(__last[p], a[p]);\\确保这个数只有一次的贡献</span><br><span class="line">            Update(p, a[p]);</span><br><span class="line">            ++p;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[Que[i].id] = Query(Que[i].l, Que[i].r) ^ sum[Que[i].r] ^ sum[Que[i].l - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i(<span class="number">1</span>); i &lt;= m; ++i) <span class="built_in">printf</span> (<span class="string">"%d\n"</span>, ans[i]);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>Min_25筛</title>
    <url>/2020/09/20/Min-25%E7%AD%9B/</url>
    <content><![CDATA[<h1 id="Min-25筛"><a href="#Min-25筛" class="headerlink" title="Min_25筛"></a>Min_25筛</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>用来处理积性函数前缀和的不错选择， 时间复杂度为$O(\frac{n^{\frac 34}}{\log_2n})$，空间复杂度为$O(\sqrt n)$</p>
<p><strong>限制：</strong>要求质数$p$处的函数值是个多项式，且$p^k$处的函数值也容易计算</p>
<p><strong>规定：</strong></p>
<ul>
<li>$\mathbb{P}$表示素数集合</li>
<li>$cnt$表示$n$范围内的素数个数</li>
<li>$p_i$表示第$i$个素数，特别的$p_0=0$</li>
<li>$lpf(x)$表示$x$的最小质因子</li>
<li>$F(x)$是我们要求的一个积性函数</li>
<li>$f(i)$是我们构造出来的计算方式与$F(x)$相似的完全积性函数</li>
</ul>
<h2 id="计算方式"><a href="#计算方式" class="headerlink" title="计算方式"></a>计算方式</h2><p>大致思路是将$F(x)$分为两部分来考虑，一部分是素数，另一部分是合数</p>
<h3 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1"></a>Step 1</h3><ul>
<li><p>先考虑求解：</p>
<script type="math/tex; mode=display">
\sum_{i=1}^{cnt}F(p_i)=\sum_{x=1}^nF(x)[x\in \mathbb{P}]</script></li>
<li><p>定义二元函数$g$：</p>
<script type="math/tex; mode=display">
g(n,j)=\sum_{i=2}^nf(i)[i\in \mathbb{p}\;\lor\; lpf(i)>p_j]</script></li>
</ul>
<p><strong>注：</strong></p>
<ul>
<li><p>这里的$f(i)$的具体计算方式与$i\in\mathbb{p}$时的$F(i)$的计算方式相同，如当$F(x)=\varphi(x)$时$f(x)=x-1$，即得到的应当是一个完全积性函数</p>
</li>
<li><p>所以我们可以发现，当且仅当$j=cnt$时，所求得的值才是要求的值</p>
</li>
<li><p>这里可以易证$lpf(i)\le \sqrt n$，即若$lpf(j)^2\ge n$，则$g(n,j)=g(n,j-1)$，因为不存在$lpf(i)&gt;p_j$， 否则：</p>
<script type="math/tex; mode=display">
g(n,j)=g(n,j-1)-f(p_j)\cdot\big(g(\frac{n}{p_j},j-1)-g(p_{j-1},j-1)\big)</script></li>
</ul>
<p><strong>证明：</strong></p>
<script type="math/tex; mode=display">
\begin{align*}
g(n,j)&=\sum_{i=2}^nf(i)[i\in\mathbb{P}\;\lor\;lpf(i)>p_j]\\
g(n,j-1)&=\sum_{i=2}^nf(i)[i\in\mathbb{P}\;\lor\;lpf(i)>p_{j-1}]\\
\end{align*}</script><ul>
<li><p>那么我们就可以发现，从$j-1$递推到$j$的过程中，我们多计算了一部分贡献，就是$i\notin \mathbb{P} \;\land\; i\ne 1 \;\land\; lpf(i)=p_j$这一部分的贡献</p>
</li>
<li><p>所以我们要减去它们</p>
</li>
<li><p>那么这一部分共有的特点就是都存在最小的质因子$p_j$</p>
</li>
<li><p>那么我们就可以先把$f(p_j)$提出来</p>
</li>
<li><p>即剩下的部分的贡献可以表示为：$\big(g(\frac n{p_j},j-1)-g(p_j-1,j-1)\big)$</p>
</li>
</ul>
<blockquote>
<ul>
<li><p>关于</p>
</li>
<li><script type="math/tex; mode=display">
f(p_j)\cdot g(p_{j-1},j-1)</script></li>
<li><p>这一部分又可以写为:</p>
</li>
<li><script type="math/tex; mode=display">
\sum_{i=1}^{j-1}f(p_i\cdot p_j)</script></li>
<li><p>发现这一部分的数并满足上文所说的$i\notin \mathbb{P} \;\land\; i\ne 1 \;\land\; lpf(i)=p_j$，所以这不能减，得消掉</p>
</li>
</ul>
</blockquote>
<ul>
<li><p>于是就得到了$g$的递推式，进而可以将空间压缩至$\sqrt n$</p>
</li>
<li><p>对于$g$的第一维，其实只有$\frac n1,\frac n2,\frac n3\cdots\frac nn$这些值有被用到。观察递推式，第一位的转移只有$n\rightarrow \frac np$，而下取整又满足结合律：</p>
</li>
<li><script type="math/tex; mode=display">
\left\lfloor\frac{\lfloor\frac {n}{a}\rfloor}{b}\right\rfloor=\left\lfloor\frac{n}{ab}\right\rfloor</script></li>
<li><p>所以无论怎样，这个函数只会用到那么$\sqrt n$个值</p>
</li>
<li><p>对于$g$的第二维，转移只有$j\rightarrow j-1$，与此同时第一位也在缩小，所以我们从大到小更新，就可以直接滚掉第二维</p>
</li>
</ul>
<p><del>据说这一步的时间复杂度就是$O(\frac{n^{\frac {3}{4}}}{\log_2n})$</del></p>
<h3 id="Step-2"><a href="#Step-2" class="headerlink" title="Step 2"></a>Step 2</h3><p>现在，我们要求的就是</p>
<script type="math/tex; mode=display">
ans=\sum_{i=1}^nf(i)</script><ul>
<li><p>定义二元函数$S$：</p>
</li>
<li><script type="math/tex; mode=display">
S(n,j)=\sum_{i=2}^nF(i)[lpf(i)> p_j]</script></li>
<li><p>显然$ans=S(n,0)$</p>
</li>
<li><p>考虑将答案拆分成素数和合数两个部分计算</p>
</li>
<li><p>显然素数部分的贡献为 </p>
</li>
<li><script type="math/tex; mode=display">
S(n,j)_{素}=g(n,cnt)-g(p_j,j)</script></li>
<li><p>在考虑合数部分：枚举一批数的最小质因子为$p_k$，指数为$e$，那么就可以不重复的计算$lpf(i)\ge p_k$的合数</p>
</li>
<li><p>因为枚举了幂次，所以将${p_k}^e$提出来后，这批数就没有质因子$p_k$了，就可积了</p>
</li>
<li><p><strong>注意</strong>，${p_k}^e$并没有被看作合数，所以贡献是还要加上去的</p>
</li>
<li><p>不用记忆化，直接递归计算即可，边界为$p_j &gt;n,S(n,j)=0$</p>
</li>
<li><script type="math/tex; mode=display">
S(n,j)=g(n,cnt)-g(p_j,j)+\sum_{k=j}^{p_k^2\le n}\sum_{e=1}^{p_k^e\le n}F(p_k^e)(S(\left\lfloor\frac n{p_k^e}\right\rfloor,k)+[e\ne1]</script></li>
<li><p>总时间复杂度为$O(\frac{n^{\frac {3}{4}}}{\log_2n})$</p>
</li>
</ul>
<h2 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2><script type="math/tex; mode=display">
 \begin{aligned} T(n) &= \sum_{i^{2} \le n} O\left(\pi\left(\sqrt{i}\right)\right) + \sum_{i^{2} \le n} O\left(\pi\left(\sqrt{\frac{n}{i}}\right)\right) \\ &= \sum_{i^{2} \le n} O\left(\frac{\sqrt{i}}{\ln{\sqrt{i}}}\right) + \sum_{i^{2} \le n} O\left(\frac{\sqrt{\frac{n}{i}}}{\ln{\sqrt{\frac{n}{i}}}}\right) \\ &= O\left(\int_{1}^{\sqrt{n}} \frac{\sqrt{\frac{n}{x}}}{\log{\sqrt{\frac{n}{x}}}} \mathrm{d} x\right) \\ &= O\left(\frac{n^{\frac{3}{4}}}{\log{n}}\right) \end{aligned}</script><p><del>直接表示看不懂好吧，跑路了</del></p>
<h1 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h1><h2 id="Min-25筛-1"><a href="#Min-25筛-1" class="headerlink" title="Min_25筛"></a><a href="https://www.luogu.com.cn/problem/P5325" target="_blank" rel="noopener">Min_25筛</a></h2><h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><p>求：$\sum_{i=1}^nF(i)$</p>
<p>其中$\forall p\in \mathbb{P}\quad\forall k\in[1,\inf]\quad F(p^k)=p^k(p^k-1)$</p>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>那么我们可以直接另$f(i) = i(i-1)$</p>
<p>然后就可以直接做了，完全的套式子，十分无脑</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> ll inv = <span class="number">166666668</span>;</span><br><span class="line"></span><br><span class="line">ll n;</span><br><span class="line">ll sq, tot, pr[maxn], id1[maxn], id2[maxn], w[maxn];</span><br><span class="line">ll cnt, sum1[maxn], sum2[maxn], g1[maxn], g2[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">inc</span><span class="params">(ll &amp;x, ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x += y;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= mod) x -= mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">add</span><span class="params">(ll x, ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll temp = x + y;</span><br><span class="line">    <span class="keyword">return</span> temp &gt;= mod ? temp - mod : temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sq = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">2</span>; i &lt;= sq; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) pr[++cnt] = i;</span><br><span class="line">        <span class="keyword">for</span> (ll j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; pr[j] * i &lt;= sq; ++j) &#123;</span><br><span class="line">            vis[i * pr[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (!(i % pr[j])) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= cnt; ++i)</span><br><span class="line">        inc(sum1[i], add(sum1[i - <span class="number">1</span>], pr[i])),</span><br><span class="line">        inc(sum2[i], add(sum2[i - <span class="number">1</span>], <span class="number">1l</span>l * pr[i] * pr[i] % mod));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">id</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= sq) <span class="keyword">return</span> id1[x];</span><br><span class="line">    <span class="keyword">return</span> id2[n / x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">f1</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x %= mod;</span><br><span class="line">    <span class="keyword">return</span> x * (x + <span class="number">1</span>) / <span class="number">2</span> % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">f2</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x %= mod;</span><br><span class="line">    <span class="keyword">return</span> x * (x + <span class="number">1</span>) % mod * (<span class="number">2</span> * x % mod + <span class="number">1</span>) % mod * inv % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">S</span><span class="params">(ll x, ll j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pr[j] &gt; x) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ll ans = ((g2[id(x)] - g1[id(x)] + mod) % mod - (sum2[j] - sum1[j] + mod) % mod + mod) % mod;</span><br><span class="line">    <span class="keyword">for</span> (ll i = j + <span class="number">1</span>; i &lt;= cnt &amp;&amp; <span class="number">1l</span>l * pr[i] * pr[i] &lt;= x; ++i)</span><br><span class="line">        <span class="keyword">for</span> (ll e = <span class="number">1</span>, sp = pr[i]; sp &lt;= x; sp *= pr[i], ++e)</span><br><span class="line">            ans = (ans + sp % mod * (sp % mod - <span class="number">1</span>) % mod * (S(x / sp, i) + (e &gt; <span class="number">1</span>)) % mod) % mod;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%lld"</span>, &amp;n);</span><br><span class="line">    init();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ll l = <span class="number">1</span>, r; l &lt;= n; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">        r = n / (n / l);</span><br><span class="line">        w[++tot] = n / l;</span><br><span class="line">        g1[tot] = f1(w[tot]) - <span class="number">1</span>, g2[tot] = f2(w[tot]) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (w[tot] &lt;= sq) id1[w[tot]] = tot;</span><br><span class="line">        <span class="keyword">else</span> id2[n / w[tot]] = tot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= cnt; ++i)</span><br><span class="line">        <span class="keyword">for</span> (ll j = <span class="number">1</span>; j &lt;= tot &amp;&amp; <span class="number">1l</span>l * pr[i] * pr[i] &lt;= w[j]; ++j) &#123;</span><br><span class="line">            ll k = id(w[j] / pr[i]);</span><br><span class="line">            g1[j] = (g1[j] - pr[i] * (g1[k] - sum1[i - <span class="number">1</span>]) % mod + mod) % mod;</span><br><span class="line">            g2[j] = (g2[j] - <span class="number">1l</span>l * pr[i] * pr[i] % mod * (g2[k] - sum2[i - <span class="number">1</span>]) % mod + mod) % mod;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"%lld\n"</span>, (S(n, <span class="number">0</span>) + <span class="number">1</span>) % mod);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>参考资料：</strong></p>
<p><a href="http://jklover.hs-blog.cf/2019/06/05/min-25筛学习笔记/" target="_blank" rel="noopener">JKLover(姥爷的原味博客)</a></p>
<p><a href="https://oi-wiki.org/math/min-25/" target="_blank" rel="noopener">OI-wiki不是给人看的好东西</a></p>
]]></content>
      <tags>
        <tag>Min_25筛</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>MooFest</title>
    <url>/2020/09/15/MooFest/</url>
    <content><![CDATA[<h1 id="MooFest"><a href="#MooFest" class="headerlink" title="MooFest"></a><a href="https://www.luogu.com.cn/problem/P5094" target="_blank" rel="noopener">MooFest</a></h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>其实我们发现这个$\max$十分不好维护</p>
<p>就是说，如果已经保证了$v_i\ge v_j$，那么原式可以写为</p>
<script type="math/tex; mode=display">
\sum_{i=1}^nv_i\sum_{j=1}^ndis(i,j)</script><p>这个按照$v_i$从大到小就可以了吧</p>
<p>那么就是$\sum_{j=i+1}^ndis(i,j)$的问题了</p>
<p>这个看看数据，这个大概是需要一个$\log$的复杂度</p>
<p>那么发现像什么线段树，树状数组之类的<del>高级</del>数据结构就可以维护</p>
<p>就分成两种情况，一种是$x_p&gt;x_i$的，一种是$x_p &lt; x_i$的</p>
<p>那就分别求和，那么就可以写成这样</p>
<script type="math/tex; mode=display">
sum\{x_p[x_p>x_i]\}-cnt\{[x_p>x_i]\}*x_i+cnt\{[x_p<x_i]\}*x_i-sum\{x_p[x_p<x_i]\}</script><h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><p>这个用了一个十分易懂的方式来维护</p>
<p>那就是先按照$x_i$从小到大排序</p>
<p>用树状数组一个点一个点插入，记录一下每头牛的$x_i$的排序，方便下文的删除操作</p>
<p>然后再按$v_i$从大到小排序</p>
<p>然后每次就查询完了就从树状数组中把这头牛删掉</p>
<p>然后重载了一下运算符，操作可能会方便一些吧</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> p = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function">ll <span class="title">ans</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span><span class="keyword">int</span> v, x, p;&#125;c[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmpx</span><span class="params">(node x, node y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.x &lt; y.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmpv</span><span class="params">(node x, node y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.v &gt; y.v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"><span class="keyword">int</span> tree[maxn], cnt[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v, <span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x &lt;= n) &#123;</span><br><span class="line">        tree[x] += v;</span><br><span class="line">        cnt[x] += p;</span><br><span class="line">        x += lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline pair&lt;int, int&gt; query(int x)</span><br><span class="line">&#123;</span><br><span class="line">    int ans(0), cur(0);</span><br><span class="line">    <span class="keyword">while</span> (x) &#123;</span><br><span class="line">        ans += tree[x];</span><br><span class="line">        cur += cnt[x];</span><br><span class="line">        x -= lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> make_pair(ans, cur);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sum first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> num second</span></span><br><span class="line"></span><br><span class="line">pair &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="keyword">operator</span> - (pair &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; a, pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> make_pair (a.sum - b.sum, a.num - b.num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline pair&lt;int, int&gt; query(int l, int r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> query(r) - query(l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span> (<span class="string">"%d %d"</span>, &amp;c[i].v, &amp;c[i].x);</span><br><span class="line">    sort (c + <span class="number">1</span>, c + n + <span class="number">1</span>, cmpx);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) add(i, c[i].x, <span class="number">1</span>), c[i].p = i;</span><br><span class="line">    sort (c + <span class="number">1</span>, c + n + <span class="number">1</span>, cmpv);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        pair &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; r = query(c[i].p, n), l = query(c[i].p - <span class="number">1</span>);</span><br><span class="line">        ans += <span class="number">1l</span>l * c[i].v * (r.sum - r.num * c[i].x + l.num * c[i].x - l.sum);</span><br><span class="line">        add(c[i].p, -c[i].x, <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>[NOI2018]屠龙勇士</title>
    <url>/2020/09/23/NOI2018-%E5%B1%A0%E9%BE%99%E5%8B%87%E5%A3%AB/</url>
    <content><![CDATA[<h1 id="NOI2018-屠龙勇士"><a href="#NOI2018-屠龙勇士" class="headerlink" title="[NOI2018]屠龙勇士"></a><a href="https://www.luogu.com.cn/problem/P4774" target="_blank" rel="noopener">[NOI2018]屠龙勇士</a></h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>你有一些刀，然后要去杀龙吃</p>
<p>没把刀都有自己的攻击力</p>
<p>然后固定每次砍它多少刀，然后龙还会回血。。。</p>
<p>如果能刚好回到零，这龙才是彻底的死了，可以吃了</p>
<p>否则输出 $-1$ </p>
<h2 id="Sulotion"><a href="#Sulotion" class="headerlink" title="Sulotion"></a>Sulotion</h2><p>对于这些剑​🗡​，你可以写平衡树维护，支持查询，删除，还有插入操作（<del>还tm可能有重复元素</del>）</p>
<p>算了，$\text{STL}$大法好，$\text{multiset}$全都支持的，理论上平板电视也可以（我离$\text{AC}$只差一个$\text{C++11}$）</p>
<p>那么假设已经得到了所有应该用的剑，那么就可以得到如下好东西：</p>
<script type="math/tex; mode=display">
\begin{cases}
atk_2\cdot x\equiv a_1\pmod {p_1}\\
atk_2\cdot x\equiv a_2\pmod {p_2}\\
\quad\vdots\\ 
atk_3\cdot x\equiv a_3\pmod {p_3}\\
\end{cases}\\</script><p>还要满足所有的$atk_3\times x\ge p_3$</p>
<p>所以还要维护一个$\max(\left\lceil\frac {p_i}{atk_i}\right\rceil)$</p>
<p>那么把所有的$atk_i$的逆元乘到右边去似乎就可以了？</p>
<p>由于题目并不保证互质，所以再操作前是一定一定要判断操作是否是可行的</p>
<p>似乎就结束啦</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">double</span> ld;</span><br><span class="line"><span class="keyword">const</span> ll maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> ll __read()</span><br><span class="line">&#123;</span><br><span class="line">    ll x(0), t(1);</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">'0'</span> || o &gt; <span class="string">'9'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">'-'</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">'0'</span> &amp;&amp; o &lt;= <span class="string">'9'</span>; o = getchar()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll a[maxn], p[maxn], b[maxn];</span><br><span class="line">ll x, y, g;</span><br><span class="line"><span class="built_in">multiset</span> &lt;ll&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(ll a, ll b, ll &amp;x, ll &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b) &#123;</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">        g = a;</span><br><span class="line">        <span class="keyword">return</span> ;     </span><br><span class="line">    &#125;</span><br><span class="line">    exgcd(b, a % b, y, x);</span><br><span class="line">    y -= a / b * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">mul</span><span class="params">(ll a, ll b, ll mod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res = a * b - (ll)((ld)a / mod * b + <span class="number">1e-8</span>) * mod;</span><br><span class="line">    <span class="keyword">return</span> res &lt; <span class="number">0</span> ? res + mod : res % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll T = __read();</span><br><span class="line">    <span class="built_in">multiset</span> &lt;ll&gt; :: iterator it;</span><br><span class="line">    __next: <span class="keyword">while</span> (T--)&#123;</span><br><span class="line">        ll n = __read(), m = __read();</span><br><span class="line">        <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; ++i) a[i] = __read();</span><br><span class="line">        <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; ++i) p[i] = __read();</span><br><span class="line">        <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; ++i) b[i] = __read();</span><br><span class="line"></span><br><span class="line">        s.clear();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= m; ++i) s.insert(__read());</span><br><span class="line"></span><br><span class="line">        ll mx(0), c(0);</span><br><span class="line">        m = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            it = s.upper_bound(a[i]);</span><br><span class="line">            <span class="keyword">if</span> (it != s.begin()) --it;</span><br><span class="line">            ll atk = *it;</span><br><span class="line">            s.erase(it);</span><br><span class="line">            s.insert(b[i]);</span><br><span class="line">            mx = max(mx, (a[i] - <span class="number">1</span>) / atk + <span class="number">1</span>);</span><br><span class="line">            atk %= p[i], a[i] %= p[i];</span><br><span class="line">            <span class="keyword">if</span> (!atk &amp;&amp; a[i]) &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line">                <span class="keyword">goto</span> __next;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!atk &amp;&amp; !a[i]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            exgcd(atk, p[i], x, y);</span><br><span class="line">            <span class="keyword">if</span> (a[i] % g) &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line">                <span class="keyword">goto</span> __next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            p[i] /= g;</span><br><span class="line">            a[i] = mul(a[i] / g, (x % p[i] + p[i]) % p[i], p[i]);</span><br><span class="line"></span><br><span class="line">            exgcd(m, p[i], x, y);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((a[i] - c) % g) &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line">                <span class="keyword">goto</span> __next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            m = m / g * p[i];</span><br><span class="line">            c = (c + mul(mul(m / p[i], (x % m + m) % m, m), ((a[i] - c) % m + m) % m, m)) % m;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"%lld\n"</span>, c &gt;= mx ? c : c + m * ((mx - c - <span class="number">1</span>) / m + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数论</tag>
        <tag>数学</tag>
        <tag>同余方程</tag>
      </tags>
  </entry>
  <entry>
    <title>NOI2020游记</title>
    <url>/2020/08/18/NOI2020%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[

	<div class="row">
    <embed src="day1.pdf" width="100%" height="550" type="application/pdf">
	</div>



<h1 id="T1-美食家（delicacy）"><a href="#T1-美食家（delicacy）" class="headerlink" title="T1:美食家（delicacy）"></a>T1:<strong>美食家（delicacy）</strong></h1><p>不知道是个什么题，网络流也没想好怎么维护</p>
<p>暴力：<del>直接跑</del></p>
<p>先鸽着</p>
]]></content>
      <tags>
        <tag>NOI</tag>
        <tag>鸽~</tag>
      </tags>
  </entry>
  <entry>
    <title>NOIP2019</title>
    <url>/2020/09/16/NOIP2019/</url>
    <content><![CDATA[<h1 id="Day1T1-格雷码"><a href="#Day1T1-格雷码" class="headerlink" title="Day1T1 格雷码"></a>Day1T1 <a href="https://www.luogu.com.cn/problem/P5657" target="_blank" rel="noopener">格雷码</a></h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这个找找规律模拟一下即可, 注意要开$\text{ULL}$, 否则会挂掉</p>
<p><del>规律记不得了</del></p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line">ll N(1), M, K;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; M &gt;&gt; K;</span><br><span class="line">    <span class="keyword">while</span> (--M) N &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (N)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (K &gt;= N) <span class="built_in">putchar</span>(<span class="string">'1'</span>), K = N - K % N - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">putchar</span>(<span class="string">'0'</span>);</span><br><span class="line">        N &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Day1T2-括号树"><a href="#Day1T2-括号树" class="headerlink" title="Day1T2 括号树"></a>Day1T2 <a href="https://www.luogu.com.cn/problem/P5658" target="_blank" rel="noopener">括号树</a></h1><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>用栈进行括号匹配, 如果能匹配上, 那么当前位置的答案就是他的父节点的答案加上这个节点有的贡献, 那么就十分的简单了</p>
<h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll maxn = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> ll __read()</span><br><span class="line">&#123;</span><br><span class="line">    ll x(0), t(1);</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">'0'</span> || o &gt; <span class="string">'9'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">'-'</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">'0'</span> &amp;&amp; o &lt;= <span class="string">'9'</span>; o = getchar()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll stk[maxn], f[maxn], top, cur, ans;</span><br><span class="line">ll sta[maxn], sum[maxn], size[maxn];</span><br><span class="line">ll head[maxn], _edge[maxn], _next[maxn];</span><br><span class="line"><span class="keyword">char</span> opt[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Addedge</span><span class="params">(ll u, ll v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _next[++cur] = head[u];</span><br><span class="line">    head[u] = cur;</span><br><span class="line">    _edge[cur] = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(ll u, ll fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ll <span class="title">left</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (sta[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (top) &#123;</span><br><span class="line">            left = stk[top];</span><br><span class="line">            size[u] = size[f[left]] + <span class="number">1</span>;</span><br><span class="line">            --top;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> stk[++top] = u;</span><br><span class="line">    sum[u] = sum[fa] + size[u];</span><br><span class="line">    <span class="keyword">for</span> (ll i = head[u]; i; i = _next[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_edge[i] == fa) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(_edge[i], u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left) stk[++top] = left;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (top) --top;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n = __read();</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%s"</span>, opt + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; ++i) sta[i] = (opt[i] == <span class="string">')'</span>);</span><br><span class="line">    <span class="keyword">for</span> (ll i(<span class="number">2</span>); i &lt;= n; ++i) &#123;</span><br><span class="line">        f[i] = __read();</span><br><span class="line">        Addedge(f[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; ++i) ans ^= (i * sum[i]);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Day1T3-树上的数"><a href="#Day1T3-树上的数" class="headerlink" title="Day1T3 树上的数"></a>Day1T3 <a href="https://www.luogu.com.cn/problem/P5659" target="_blank" rel="noopener">树上的数</a></h1><p>鸽~</p>
<hr>
<h1 id="Day2T1-Emiya-家今天的饭"><a href="#Day2T1-Emiya-家今天的饭" class="headerlink" title="Day2T1 Emiya 家今天的饭"></a>Day2T1 <a href="https://www.luogu.com.cn/problem/P5664" target="_blank" rel="noopener">Emiya 家今天的饭</a></h1><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>那么首先考虑容斥, 我们用所有方案减去不可行的方案</p>
<p>设计转移方程 : $Dp[i][j][k]$表示在第$i$种烹饪方式时选择第$j$种食材, 且这种食材比其他食材多用了$k$次</p>
<p>由于$k$有可能是负数, 所以我们给了一个$n$的偏移量</p>
<p>那么$Dp[i][j][k]=Dp[i-1][j][k]+Dp[i-1][k-1]<em>a[i][j]+Dp[i-1][k+1]</em>(sum[i]-a[i][j])$</p>
<p>所以不可行的方案就是$k&gt;n$的方案数</p>
<p>减去即可</p>
<h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> __read()</span><br><span class="line">&#123;</span><br><span class="line">    int x(0), t(1);</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">'0'</span> || o &gt; <span class="string">'9'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">'-'</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">'0'</span> &amp;&amp; o &lt;= <span class="string">'9'</span>; o = getchar()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[maxn][maxn * <span class="number">20</span>], sum[maxn][maxn * <span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> f[maxn][maxn * <span class="number">20</span>][maxn &lt;&lt; <span class="number">1</span>], ans(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = __read(), m = __read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) sum[i][<span class="number">0</span>] = (sum[i][<span class="number">0</span>] + (a[i][j] = __read())) % mod;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) sum[i][j] = (sum[i][<span class="number">0</span>] - a[i][j] + mod) % mod;</span><br><span class="line">        ans = <span class="number">1l</span>l * ans * (sum[i][<span class="number">0</span>] + <span class="number">1</span>) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    ans -= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">        f[<span class="number">0</span>][j][n] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = n - i; k &lt;= n + i; ++k)</span><br><span class="line">                f[i][j][k] = (f[i - <span class="number">1</span>][j][k] + <span class="number">1l</span>l * f[i - <span class="number">1</span>][j][k - <span class="number">1</span>] * a[i][j] % mod + <span class="number">1l</span>l * sum[i][j] * f[i - <span class="number">1</span>][j][k + <span class="number">1</span>] % mod) % mod; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            ans = (ans - f[n][j][n + i] + mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Day2T2-划分"><a href="#Day2T2-划分" class="headerlink" title="Day2T2 划分"></a>Day2T2 划分</h1><p>别急, 先鸽鸽~</p>
]]></content>
      <tags>
        <tag>NOI</tag>
        <tag>鸽~</tag>
        <tag>Dp优化</tag>
      </tags>
  </entry>
  <entry>
    <title>P1491集合位置</title>
    <url>/2020/07/20/P1491%E9%9B%86%E5%90%88%E4%BD%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="P1491-集合位置"><a href="#P1491-集合位置" class="headerlink" title="P1491 集合位置"></a><a href="https://www.luogu.com.cn/problem/P1491" target="_blank" rel="noopener">P1491 集合位置</a></h1><p>简言之: 求<strong>不严格</strong>的次短路</p>
<p>emmmm, 这个我们考虑$A^*$算法</p>
<p>估价函数$f(x)=g(x)+h(x)$, 其中$g(x)$表示从起点到$x$的花费, $h(x)$表示从$x$到终点的期望最小花费, 这个可以先跑一遍最短路处理出来</p>
<p>然后就是一个优先队列, 关键字为$f(x)$的升序队列, 跑一遍, 第$k$次跑到的终点就是$k$短路了</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">205</span>;</span><br><span class="line">pair &lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; P[Maxn];</span><br><span class="line"><span class="keyword">bool</span> Vis[Maxn];</span><br><span class="line"><span class="keyword">double</span> H[Maxn], Cost[<span class="number">40005</span>];</span><br><span class="line"><span class="keyword">int</span> Head[Maxn], Next[<span class="number">40005</span>], E[<span class="number">40005</span>], Cur;</span><br><span class="line"><span class="keyword">int</span> N, M, X, Y;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ANode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> X;</span><br><span class="line">    <span class="keyword">double</span> Dis;</span><br><span class="line">    <span class="keyword">bool</span> Vis[Maxn];</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> ANode &amp;Temp) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Dis + H[X] &gt; Temp.Dis + H[Temp.X];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">Dis</span><span class="params">(<span class="keyword">int</span> U, <span class="keyword">int</span> V)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="keyword">double</span>(P[U].x - P[V].x) * <span class="keyword">double</span>(P[U].x - P[V].x) + <span class="keyword">double</span>(P[U].y - P[V].y) * <span class="keyword">double</span>(P[U].y - P[V].y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> U, <span class="keyword">int</span> V)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Next[++Cur] = Head[U];</span><br><span class="line">    Head[U] = Cur;</span><br><span class="line">    E[Cur] = V;</span><br><span class="line">    Cost[Cur] = Dis(U, V);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">SPFA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) H[i] = <span class="number">1e9</span>;</span><br><span class="line">    <span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    Q.push(N);</span><br><span class="line">    H[N] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!Q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> X = Q.front();</span><br><span class="line">        Vis[X] = <span class="number">0</span>;</span><br><span class="line">        Q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = Head[X]; i; i = Next[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (H[E[i]] &lt;= H[X] + Cost[i]) <span class="keyword">continue</span>;</span><br><span class="line">            H[E[i]] = H[X] + Cost[i];</span><br><span class="line">            <span class="keyword">if</span> (Vis[E[i]]) <span class="keyword">continue</span>;</span><br><span class="line">            Vis[E[i]] = <span class="number">1</span>;</span><br><span class="line">            Q.push(E[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">GetRoad</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue &lt;ANode&gt; Q;</span><br><span class="line">    ANode Now = ANode&#123;<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    Now.Vis[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    Q.push(Now);</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Count</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (!Q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        Now = Q.top();</span><br><span class="line">        Q.pop();</span><br><span class="line">        <span class="keyword">if</span> (Now.X == N)++Count;</span><br><span class="line">        <span class="keyword">if</span> (Count == <span class="number">2</span>) <span class="keyword">return</span> Now.Dis;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = Head[Now.X]; i; i = Next[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (Now.Vis[E[i]]) <span class="keyword">continue</span>;</span><br><span class="line">            ANode Nxt = Now;</span><br><span class="line">            Nxt.X = E[i], Nxt.Dis = Now.Dis + Cost[i];</span><br><span class="line">            Nxt.Vis[E[i]] = <span class="number">1</span>;</span><br><span class="line">            Q.push(Nxt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;N, &amp;M);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) <span class="built_in">scanf</span> (<span class="string">"%d %d"</span>, &amp;P[i].x, &amp;P[i].y);</span><br><span class="line">    <span class="keyword">while</span> (M--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">"%d %d"</span>, &amp;X, &amp;Y);</span><br><span class="line">        AddEdge(X, Y), AddEdge(Y, X);</span><br><span class="line">    &#125;</span><br><span class="line">    SPFA();</span><br><span class="line">    <span class="keyword">double</span> Ans = GetRoad();</span><br><span class="line">    <span class="keyword">if</span> (Ans &lt; <span class="number">0.0</span>) <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%.2lf"</span>, Ans);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>k短路</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>P2599取石子游戏</title>
    <url>/2020/07/13/P2599%E5%8F%96%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<h1 id="P2599-ZJOI2009-取石子游戏"><a href="#P2599-ZJOI2009-取石子游戏" class="headerlink" title="P2599 [ZJOI2009]取石子游戏"></a><a href="https://www.luogu.com.cn/problem/P2599" target="_blank" rel="noopener"><strong>P2599 [ZJOI2009]取石子游戏</strong></a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在研究过$Nim$游戏及各种变种之后，$Orez$又发现了一种全新的取石子游戏，这个游戏是这样的： 有$n$堆石子，将这$n$堆石子摆成一排。游戏由两个人进行，两人轮流操作，每次操作者都可以从最左或最右的一堆中取出若干颗石子，可以将那一堆全部取掉，但不能不取，不能操作的人就输了。 $Orez$问：对于任意给出一个初始一个局面，是否存在先手必胜策略。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>文件的第一行为一个整数$T$，表示有 $T$组测试数据。</p>
<p>对于每组测试数据，第一行为一个整数$n$，表示有$n$堆石子; 第二行为$n$个整数$a_i$，依次表示每堆石子的数目。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>对于每组测试数据仅输出一个整数$0$或$1$。其中$1$表示有先手必胜策略，$0$表示没有。</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><blockquote>
<p>如果最靠外边的两堆不一样, 那就先取高的那一堆的一个</p>
<p>然后后手取了几个, 先手就会跟着后手在另一堆中取相同的个石子</p>
<p>易证当两堆的差大于$1$时, 后手一定会先取完一堆</p>
<p>先手该取的那一堆还有石子</p>
<p>谔谔, 出了一点小问题?</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">1e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> T, N, A[Maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) <span class="built_in">scanf</span> (<span class="string">"%d"</span>, A + i);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(A[<span class="number">0</span>] - A[N - <span class="number">1</span>]) &lt;= <span class="number">1</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[<span class="number">0</span>] == <span class="number">1</span> || A[N - <span class="number">1</span>] == <span class="number">1</span>) <span class="built_in">puts</span>(<span class="string">"1"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"0"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
]]></content>
      <tags>
        <tag>Nim游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>P1587[NOI2016]循环之美</title>
    <url>/2020/08/06/P1587%5BNOI2016%5D%E5%BE%AA%E7%8E%AF%E4%B9%8B%E7%BE%8E/</url>
    <content><![CDATA[<h1 id="P1587-NOI2016-循环之美"><a href="#P1587-NOI2016-循环之美" class="headerlink" title="P1587[NOI2016]循环之美"></a><a href="https://www.luogu.com.cn/problem/P1587" target="_blank" rel="noopener">P1587[NOI2016]循环之美</a></h1><p>emmmmm</p>
<p>这是一道莫比乌斯反演+杜教筛的好题</p>
<p>题目就不赘述了，即求：</p>
<script type="math/tex; mode=display">
\sum_{i=1}^n\sum_{j=1}^m[i\perp j][j\perp k]</script><p>这个看完题应该就知道怎么证明了</p>
<p>好，继续化简式子:</p>
<p>$Step\;One:$</p>
<script type="math/tex; mode=display">
\begin{align*}
&\quad\sum_{j=1}^m[j\perp k]\sum_{i=1}^n[i\perp j]\\
&=\sum_{j=1}^m[j\perp k]\sum_{i=1}^n\sum_{d|\gcd(i,j)}\mu(d)\\
&=\sum_{d=1}^{\min(n, m)}\frac nd\mu(d)\sum_{j=1}^{\frac md}[jd\perp k]\\
&=\sum_{d=1}^{\min(n, m)}\frac nd\mu(d)[d\perp k]\sum_{j=1}^{\frac md}[j\perp k]
\end{align*}</script><p>$Step\;Two:$</p>
<p>考虑拆分$\sum\limits_{j=1}^{\frac md}[j\perp k]$</p>
<p>你可以莫比乌斯反演，但是那样就太麻烦了，这个我们可以考虑用欧拉函数和剩余系的方法来处理，于是有：</p>
<script type="math/tex; mode=display">
f(n)=\frac nk\varphi(k)+f(n\%k)</script><p>这个可以预处理+度教筛</p>
<p>$Step\;Three:$</p>
<p>考虑</p>
<script type="math/tex; mode=display">
\begin{align*}
g(n,k)&=\sum_{d=1}^n\mu(d)[d\perp k]\\
&=\sum_{d=1}^n\mu(d)\sum_{d\prime|(d,k)}\mu(d\prime)\\
&=\sum_{d=1}^n\mu(d)\sum_{d\prime|d,d\prime |k}\mu(d\prime)\\
&=\sum_{d\prime=1}^n...
\end{align*}</script><p>先说下一种的</p>
<p>考虑先处理$[j\perp k]$，化简可以得到</p>
<script type="math/tex; mode=display">
\begin{align*}
f(n,m,k)&=\sum_{i=1}^n\sum_{j=1}^m[i\perp j][j\perp k]\\
&=\sum_{d|k}\mu(d)f(\frac md,n,d)
\end{align*}</script><p>边界就不用说了？</p>
<p>看代码</p>
<p>​    </p>
]]></content>
      <tags>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title>P3810[模板]三位偏序</title>
    <url>/2020/07/27/P3810%5B%E6%A8%A1%E6%9D%BF%5D%E4%B8%89%E4%BD%8D%E5%81%8F%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="P3810-【模板】三维偏序（陌上花开）"><a href="#P3810-【模板】三维偏序（陌上花开）" class="headerlink" title="P3810 【模板】三维偏序（陌上花开）"></a><a href="https://www.luogu.com.cn/problem/P3810" target="_blank" rel="noopener">P3810 【模板】三维偏序（陌上花开）</a></h1><p>这道题, 刚看题时, 感觉就是把三个元素压缩成一个元素, 然后就是一个逆序对这样的一个问题 .</p>
<p>但是, 三个条件要求的是要同时成立, 所以, 不能这样做</p>
<p>既然想到逆序对了, 那么我们就可以先让其中的两维变成有序的, 剩下的一维, 就类似一个逆序对了</p>
<ul>
<li>首先对$X$进行排序</li>
<li>分治, 在每个块中对$Y$排序</li>
<li>对$Z$做逆序对, 此时$Z$是有限制条件的, 它依赖于$X,Y$的取值大小</li>
</ul>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; (-x))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> X, Y, Z, Ans, W;</span><br><span class="line">&#125;A[Maxn], B[Maxn];</span><br><span class="line"><span class="keyword">int</span> Cnt, Ans[Maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> K, N;</span><br><span class="line"><span class="keyword">int</span> Tree[Maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Cmpa</span><span class="params">(Node A, Node B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.X == B.X) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (A.Y == B.Y) <span class="keyword">return</span> A.Z &lt; B.Z;</span><br><span class="line">        <span class="keyword">return</span> A.Y &lt; B.Y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> A.X &lt; B.X;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Cmpy</span><span class="params">(Node A, Node B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.Y == B.Y) <span class="keyword">return</span> A.Z &lt; B.Z;</span><br><span class="line">    <span class="keyword">return</span> A.Y &lt; B.Y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Ask</span><span class="params">(<span class="keyword">int</span> P)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Ans</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (P)</span><br><span class="line">    &#123;</span><br><span class="line">        Ans += Tree[P];</span><br><span class="line">        P -= lowbit(P);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> P, <span class="keyword">int</span> Val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (P &lt;= K)</span><br><span class="line">    &#123;</span><br><span class="line">        Tree[P] += Val;</span><br><span class="line">        P += lowbit(P);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">CDQ</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == R) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> Mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    CDQ (L, Mid), CDQ (Mid + <span class="number">1</span>, R);</span><br><span class="line">    sort (A + L, A + Mid + <span class="number">1</span>, Cmpy);</span><br><span class="line">    sort (A + Mid + <span class="number">1</span>, A + R + <span class="number">1</span>, Cmpy);</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">j</span><span class="params">(L)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = Mid + <span class="number">1</span>; i &lt;= R; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (A[j].Y &lt;= A[i].Y &amp;&amp; j &lt;= Mid)</span><br><span class="line">            Add(A[j].Z, A[j].W), ++j;</span><br><span class="line">        A[i].Ans += Ask(A[i].Z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = L; i &lt; j; ++i) Add(A[i].Z, -A[i].W);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%d %d"</span>, &amp;N, &amp;K);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">"%d %d %d"</span>, &amp;B[i].X, &amp;B[i].Y, &amp;B[i].Z);</span><br><span class="line"></span><br><span class="line">    sort (B + <span class="number">1</span>, B + N + <span class="number">1</span>, Cmpa);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, C = <span class="number">0</span>; i &lt;= N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ++C;</span><br><span class="line">        <span class="keyword">if</span> (B[i].X != B[i + <span class="number">1</span>].X || B[i].Y != B[i + <span class="number">1</span>].Y || B[i].Z != B[i + <span class="number">1</span>].Z)</span><br><span class="line">            A[++Cnt] = B[i], A[Cnt].W = C, C = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    CDQ (<span class="number">1</span>, Cnt);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Cnt; ++i)</span><br><span class="line">        Ans[A[i].Ans + A[i].W - <span class="number">1</span>] += A[i].W;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) <span class="built_in">printf</span> (<span class="string">"%d\n"</span>, Ans[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不明白为啥叫$CDQ$, 大雾</p>
]]></content>
      <tags>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>P2675三角圣地</title>
    <url>/2020/07/20/P2675%E4%B8%89%E8%A7%92%E5%9C%A3%E5%9C%B0/</url>
    <content><![CDATA[<h1 id="P2675-《瞿葩的数字游戏》T3-三角圣地"><a href="#P2675-《瞿葩的数字游戏》T3-三角圣地" class="headerlink" title="P2675 《瞿葩的数字游戏》T3-三角圣地"></a><a href="https://www.luogu.com.cn/problem/P2675" target="_blank" rel="noopener">P2675 《瞿葩的数字游戏》T3-三角圣地</a></h1><blockquote>
<p> emmmmm, 这眨眼一看像是个杨辉三角之类的东西, 定眼一看好像不太对啊</p>
</blockquote>
<p>每次把上面两堆合并起来, 显然越靠近中间在最后的结果中出现次数越多, 越靠近两端次数越少, 考虑贪心</p>
<p>所以数列大概长成这个样子:</p>
<script type="math/tex; mode=display">
2, 4, 6,\cdots,2(k-1),2k,2k-1,\cdots,5,3,1</script><p>所以可以得出: $2k-1$与$2k$出现的频率是相通的<del>并没啥用</del></p>
<p>答案可以记为: </p>
<script type="math/tex; mode=display">
Ans = \sum\limits_{i=1}^nc_i\cdot A_i</script><p>打一个表, 与似乎发现系数就$TM$是杨辉三角了啊, 模数很小, 快乐$Lucas$</p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">1e6</span> + <span class="number">10</span>, Mod = <span class="number">1e4</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> N, Ans;</span><br><span class="line"><span class="keyword">int</span> Num[Maxn], Fac[Maxn] = &#123;<span class="number">1</span>&#125;, Inv[Maxn] = &#123;<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> X, <span class="keyword">int</span> Y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Ans</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (Y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Y &amp; <span class="number">1</span>) Ans = Ans * X % Mod;</span><br><span class="line">        X = X * X % Mod;</span><br><span class="line">        Y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) Fac[i] = Fac[i - <span class="number">1</span>] * i % Mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) Inv[i] = Pow(Fac[i], Mod - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> M)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (M &gt; N) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> Fac[N] * Inv[M] % Mod * Inv[N - M] % Mod; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Lucas</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> M)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!M) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> Lucas(N / Mod, M / Mod) * C(N % Mod, M % Mod) % Mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">    Init();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i += <span class="number">2</span>) Num[i &gt;&gt; <span class="number">1</span>] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i += <span class="number">2</span>) Num[N - (i &gt;&gt; <span class="number">1</span>)] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) Ans = (Ans + Num[i] % Mod * Lucas(N - <span class="number">1</span>, i - <span class="number">1</span>) % Mod) % Mod;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"%d\n"</span>, Ans % Mod);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数论</tag>
        <tag>Lucas</tag>
      </tags>
  </entry>
  <entry>
    <title>P4180严格次小生成树</title>
    <url>/2020/07/21/P4180%E4%B8%A5%E6%A0%BC%E6%AC%A1%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
    <content><![CDATA[<h1 id="P4180-BJWC2010-严格次小生成树"><a href="#P4180-BJWC2010-严格次小生成树" class="headerlink" title="P4180 [BJWC2010]严格次小生成树"></a><a href="https://www.luogu.com.cn/problem/P4180" target="_blank" rel="noopener">P4180 [BJWC2010]严格次小生成树</a></h1><p>题意同标题</p>
<p>最小生成树就不用说了, 那么次小生成树就是枚举剩下的边, 把它加入到我们的最小生成树中, 这样就构成了一个奇环树, 考虑这条新加入的边能够取代哪一条边, 能使新生成的树为一颗与原来全职不相等的树?</p>
<p>显然答案是取代第一个长度严格小于新加入的边的那一条, 关于这一条边, 我们可以维护树上两点间的最大边权和严格次大边权</p>
<p>因为做这道题时, <del>没发现写树剖维护的</del>, 觉得倍增写着挺好看的, 于是就写了个倍增维护的</p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">1e5</span> + <span class="number">10</span>, Maxm = <span class="number">3e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> N, M, MinInc(<span class="number">1e9</span> + <span class="number">10</span>);</span><br><span class="line"><span class="keyword">int</span> F[Maxn][<span class="number">20</span>], Max[Maxn][<span class="number">20</span>], SMax[Maxn][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> Depth[Maxn], Fa[Maxn];</span><br><span class="line"><span class="keyword">int</span> Head[Maxn], E[Maxm &lt;&lt; <span class="number">1</span>], Next[Maxm &lt;&lt; <span class="number">1</span>], Cost[Maxm &lt;&lt; <span class="number">1</span>], Cur;</span><br><span class="line">ll Ans;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> U, V, W;</span><br><span class="line">    <span class="keyword">bool</span> In;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;Temp) <span class="keyword">const</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> W &lt; Temp.W;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;_E[Maxm];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> X)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Fa[X] == X) <span class="keyword">return</span> X;</span><br><span class="line">    <span class="keyword">return</span> Fa[X] = Find(Fa[X]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> U, <span class="keyword">int</span> V, <span class="keyword">int</span> W)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Next[++Cur] = Head[U];</span><br><span class="line">    Head[U] = Cur;</span><br><span class="line">    E[Cur] = V;</span><br><span class="line">    Cost[Cur] = W;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">MST</span><span class="params">(<span class="keyword">int</span> Cnt = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) Fa[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; Cnt != N - <span class="number">1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> U = _E[i].U, V = _E[i].V, FU = Find(U), FV = Find(V);</span><br><span class="line">        <span class="keyword">if</span> (FU == FV) <span class="keyword">continue</span>;</span><br><span class="line">        Fa[FV] = FU;</span><br><span class="line">        ++Cnt;</span><br><span class="line">        _E[i].In = <span class="number">1</span>;</span><br><span class="line">        Ans += _E[i].W;</span><br><span class="line">        AddEdge(U, V, _E[i].W);</span><br><span class="line">        AddEdge(V, U, _E[i].W);<span class="comment">//建边</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//最小生成树</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> X, <span class="keyword">int</span> _f, <span class="keyword">int</span> WEdge, <span class="keyword">int</span> Dep)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Depth[X] = Dep, F[X][<span class="number">0</span>] = _f, Max[X][<span class="number">0</span>] = WEdge, SMax[X][<span class="number">0</span>] = <span class="number">-1</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; i) &lt;= Dep; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        F[X][i] = F[F[X][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">        Max[X][i] = max(Max[X][i - <span class="number">1</span>], Max[F[X][i - <span class="number">1</span>]][i - <span class="number">1</span>]);<span class="comment">//倍增维护最大的边</span></span><br><span class="line">        SMax[X][i] = max(SMax[X][i - <span class="number">1</span>], SMax[F[X][i - <span class="number">1</span>]][i - <span class="number">1</span>]);<span class="comment">//次大</span></span><br><span class="line">        <span class="keyword">if</span> (Max[X][i - <span class="number">1</span>] &lt; Max[X][i]) SMax[X][i] = max(SMax[X][i], Max[X][i - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Max[X][i - <span class="number">1</span>] &gt; Max[F[X][i - <span class="number">1</span>]][i - <span class="number">1</span>]) SMax[X][i] = max(SMax[X][i], Max[F[X][i - <span class="number">1</span>]][i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = Head[X]; i; i = Next[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> V = E[i];</span><br><span class="line">        <span class="keyword">if</span> (V == _f) <span class="keyword">continue</span>;</span><br><span class="line">        DFS(V, X, Cost[i], Dep + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> X, <span class="keyword">int</span> Y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Depth[X] &lt; Depth[Y]) X ^= Y ^= X ^= Y;</span><br><span class="line">    <span class="keyword">int</span> K = Depth[X] - Depth[Y];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">17</span>; ++i)</span><br><span class="line">        <span class="keyword">if</span> (K &gt;&gt; i &amp; <span class="number">1</span>) X = F[X][i];</span><br><span class="line">    <span class="keyword">if</span> (X == Y) <span class="keyword">return</span> X;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">17</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        <span class="keyword">if</span> (F[X][i] != F[Y][i]) X = F[X][i], Y = F[Y][i];</span><br><span class="line">    <span class="keyword">return</span> F[X][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Work</span><span class="params">(<span class="keyword">int</span> S, <span class="keyword">int</span> T, <span class="keyword">int</span> _W)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    int Ans(0), K = Depth[S] - Depth[T];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">17</span>; ++i)</span><br><span class="line">        <span class="keyword">if</span> (K &gt;&gt; i &amp; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (Max[S][i] != _W) Ans = max(Ans, Max[S][i]);</span><br><span class="line">            <span class="keyword">else</span> Ans = max(Ans, SMax[S][i]);</span><br><span class="line">            S = F[S][i];</span><br><span class="line">        &#125;<span class="comment">//找路径上严格小于_W的最大边</span></span><br><span class="line">    MinInc = min(MinInc, _W - Ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%d %d"</span>, &amp;N, &amp;M);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; ++i) <span class="built_in">scanf</span> (<span class="string">"%d %d %d"</span>, &amp;_E[i].U, &amp;_E[i].V, &amp;_E[i].W);</span><br><span class="line">    sort (_E + <span class="number">1</span>, _E + M + <span class="number">1</span>);</span><br><span class="line">    MST();</span><br><span class="line">    DFS(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; ++i)</span><br><span class="line">        <span class="keyword">if</span> (!_E[i].In)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> U = _E[i].U, V = _E[i].V;</span><br><span class="line">            <span class="keyword">int</span> Lca = LCA(U, V);</span><br><span class="line">            Work (U, Lca, _E[i].W);</span><br><span class="line">            Work (V, Lca, _E[i].W);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"%lld\n"</span>, Ans + MinInc);<span class="comment">//答案是最小生成树+最小增量</span></span><br><span class="line">    system (<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若这道题求的并不是严格次小生成树, 那么就不需要维护次小边, 就是说最小增量可能为零</p>
<p>多说一句, 洛谷的数据貌似真的太弱了, 我有地方写挂了竟然都可以$AC$</p>
<p><del>而且洛谷评测的速度比$LOJ$慢太多啦</del></p>
]]></content>
      <tags>
        <tag>图论</tag>
        <tag>生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>Present</title>
    <url>/2020/09/15/Present/</url>
    <content><![CDATA[<h1 id="Present"><a href="#Present" class="headerlink" title="Present"></a><a href="https://ac.nowcoder.com/acm/problem/110615" target="_blank" rel="noopener">Present</a></h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意:"></a>题目大意:</h2><p>先给你一串序列,你至多有$\text{m}$次操作使得一段长度为$w$的区间加一</p>
<p>问这串序列的最小值最大可以是多少?</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h2><p>最小值最大或者最大值最小,我们的第一反应可能都是二分答案</p>
<blockquote>
<p>简单证明一下:</p>
<blockquote>
<p>如果最小值最大为$x$,那么只要我们少做一次操作,那么$x-1$也是可行的<br>这满足二分答案的性质,所以呢二分答案没有问题的</p>
</blockquote>
</blockquote>
<p>那么关于$check$函数的话,如果当前我们枚举到的数他小于这个我们$\text{check}$的值,那么我们就给这一段区间加上这个差值(如果可以加,否则返回零)</p>
<p>那么时间复杂度大概就是$O(\log10^9*n)$,可以接受的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> ll __read()</span><br><span class="line">&#123;</span><br><span class="line">    ll x(0), t(1);</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">'0'</span> || o &gt; <span class="string">'9'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">'-'</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">'0'</span> &amp;&amp; o &lt;= <span class="string">'9'</span>; o = getchar()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll n, m, w, a[maxn];</span><br><span class="line">ll CF[maxn], temp[maxn];</span><br><span class="line">ll l(0x7fffffff), r, ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Check</span><span class="params">(ll x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(temp + <span class="number">1</span>, CF + <span class="number">1</span>, <span class="keyword">sizeof</span>(ll) * n);</span><br><span class="line">    ll now(0), rest(m);</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        now += temp[i];</span><br><span class="line">        <span class="keyword">if</span> (now &gt;= x) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (now + rest &lt; x) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        ll get = x - now;</span><br><span class="line">        rest -= get;</span><br><span class="line">        now += get;</span><br><span class="line">        <span class="keyword">if</span> (i + w &lt;= n) temp[i + w] -= get;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = __read(), m = __read(), w = __read();</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; ++i)  &#123;</span><br><span class="line">        a[i] = __read();</span><br><span class="line">        CF[i] = a[i] - a[i - <span class="number">1</span>];</span><br><span class="line">        l = min(l, a[i]), r = max(r, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    r += m;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (Check(mid)) ans = mid, l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>P4655[CEO2017]Building Bridges</title>
    <url>/2020/08/05/P4655%5BCEO2017%5DBuildingBridges/</url>
    <content><![CDATA[<h1 id="Building-Bridges"><a href="#Building-Bridges" class="headerlink" title="Building Bridges"></a><a href="https://www.luogu.com.cn/problem/P4655" target="_blank" rel="noopener">Building Bridges</a></h1><h2 id="CDQ-分治"><a href="#CDQ-分治" class="headerlink" title="$CDQ$分治"></a>$CDQ$分治</h2><p>对, 这道题我的第一反应就是斜率优化</p>
<p>先推一波式子：</p>
<script type="math/tex; mode=display">
\text{先令Dp[i]表示以i结尾的这一段的贡献, S[i]表示关于W[i]的一个前缀和}\\
\begin{align*}
Dp[i] &= (h[i]-h[t])^2+S[i-1]-S[t]\\
Dp[j] &= (h[j]-h[t])^2+S[j-1]-S[t]\\
\end{align*}\\</script><p>若$Dp[j]&gt;Dp[i]$, 那么有：</p>
<script type="math/tex; mode=display">
\begin{align*}
(h[j]-h[t]^2)+S[j-1]-S[t]&>(h[i]-h[t]^2)+S[i-1]-S[t]\\
h[j]^2-2h[j]h[t]+h[t]^2+S[j-1]-S[t]&>h[i]^2-2h[i]h[t]+h[t]^2+S[i-1]-S[t]\\
h[j]^2-2h[j]h[t]+S[j-1]&>h[i]^2-2h[i]h[t]+S[i-1]\\
(h[j]+S[j-1])-(h[i]-S[i-1])&>2h[t]*(h[j]-h[i])\\
\frac{g[j]-g[i]}{h[j]-h[i]}&>2h[t]
\end{align*}</script><p>那么这个式子要想写斜率优化的话，$h$数组要保证单调</p>
<p>嗯，就分治，排序，然后斜率$Dp$</p>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>$O(\log^2n)$应该没有问题吧，没有写代码，口胡</p>
<h2 id="李超线段树"><a href="#李超线段树" class="headerlink" title="李超线段树"></a>李超线段树</h2><p>？？？，怎么回事，看错题了？</p>
<p>没有，个人认为这才是正解！！！</p>
<p>再来看看我们的式子：</p>
<script type="math/tex; mode=display">
\begin{align*}
Dp[i]&=(h[i]-h[t])^2+S[i-1]-S[t]+Dp[t]\\
&=h[i]^2-2h[i]h[t]+h[t]^2+S[i-1]-S[t]+Dp[t]\\
&=h[i]^2+S[i-1]+\min_{t=1}^{i-1}(h[t]^2-2h[t]h[i]-S[t]+Dp[t])
\end{align*}</script><p>看见其实对于我们的$i$，它的答案其实有一部分是定值，还有一部分与之前的信息相关联</p>
<p>那么我们可以新定义一个函数叫$f_t(x)$：</p>
<script type="math/tex; mode=display">
f_t(x)=-2h[t]\times x+h[t]^2-S[t]+Dp[t]</script><p>那么，原式可以化为</p>
<script type="math/tex; mode=display">
Dp[i]=h[i]+S[i-1]+\min_{t=1}^{i-1}f_t(H[i])</script><p>相当于是向一个坐标系中加入了很多条线段，问你在某个点时的最小值，是吧</p>
<p>此时，$f_t(x)$的斜率为$-2h[t]$，截距为$h[t]^2-S[t]+Dp[t]$</p>
<p>就可以了</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">1e5</span> + <span class="number">10</span>, L = <span class="number">0</span>, R = <span class="number">1e6</span>, MWi = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line">ll K[Maxn], B[Maxn] = &#123;<span class="number">1e18</span>&#125;, H[Maxn], W[Maxn], F[Maxn];\\B[<span class="number">0</span>]一定要初始化，否则当x取<span class="number">0</span>时，不会进行更新的</span><br><span class="line"><span class="keyword">int</span> S[MWi &lt;&lt; <span class="number">2</span>], Qx, N;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Fx</span><span class="params">(<span class="keyword">int</span> X, <span class="keyword">int</span> Id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> K[Id] * X + B[Id];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UpDate</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> K, <span class="keyword">int</span> X = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == R)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Fx(L, K) &lt; Fx(L, S[X])) S[X] = K;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> Mid = L + R &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (Fx(Mid, K) &lt; Fx(Mid, S[X])) swap(K, S[X]);</span><br><span class="line">    <span class="keyword">if</span> (Fx(L, K) &lt; Fx(L, S[X])) UpDate(L, Mid, K, X &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (Fx(R, K) &lt; Fx(R, S[X])) UpDate(Mid + <span class="number">1</span>, R, K, X &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Query</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> X = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == R) <span class="keyword">return</span> Fx(L, S[X]);</span><br><span class="line">    <span class="keyword">int</span> Mid = L + R &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    ll Temp = Fx(Qx, S[X]);</span><br><span class="line">    <span class="keyword">if</span> (Qx &lt;= Mid) <span class="keyword">return</span> min(Temp, Query(L, Mid, X &lt;&lt; <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> min(Temp, Query(Mid + <span class="number">1</span>, R, X &lt;&lt; <span class="number">1</span> | <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) <span class="built_in">scanf</span> (<span class="string">"%lld"</span>, K + i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) <span class="built_in">scanf</span> </span><br><span class="line">    (<span class="string">"%lld"</span>, W + i), W[i] += W[i - <span class="number">1</span>];</span><br><span class="line">    B[<span class="number">1</span>] = K[<span class="number">1</span>] * K[<span class="number">1</span>] - W[<span class="number">1</span>];</span><br><span class="line">    K[<span class="number">1</span>] *= <span class="number">-2</span>;</span><br><span class="line">    UpDate (L, R, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        Qx = K[i];</span><br><span class="line">        F[i] = K[i] * K[i] + W[i - <span class="number">1</span>] + Query(L, R);</span><br><span class="line">        B[i] = F[i] + K[i] * K[i] - W[i];</span><br><span class="line">        K[i] *= <span class="number">-2</span>;</span><br><span class="line">        UpDate (L, R, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"%lld\n"</span>, F[N]);</span><br><span class="line">    system (<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Dp优化</tag>
        <tag>李超线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>[SCOI2009]游戏</title>
    <url>/2020/09/18/SCOI2009-%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<h1 id="SCOI2009-游戏"><a href="#SCOI2009-游戏" class="headerlink" title="[SCOI2009]游戏)"></a><a href="[https://ac.nowcoder.com/acm/problem/20271](https://ac.nowcoder.com/acm/problem/20271">[SCOI2009]游戏</a>)</h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>有一个$1$到$n$的序列, 每个数可能对应另一个数</p>
<p>不停的变换, 直到变回串, 一次变换记作一次花费</p>
<p>问你对于所有可能的对应关系, 有多少种不同的花费</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>显然, 无论对应关系如何, 这些有对应关系的数一定构成环(包括自环)</p>
<p>对于每一个环, 若他的长度为$x$, 那么这个环归位的花费一定为$x$</p>
<p>那么原串长度可以表示为$\sum_{i=1}^n len_i$, 那么花费就为$\mathbb{lcm}len_i$</p>
<p>所以问题就转化为了有多少种不同的$\mathbb{lcm}$</p>
<p>再考虑所有的$\mathbb{lcm}$, 可以表示为$\mathbb{lcm}=p_1^{\max(k_1)}p_2^{\max(k_2)}\cdots p_n^{\max(k_n)}$</p>
<p>看上去是不是有点点像背包了呢?</p>
<p>因为我们知道$\forall i\;p_i\in[1,n], \forall k\;p_ik\in[1,n]$, 那后每个物品至多选一次(若可以选多次, 那么后面选的不应该有贡献, 如上式), 似乎就可以写一个$01$背包了呢</p>
<p>所以我们可以先处理出$1\sim n$内所有的素数,再枚举每个素数的$k\in[1,n]$次方作为体积为$p_i^n$的物品, 容量为$n$</p>
<p>就结束啦<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> __read()</span><br><span class="line">&#123;</span><br><span class="line">    int x(0), t(1);</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">'0'</span> || o &gt; <span class="string">'9'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">'-'</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">'0'</span> &amp;&amp; o &lt;= <span class="string">'9'</span>; o = getchar()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll f[maxn];</span><br><span class="line"><span class="keyword">int</span> pr[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= maxn; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) pr[++pr[<span class="number">0</span>]] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= pr[<span class="number">0</span>] &amp;&amp; i * pr[j] &lt;= maxn; ++j) &#123;</span><br><span class="line">            vis[i * pr[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (!(i % pr[j])) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">int</span> n = __read();</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= pr[<span class="number">0</span>]; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &gt;= pr[i]; --j) &#123;<span class="comment">//这里的n只能从n到1,保证每个物品只选一次</span></span><br><span class="line">            <span class="keyword">int</span> temp = pr[i];</span><br><span class="line">            <span class="keyword">while</span> (temp &lt;= j) f[j] += f[j - temp], temp *= pr[i];<span class="comment">//这里从小到大枚举temp没有什么讲究</span></span><br><span class="line">            <span class="comment">//但是不能先枚举pr[i]的k次方,先枚举次方会导致一个素数被多次计算, 然而他不应该有贡献</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="function">ll <span class="title">ans</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) ans += f[i];<span class="comment">//最后枚举有多少个物品, 从0个物品到n个都是有贡献的</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>数论</tag>
        <tag>Dp优化</tag>
      </tags>
  </entry>
  <entry>
    <title>[SDOI2017]数字表格</title>
    <url>/2020/09/30/SDOI2017-%E6%95%B0%E5%AD%97%E8%A1%A8%E6%A0%BC/</url>
    <content><![CDATA[<h1 id="SDOI2017-数字表格"><a href="#SDOI2017-数字表格" class="headerlink" title="[SDOI2017]数字表格"></a><a href="https://www.luogu.com.cn/problem/P3704" target="_blank" rel="noopener">[SDOI2017]数字表格</a></h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>求：</p>
<script type="math/tex; mode=display">
\prod_{i=1}^n\prod_{j=1}^mf_{\gcd(i,j)}</script><p>其中：</p>
<script type="math/tex; mode=display">
f_i=
\begin{cases}
0&i=0\\
1&i=1\\
f_{i-1}+f_{i-2}&i\ge2
\end{cases}</script><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这其实是一个多么裸的题，最多就用了一个欧拉定理。。。</p>
<p>那就直接来吧(规定$n\le m$)</p>
<script type="math/tex; mode=display">
\begin{aligned}
ans&=\prod_{i=1}^n\prod_{j=1}^mf_{\gcd(i,j)}\\
&=\prod_{d=1}^nf_d^{\sum_{i=1}^{\frac nd}\sum_{j=1}^{\frac md}[\gcd(i,j)==1]}
\end{aligned}</script><p>其中，那一坨多么难看的指数可以拉出来特殊关照一下</p>
<p>那么就有</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum_{i=1}^{\frac nd}\sum_{j=1}^{\frac md}[\gcd==1]&=\sum_{i=1}^{\frac nd}\sum_{j=1}^{\frac md}\sum_{k|\gcd(i,j)}\mu(k)\\
&=\sum_{k=1}^{\frac nd}\mu(k)\left\lfloor\frac n{kd}\right\rfloor\left\lfloor\frac m{kd}\right\rfloor\\
\end{aligned}</script><p>带回原式，可以得到：</p>
<script type="math/tex; mode=display">
\begin{aligned}
ans&=\prod_{d=1}^n{f_d}^{\sum_{k=1}^{\frac nd}\mu(k)\left\lfloor\frac n{kd}\right\rfloor\left\lfloor\frac m{kd}\right\rfloor}\\
&=\prod_{t=1}^n\prod_{d|t}{f_d}^{\mu(\frac td)\left\lfloor\frac mt\right\rfloor\left\lfloor\frac nt\right\rfloor}
\end{aligned}</script><p>这一步稍微交换一下求值顺序即可得到，然后就是中间多出来的那块求积的东西是可以预处理的，时间复杂度大概是$\ln n$级别的，最后的最后就是一个数论分块，因为预处理完后，这个就可以化简为：</p>
<script type="math/tex; mode=display">
ans=\prod_{t=1}^nF_t^{\left\lfloor\frac mt\right\rfloor\left\lfloor\frac nt\right\rfloor}</script><p>这样以来，就十分的显然了，那么到这里，这道题就是真的水完了</p>
<p>唯一值得注意的就是指数那一坨可能特别的大，于是乎可能需要一个欧拉定理之类的东西</p>
<p>但是看到$n,m\le1e6$，就知道只需要一个$ll$就够了，是否用欧拉定理只是对于常数优化的问题了</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> __read()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">x</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">o</span><span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">'0'</span> || o &gt; <span class="string">'9'</span>) o = getchar();</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">'0'</span> &amp;&amp; o &lt;= <span class="string">'9'</span>; o = getchar())</span><br><span class="line">        x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ans</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (y) &#123;</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">1</span>) ans = <span class="number">1l</span>l * ans * x % mod;</span><br><span class="line">        x = <span class="number">1l</span>l * x * x % mod;</span><br><span class="line">        y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> ip[maxn];</span><br><span class="line"><span class="keyword">int</span> p[maxn], cnt;</span><br><span class="line"><span class="keyword">int</span> mu[maxn], inv[maxn];</span><br><span class="line"><span class="keyword">int</span> f[maxn], g[maxn], F[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[<span class="number">1</span>] = g[<span class="number">1</span>] = F[<span class="number">0</span>] = F[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxn; ++i) &#123;</span><br><span class="line">        f[i] = (f[i - <span class="number">1</span>] + f[i - <span class="number">2</span>]) % mod;</span><br><span class="line">        g[i] = Pow(f[i], mod - <span class="number">2</span>);</span><br><span class="line">        F[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!ip[i]) p[++cnt] = i, mu[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; i * p[j] &lt; maxn; ++j) &#123;</span><br><span class="line">            ip[i * p[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % p[j]) mu[i * p[j]] = -mu[i];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; maxn; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; maxn; j += i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mu[j / i]) <span class="keyword">continue</span>;</span><br><span class="line">            F[j] = <span class="number">1l</span>l * F[j] * (mu[j / i] == <span class="number">1</span> ? f[i] : g[i]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; maxn; ++i) F[i] = <span class="number">1l</span>l * F[i] * F[i - <span class="number">1</span>] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Init();</span><br><span class="line">    <span class="keyword">int</span> T = __read();</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = __read(), m = __read();</span><br><span class="line">        <span class="keyword">if</span> (n &gt; m) swap(n, m);</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">ans</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r; l &lt;= n; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">            r = min(n / (n / l), m / (m / l));</span><br><span class="line">            <span class="keyword">int</span> temp = <span class="number">1l</span>l * F[r] * Pow(F[l - <span class="number">1</span>], mod - <span class="number">2</span>) % mod;</span><br><span class="line">            ans = <span class="number">1l</span>l * ans * Pow(temp, <span class="number">1l</span>l * (n / l) * (m / l) % (mod - <span class="number">1</span>)) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>交了以后，发现这两种写法并没有多大的差别，如果想要优化的话，可以考虑离线一下所有的询问，然后可以排个序，这要确实是可以快很多的</p>
<p>至于更多的奇技淫巧可以看看$loj$上大佬们的做法</p>
]]></content>
      <tags>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title>SP26037 DIVCNT1</title>
    <url>/2020/09/21/SP26037-DIVCNT1/</url>
    <content><![CDATA[<h1 id="SP26073-DIVCNT1-Counting-Divisors"><a href="#SP26073-DIVCNT1-Counting-Divisors" class="headerlink" title="SP26073 DIVCNT1 - Counting Divisors"></a><a href="https://www.luogu.com.cn/problem/SP26073" target="_blank" rel="noopener">SP26073 DIVCNT1 - Counting Divisors</a></h1><p>先看了一眼数据范围$n\le 2^{63}$，可以了，这与$Min_25$筛无缘了</p>
<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>求：</p>
<script type="math/tex; mode=display">
\sum_{i=1}^n\sigma_0(i)</script><h2 id="问题转化："><a href="#问题转化：" class="headerlink" title="问题转化："></a>问题转化：</h2><script type="math/tex; mode=display">
\begin{align*}
\sigma_0(n)&=\sum_{i=1}^n\left\lfloor\frac ni\right\rfloor\\
&=\sum_{i=1}^n\sum_{j=1}^n[i*j\le n]\\
&=\sum_{i=1}^\sqrt n\sum_{j=1}^{\left\lfloor\frac ni\right\rfloor}1+
\sum_{j=1}^\sqrt n\sum_{i=1}^{\left\lfloor\frac nj\right\rfloor}1-\sum_{i=1}^\sqrt n\sum_{j=1}^\sqrt n 1\\
&=2\sum_{i=1}^\sqrt n\left\lfloor\frac ni\right\rfloor-\left\lfloor\sqrt n\right\rfloor^2
\end{align*}</script><p>等价于求函数$y=\frac nx$直线$y=\sqrt n$与直线$y=1$与函数图像和坐标轴相交构成的闭合图形内的整点个数</p>
<p><img src="https://s1.ax1x.com/2020/09/21/w7Oq9P.png" alt=""></p>
<p>紫色阴影部分即为所求（图是嫖的其他巨佬的）</p>
<p>这样，这道题就变成了一道数点问题</p>
<p>通过在$Stern-Brocot$树上寻找斜率，借助单调栈去找一个背包</p>
<p>这部分没太明白，鸽~</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> __int128 _ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e7</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> ll __read()</span><br><span class="line">&#123;</span><br><span class="line">    ll x(0), t(1);</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">'0'</span> || o &gt; <span class="string">'9'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">'-'</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">'0'</span> &amp;&amp; o &lt;= <span class="string">'9'</span>; o = getchar()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ll x, y;</span><br><span class="line">    Point(ll x = <span class="number">0</span>, ll y = <span class="number">0</span>) : x(x), y(y) &#123;&#125;</span><br><span class="line">    Point <span class="keyword">operator</span> + (<span class="keyword">const</span> Point &amp;Temp) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x + Temp.x, y + Temp.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;stk[maxn], L, R, M;</span><br><span class="line"></span><br><span class="line">ll n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">In_R</span><span class="params">(ll x, ll y)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * y &lt;= n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">Slope</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">double</span>)n / x / x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> _ll <span class="title">Slove</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">_ll <span class="title">res</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    int t(0), rt = cbrt(n);</span><br><span class="line">    stk[++t] = Point(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    stk[++t] = Point(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    ll m = <span class="built_in">sqrt</span>(n), x = n / m, y = m + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (L = stk[t--]; !In_R(x + L.x, y - L.y); x += L.x, y -= L.y)</span><br><span class="line">            res += x * L.y + (L.y + <span class="number">1</span>) * (L.x - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (y &lt;= rt) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span> (R = stk[t]; In_R(x + R.x, y - R.y); R = stk[--t]) L = R;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            M = L + R;</span><br><span class="line">            <span class="keyword">if</span> (!In_R(x + M.x, y - M.y)) &#123;</span><br><span class="line">                stk[++t] = (R = M);</span><br><span class="line">            &#125; <span class="keyword">else</span>  &#123;</span><br><span class="line">                <span class="keyword">if</span> (Slope(x + M.x) &lt;= (<span class="keyword">double</span>) R.y / R.x) <span class="keyword">break</span>;</span><br><span class="line">                L = M;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; y; ++i) res += n / i;</span><br><span class="line">    <span class="keyword">return</span> res * <span class="number">2</span> - <span class="number">1l</span>l * m * m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(_ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x) <span class="keyword">return</span>;</span><br><span class="line">    Print(x / <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T = __read();</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        n = __read();</span><br><span class="line">        Print(Slove());</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后面三道题确实是妥妥的$\text{Min_25}$筛了</p>
]]></content>
      <tags>
        <tag>前缀和</tag>
        <tag>鸽~</tag>
      </tags>
  </entry>
  <entry>
    <title>SP34096 DIVCNTK</title>
    <url>/2020/09/21/SP34096-DIVCNTK/</url>
    <content><![CDATA[<h1 id="P34096-DIVCNTK-Counting-Divisors-general"><a href="#P34096-DIVCNTK-Counting-Divisors-general" class="headerlink" title="P34096 DIVCNTK - Counting Divisors (general)"></a><a href="https://www.luogu.com.cn/problem/SP34096" target="_blank" rel="noopener">P34096 DIVCNTK - Counting Divisors (general)</a></h1><h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>求：</p>
<script type="math/tex; mode=display">
S_k=\sum_{i=1}^n\sigma_0(i^k)\mod{2^{64}}</script><h2 id="Sulotion"><a href="#Sulotion" class="headerlink" title="Sulotion"></a>Sulotion</h2><p>观察发现，$\sigma_0(p^k)=k+1$，不完全积性函数，很好，满足$\text{Min_25}$筛的条件</p>
<p>令：$F(x)=\sigma_0(x^k)$，$f(p)=k+1$</p>
<p>好了，就可以直接套版子了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll maxn = <span class="number">1e7</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> ll __read()</span><br><span class="line">&#123;</span><br><span class="line">    ll x(0), t(1);</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">'0'</span> || o &gt; <span class="string">'9'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">'-'</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">'0'</span> &amp;&amp; o &lt;= <span class="string">'9'</span>; o = getchar()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll n, p;</span><br><span class="line">ll sq, tot, pr[maxn], id1[maxn], id2[maxn], w[maxn];</span><br><span class="line">ll cnt, g[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ll maxn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">2</span>; i &lt;= maxn; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) pr[++cnt] = i;</span><br><span class="line">        <span class="keyword">for</span> (ll j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; pr[j] * i &lt;= maxn; ++j) &#123;</span><br><span class="line">            vis[i * pr[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (!(i % pr[j])) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">id</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= sq) <span class="keyword">return</span> id1[x];</span><br><span class="line">    <span class="keyword">return</span> id2[n / x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">S</span><span class="params">(ll x, ll j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pr[j] &gt; x) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ll k = id(x);</span><br><span class="line">    ll ans = g[k] - j * (p + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (ll i = j + <span class="number">1</span>; i &lt;= cnt &amp;&amp; pr[i] * pr[i] &lt;= x; ++i)</span><br><span class="line">        <span class="keyword">for</span> (ll e = <span class="number">1</span>, sp = pr[i]; sp &lt;= x; sp *= pr[i], ++e)</span><br><span class="line">            ans += (p * e + <span class="number">1</span>) * (S(x / sp, i) + (e &gt; <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init(ll(<span class="number">1e6</span>));</span><br><span class="line"></span><br><span class="line">    ll t = __read();</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        tot = <span class="number">0</span>;</span><br><span class="line">        n = __read(), p = __read();</span><br><span class="line">        sq = <span class="built_in">sqrt</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (ll l(<span class="number">1</span>), r; l &lt;= n; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">            r = n / (n / l);</span><br><span class="line">            w[++tot] = n / l;</span><br><span class="line">            g[tot] = n / l - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (w[tot] &lt;= sq) id1[w[tot]] = tot;</span><br><span class="line">            <span class="keyword">else</span> id2[n / w[tot]] = tot;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= cnt; ++i)</span><br><span class="line">            <span class="keyword">for</span> (ll j = <span class="number">1</span>; j &lt;= tot &amp;&amp; pr[i] * pr[i] &lt;= w[j]; ++j) &#123;</span><br><span class="line">                ll k = id(w[j] / pr[i]);</span><br><span class="line">                g[j] -= g[k] - i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= tot; ++i) g[i] *= (p + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"%llu\n"</span>, S(n, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有两道题，一样的，只是手动改一下$p$就可以过了</p>
<p><a href="https://www.luogu.com.cn/problem/SP26073" target="_blank" rel="noopener">SP26073 DIVCNT1 - Counting Divisors</a></p>
<p><a href="https://www.luogu.com.cn/problem/SP20173" target="_blank" rel="noopener">SP20173 DIVCNT2 - Counting Divisors (square)</a></p>
]]></content>
      <tags>
        <tag>前缀和</tag>
        <tag>Min_25筛</tag>
      </tags>
  </entry>
  <entry>
    <title>T20200529</title>
    <url>/2020/05/29/T20200529/</url>
    <content><![CDATA[<h1 id="单词-words"><a href="#单词-words" class="headerlink" title="单词(words)"></a>单词(words)</h1><p><strong>Description</strong></p>
<p> 给你两个由小写字母组成的单词$A$和$B$，我们称一个单词为<strong>幸运单词</strong>，当且仅当它是由$A$的某个非 空前缀和$B$的某个非空后缀拼接而成的（$A$的前缀在$B$的后缀的前面）。</p>
<p> 例如，当单词$A$为$tree$，单词$B$为$heap$时，$trap$就是一个幸运单词，而$traep,aptr$则不是。 请问对于给定的单词$A$和$B$，共有多少个不同的幸运单词？ </p>
<p><strong>Input</strong> </p>
<p>输入包含两行，第一行为单词$A$，第二行为单词$B$。 </p>
<p><strong>Output</strong> </p>
<p>输出一个整数，表示幸运单词的总个数。</p>
<p><strong>Examples</strong> </p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Input</th>
<th>Output</th>
</tr>
</thead>
<tbody>
<tr>
<td>tree<br />heap</td>
<td>14</td>
</tr>
</tbody>
</table>
</div>
<p><strong>数据范围</strong> </p>
<p>对于$20\%$的数据，单词$A$的长度$length_A$和单词B的长的$length_B$满足，$1\le length_A, length_B\le 100;$</p>
<p>对于$40\%$的数据， $1\le length_A, length_B\le 10^3;$</p>
<p>对于$100\%$的数据，$1\le length_A, length_B\le 10^5;$</p>
<blockquote>
<p>其实答案因该和$length_A\times length_B$有关</p>
<p>但是看$treap$， 他可以看成$tre+ap$和$tr+eap$</p>
<p>就是说如果直接按照上面直接乘的话，$treap$是被计算了两次的</p>
<p>所以可以一记录一下A，B串中除了首位字符，有多少个重复的字符，就可以了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> A[Maxn], B[Maxn];</span><br><span class="line">ll CntA[<span class="number">30</span>], CntB[<span class="number">30</span>], Temp, Ans;</span><br><span class="line">ll LenA, LenB;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	freopen (<span class="string">"words.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">	freopen (<span class="string">"words.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">	<span class="built_in">scanf</span> (<span class="string">"%s %s"</span>, A, B);</span><br><span class="line">	LenA = <span class="built_in">strlen</span>(A), LenB = <span class="built_in">strlen</span>(B);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; LenB - <span class="number">1</span>; ++i) CntB[B[i] - <span class="string">'a'</span>]++;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; LenA; ++i) CntA[A[i] - <span class="string">'a'</span>]++;</span><br><span class="line">	Ans = LenA * LenB;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) Ans -= CntA[i] * CntB[i];</span><br><span class="line">	<span class="built_in">printf</span> (<span class="string">"%lld\n"</span>, Ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="距离-distance"><a href="#距离-distance" class="headerlink" title="距离(distance)"></a>距离(distance)</h1><p><strong>Description</strong> </p>
<p>给你一个由$0$和$1$组成的$n × m$大小的矩阵$A$，其中第$i$行第$j$列$\left(1\le i\le n, 1 \le j \le m\right)$的元素的坐标 为$\left(i, j\right)$。 </p>
<p>请输出一个$n × m$大小的矩阵$B$。该矩阵第$i$行第$j$列$\left(1\le i\le n, 1 \le j \le m\right)$的元素表示的是，矩阵$A$中坐标为$\left(i, j\right)$的元素到矩阵$A$中欧几里得距离最近的$1$的欧几里得距离。 </p>
<p>对于位置$\left(x, y\right)$和位置$\left(a, b\right)$，它们的欧几里得距离定义为$\left(x - a\right)^2 + \left(y - b\right)^2$。</p>
<p><strong>Input</strong> </p>
<p>输入的第一行包括两个正整数$n, m$。 </p>
<p>接下来有$n$行$01$字符串，每一行字符串的长度为$m$，表示矩阵$B$。 </p>
<p><strong>Output</strong> </p>
<p>请输出$n$行，每一行有$m$个整数，表示矩阵$B$。 </p>
<p><strong>Examples</strong> </p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Input</th>
<th>Output</th>
</tr>
</thead>
<tbody>
<tr>
<td>3 4<br />1000<br />0000<br />0010</td>
<td>0 1 4 5<br />1 2 1 2<br />4 1 0 1</td>
</tr>
</tbody>
</table>
</div>
<p><strong>数据范围</strong></p>
<p>对于$20\%$的数据， $1\le n，m\le 100$</p>
<p>对于100%的数据 $1\le n， m\le 1000$</p>
<blockquote>
<p>对于这个问题，我们可以先看作是对于每一个$1$只对它右下方的$0$有约束作用</p>
<p>那么这道题会变得非常简单啊，就是一个$n^2$暴力就完了，$O(10^6)$还是可以接受的</p>
<p>但是理论上所有的$1$对所有的$0$都有约束作用，那么转一下，跑四遍 $Dp$就可以了 就可以了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">1e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"><span class="keyword">char</span> Input[Maxn];</span><br><span class="line"><span class="keyword">int</span> Dp[Maxn][Maxn], Temp[Maxn][Maxn];<span class="comment">//权值</span></span><br><span class="line">pair &lt;<span class="keyword">int</span> , <span class="keyword">int</span>&gt; Pos[Maxn][Maxn], TP[Maxn][Maxn];<span class="comment">//位置</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> X, <span class="keyword">int</span> Y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (X - Y) * (X - Y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Upt</span><span class="params">(<span class="keyword">int</span> X, <span class="keyword">int</span> Y, <span class="keyword">int</span> Nx, <span class="keyword">int</span> Ny)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> ((Pos[X][Y].first | Pos[X][Y].second) == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">int</span> NAns = Pow(Nx, Pos[X][Y].first) + Pow(Ny, Pos[X][Y].second);</span><br><span class="line">	<span class="keyword">if</span> (NAns &lt; Dp[Nx][Ny])</span><br><span class="line">	&#123;</span><br><span class="line">		Pos[Nx][Ny] = Pos[X][Y];</span><br><span class="line">		Dp[Nx][Ny] = NAns;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Rotate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= M; ++j)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = N; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">		&#123;</span><br><span class="line">			Temp[j][N - i + <span class="number">1</span>] = Dp[i][j];</span><br><span class="line">			TP[j][N - i + <span class="number">1</span>].first = Pos[i][j].second;</span><br><span class="line">			TP[j][N - i + <span class="number">1</span>].second = N - Pos[i][j].first + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">			</span><br><span class="line">	N ^= M ^= N ^= M;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= M; ++j) Dp[i][j] = Temp[i][j], Pos[i][j] = TP[i][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= M; ++j) <span class="built_in">printf</span> (<span class="string">"%d "</span>, Dp[i][j]);</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= M; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (i &gt; <span class="number">1</span>) Upt (i - <span class="number">1</span>, j, i, j);</span><br><span class="line">			<span class="keyword">if</span> (j &gt; <span class="number">1</span>) Upt (i, j - <span class="number">1</span>, i, j);</span><br><span class="line">			<span class="keyword">if</span> (i &gt; <span class="number">1</span> &amp;&amp; j &gt; <span class="number">1</span>) Upt (i - <span class="number">1</span>, j - <span class="number">1</span>, i, j);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	freopen (<span class="string">"distance.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">	freopen (<span class="string">"distance.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">	<span class="built_in">memset</span> (Dp, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> Dp);</span><br><span class="line">	<span class="built_in">scanf</span> (<span class="string">"%d %d"</span>, &amp;N, &amp;M);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span> (<span class="string">"%s"</span>, Input + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= M; ++j)</span><br><span class="line">			<span class="keyword">if</span> (Input[j] - <span class="string">'0'</span>)Dp[i][j] = <span class="number">0</span>, Pos[i][j].first = i, Pos[i][j].second = j;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i, Rotate()) Work();</span><br><span class="line">	Print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后$std$给的方案是从四个方向分别跑一遍斜率优化$Dp$</p>
<p>大概还是一个意思</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> X first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Y second</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; point;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1005</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, f[maxn][maxn], a[maxn][maxn], tmp[maxn][maxn], d[maxn];</span><br><span class="line"><span class="keyword">char</span> s[maxn][maxn];</span><br><span class="line">point Q[maxn];</span><br><span class="line">point <span class="keyword">operator</span>-(point a, point b) &#123;</span><br><span class="line">	<span class="keyword">return</span> point(a.X - b.X, a.Y - b.Y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">cross</span><span class="params">(point a, point b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1L</span>L * a.X * b.Y - <span class="number">1L</span>L * a.Y * b.X;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">cross</span><span class="params">(point a, point b, point c)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> cross(b - a, c - a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(point p, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> p.Y - <span class="number">2</span> * k * p.X;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">		d[i] = <span class="number">2000</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> h = <span class="number">0</span>, t = <span class="number">0</span>;	</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (s[i][j] == <span class="string">'1'</span>) d[j] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">else</span> ++d[j];</span><br><span class="line">			</span><br><span class="line">			point now = make_pair(j, j * j + d[j] * d[j]);</span><br><span class="line">			<span class="keyword">while</span> (h + <span class="number">1</span> &lt; t &amp;&amp; cross(Q[t - <span class="number">1</span>], Q[t], now) &lt;= <span class="number">0</span>) --t;</span><br><span class="line">			Q[++t] = now;</span><br><span class="line">			<span class="keyword">while</span> (h + <span class="number">1</span> &lt; t &amp;&amp; calc(Q[h + <span class="number">1</span>], j) &gt; calc(Q[h + <span class="number">2</span>], j)) ++h;</span><br><span class="line">			a[i][j] = calc(Q[h + <span class="number">1</span>], j) + j * j;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"distance.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"distance.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>, s[i] + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">			tmp[i][j] = s[i][j];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//1</span></span><br><span class="line">	solve();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">			f[i][j] = a[i][j];</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//2</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		reverse(s[i] + <span class="number">1</span>, s[i] + m + <span class="number">1</span>);</span><br><span class="line">	solve();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;++i)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">			f[i][j] = min(f[i][j], a[i][m - j + <span class="number">1</span>]);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//3</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) </span><br><span class="line">			s[i][j] = tmp[n - i + <span class="number">1</span>][j];</span><br><span class="line">	solve();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">			f[i][j] = min(f[i][j], a[n - i + <span class="number">1</span>][j]);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//4</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		reverse(s[i] + <span class="number">1</span>, s[i] + m + <span class="number">1</span>);</span><br><span class="line">	solve();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;++i)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">			f[i][j] = min(f[i][j], a[n - i + <span class="number">1</span>][m - j + <span class="number">1</span>]);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d%c"</span>, f[i][j], j == m ? <span class="string">'\n'</span> : <span class="string">' '</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><del>又臭又长的$std$</del></p>
</blockquote>
<h1 id="树-Tree"><a href="#树-Tree" class="headerlink" title="树(Tree)"></a>树(Tree)</h1><p><strong>Description</strong></p>
<p>鼹鼠们在底下开凿了 $n$ 个洞，由 $n-1$ 条隧道连接，对于任意的$ i&gt;1$，第 $i$ 个洞都会和第 $\frac{i}{2}$（取下整）个洞间有一条隧道，第 $i$ 个洞内还有 $c_i$ 个食物能供最多 $c_i$ 只鼹鼠吃。一共有 $m$ 只鼹鼠，第 $i$ 只鼹鼠住在第 $p_i$ 个洞内。</p>
<p>一天早晨，前 $k$ 只 鼹鼠醒来了，而后 $n-k$ 只鼹鼠均在睡觉，前 $k$ 只鼹鼠就开始觅食，最终他们都会到达某一个洞，使得所有洞的 $c_i$ 均大于等于该洞内醒着的鼹鼠个数，而且要求鼹鼠行动路径总长度最小。现对于所有的 $1\le k \le m$，输出最小的鼹鼠行动 路径的总长度，保证一定存在某种合法方案。</p>
<p><strong>Input</strong></p>
<p>第一行两个数 $n,m$，表示有 $n$个洞，$m$只鼹鼠。 第二行 $n$个整数 $c_i$ 表示第 $i$个洞的食物数。 第三行 $m$ 个整数 $p_i$表示第 $i$只鼹鼠所在洞 $p_i$。</p>
<p><strong>Output</strong></p>
<p>输出一行$m$个整数，第$i$个整数表示当$k = i$时鼹鼠的最小行动路径长度。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Input</th>
<th>Output</th>
</tr>
</thead>
<tbody>
<tr>
<td>5 4 <br />0 0 4 1 1 <br />2 4 5 2</td>
<td>1 1 2 4</td>
</tr>
</tbody>
</table>
</div>
<p><strong>数据范围</strong></p>
<p>$1\le n,m\le 10^5,\; 0\le c_i\le m,\;1 \le p_i\le n $</p>
<blockquote>
<p>所以第一想法就是贪心，这是毫无疑问的</p>
<p>但是考虑到后面的鼹鼠用剩余的点来贪心的话显然是不正确的</p>
<p>怎么办呐?</p>
<p>于是就可以借用网络流的反悔机制</p>
<p><img src="1.png" alt=""></p>
<p>这是$1$(黑)吃了上面的$1$的情况，显然如果$2$要吃饭了的话，$1$时占据了$2$的坑位的</p>
<p>所以其实$2$其实应该吃的是$1$上面的点，但是我们看见的$2$现在能吃的只是$1$下面的点了</p>
<p>让如果我们让这个时候的$2$经过$1$吃的点的时候的边权为$-1$就等价于$1$吃的是下面的点，而$2$吃的是$1$上面的点了</p>
<p><img src="2.png" alt=""></p>
<p>就是让后来的鼹鼠按相反的方向经过了之前的鼹鼠经过的边时，加上$-1$的边权即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">1e6</span>, INF = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Check</span><span class="params">(<span class="keyword">int</span> &amp;X, <span class="keyword">int</span> Y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Y &lt; X ? (X = Y , <span class="number">1</span>) : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M, S;</span><br><span class="line"><span class="keyword">int</span> Dis[Maxn], C[Maxn], Pos[Maxn], Flow[Maxn];<span class="comment">//规定向上走flow + 1，向下走flow - 1，方便记录方向，以便确定边权</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">LenU</span><span class="params">(<span class="keyword">int</span> X)</span> </span>&#123;<span class="keyword">return</span> Flow[X] &lt; <span class="number">0</span> ? <span class="number">-1</span> : <span class="number">1</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">LenD</span><span class="params">(<span class="keyword">int</span> X)</span> </span>&#123;<span class="keyword">return</span> Flow[X] &gt; <span class="number">0</span> ? <span class="number">-1</span> : <span class="number">1</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">UpDate</span><span class="params">(<span class="keyword">int</span> X)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Dis[X] = INF, Pos[X] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (C[X]) Dis[X] = <span class="number">0</span>, Pos[X] = X;</span><br><span class="line">    <span class="keyword">if</span> (Check(Dis[X], Dis[X &lt;&lt; <span class="number">1</span>] + LenD(X &lt;&lt; <span class="number">1</span>))) Pos[X] = Pos[X &lt;&lt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (Check(Dis[X], Dis[X &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] + LenD(X &lt;&lt; <span class="number">1</span> | <span class="number">1</span>))) Pos[X] = Pos[X &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen (<span class="string">"tree.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen (<span class="string">"tree.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%d %d"</span>, &amp;N, &amp;M);</span><br><span class="line">    <span class="built_in">memset</span> (Dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> Dis);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) <span class="built_in">scanf</span> (<span class="string">"%d"</span>, C + i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = N; i &gt;= <span class="number">1</span>; --i) UpDate(i);<span class="comment">//先记录每个点的到子树中最近的洞及距离</span></span><br><span class="line">    <span class="keyword">int</span> Ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (M--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">"%d"</span>, &amp;S);</span><br><span class="line">        int Cost(INF), Now(0), T(0);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> X = S; X != <span class="number">0</span>; X &gt;&gt;= <span class="number">1</span>)<span class="comment">//从这个点到1更新相当于遍历了整棵树</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (Check(Cost, Now + Dis[X])) T = X;</span><br><span class="line">            Now += LenU(X);<span class="comment">//更新点S到X的距离</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> Target = Pos[T];<span class="comment">//这是目标食物的位置</span></span><br><span class="line">        Ans += Cost;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> X = S; X != T; X &gt;&gt;= <span class="number">1</span>) Flow[X]++;<span class="comment">//从X向上走flow应该+1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> X = Target; X != T; X &gt;&gt;= <span class="number">1</span>) Flow[X]--;<span class="comment">//向下走的flow应该-1</span></span><br><span class="line">        C[Target]--;<span class="comment">//又被拿走一个，更新一下</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> X = Target; X != T; X &gt;&gt;= <span class="number">1</span>) UpDate(X);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> X = S; X != <span class="number">0</span>; X &gt;&gt;= <span class="number">1</span>) UpDate(X);<span class="comment">//走过的路径都要更新子树信息</span></span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"%d "</span>, Ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
]]></content>
      <tags>
        <tag>Dp优化</tag>
        <tag>考试</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>T20200607</title>
    <url>/2020/06/07/T20200607/</url>
    <content><![CDATA[<h2 id="题一：答题比赛"><a href="#题一：答题比赛" class="headerlink" title="题一：答题比赛"></a>题一：答题比赛</h2><p><strong>【问题描述】</strong></p>
<p>$YYH$报名参加了一个特殊的电视问答节目。这个节目共有$n$个问题，每回答正确$1$题，$YYH$就会获得$1$分，而每当$YYH$连续答对k题，那么他的现有得分乘以$2$，注意答对第$k$题后，是先加$1$分到总分中，再把总分乘以$2$，此时连续答对题目计数器会清零。现在$YYH$成功对了$m$题，他想知道他的最小得分。因为这个数字可能很大，你只需要输出这个数对$1,000,000,009$取模的结果即可。</p>
<p><strong>【输入格式】</strong></p>
<p>仅一行，三个数$n,m,k$如题目描述。</p>
<p><strong>【输出】</strong></p>
<p>仅一行，一个数，$YYH$的最小得分。</p>
<p><strong>【输入输出样例1】</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>exam.in</th>
<th>exam.out</th>
</tr>
</thead>
<tbody>
<tr>
<td>5 3 2</td>
<td>3</td>
</tr>
</tbody>
</table>
</div>
<p><strong>【输入输出样例2】</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>exam.in</th>
<th>exam.out</th>
</tr>
</thead>
<tbody>
<tr>
<td>5 4 2</td>
<td>6</td>
</tr>
</tbody>
</table>
</div>
<p><strong>【样例解释】</strong></p>
<p>样例$1$答对第$1,3,5$题可以获得最低分$3$分；</p>
<p>样例$2$只答错第$4$题，可以获得最低分$6$分。</p>
<p><strong>【数据范围】</strong></p>
<p>对于$30%$的数据，$n,m,k&lt;=10$</p>
<p>对于$60%$的数据，$n,m,k&lt;=1000$</p>
<p>对于$100%$的数据，$1&lt;=k&lt;=n&lt;=10^9，0&lt;=m&lt;=n$</p>
<blockquote>
<p>贪心一下应该就可以了</p>
</blockquote>
<h2 id="题二：人类基因组"><a href="#题二：人类基因组" class="headerlink" title="题二：人类基因组"></a>题二：人类基因组</h2><p><strong>【问题描述】</strong></p>
<p>$L$教授最近正在研究一个关于人类基因的项目，基因可以被看作一个长度为$n$的序列 $A_1,A_2,\dots,An$: 。对于这个基因序列循环移动$k$位之后，就可以得到一个新的基因序列为：$A_k,\dots,A_1,A_2,…,A_k$ 。当一个基因序列满足对于任意的前$i(1&lt;=i&lt;=n)$项和都满足不小于 $0$，我们就称这个基因序列为优质基因序列。</p>
<p>由于$L$教授最近工作比较繁忙，所以找到了正在实验室闲逛的你，你的任务就是帮$L$教授统计出所有优质基因序列的个数。</p>
<p><strong>【输入格式】</strong></p>
<p>第一行一个整数$n$，表示基因序列的长度。<br>第二行$n$个整数，依次为$A_1,A_2,……,A_n$的值。</p>
<p><strong>【输出格式】</strong></p>
<p>输出仅一个整数，表示优质基因序列的个数。</p>
<p><strong>【输入输出样例1】</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>genes.in</th>
<th>genes.out</th>
</tr>
</thead>
<tbody>
<tr>
<td>3<br />2 2 3</td>
<td>3</td>
</tr>
</tbody>
</table>
</div>
<p><strong>【样例1说明】</strong></p>
<p>  $3$个元素的序列：$2\;2\;3$，循环移动情况如下：<br>  循环移动0位得到序列：$2\;2\;3$，前$i$项和分别为：$2\;4\;7$，符合条件；<br>  循环移动1位得到序列：$2 \;3 \;2$，前$i$项和分别为：$2\;5\;7$；符合条件；<br>  循环移动2位得到序列：$3 \;2 \;2$，前$i$项和分别为：$3 \;5 \;7$；符合条件；</p>
<p><strong>【输入输出样例2】</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>genes.in</th>
<th>genes.out</th>
</tr>
</thead>
<tbody>
<tr>
<td>5<br />3 -1 2 -3 4</td>
<td>2</td>
</tr>
</tbody>
</table>
</div>
<p><strong>【数据范围】</strong></p>
<p>  对于$30%$的数据，满足$1&lt;=N&lt;=5,000 $<br>          对于$50%$的数据，满足$1&lt;=N&lt;=10,000 $<br>          对于$100%$的数据，满足$1&lt;=N&lt;=1,000,000，-1,000&lt;=Ai&lt;=1,000 $</p>
<blockquote>
<p>拼成$2N$的链，单调队列维护一下即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> N, Sum, Cut, Ans, H, T(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> Arr[Maxn &lt;&lt; <span class="number">1</span>], Q[Maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	int X(0), T(1), O(getchar());</span><br><span class="line">	<span class="keyword">while</span> (O &lt; <span class="string">'0'</span> || O &gt; <span class="string">'9'</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (O == <span class="string">'-'</span>) T = <span class="number">-1</span>;</span><br><span class="line">		O = getchar();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (; O &gt;= <span class="string">'0'</span> &amp;&amp; O &lt;= <span class="string">'9'</span>; O = getchar()) X = (X &lt;&lt; <span class="number">1</span>) + (X &lt;&lt; <span class="number">3</span>) + (O ^ <span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> X * T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	freopen (<span class="string">"genes.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">	freopen (<span class="string">"genes.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">	N = Read();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) Arr[i] =  Arr[i + N] = Read();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N * <span class="number">2</span>; ++i) Arr[i] += Arr[i - <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N - <span class="number">1</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (H &lt;= T &amp;&amp; Arr[Q[H]] &gt;= Arr[i]) H++;</span><br><span class="line">		<span class="keyword">while</span> (H &lt;= T &amp;&amp; Arr[Q[T]] &gt;= Arr[i]) --T;</span><br><span class="line">		Q[++T] = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = N; i &lt; N * <span class="number">2</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (H &lt;= T &amp;&amp; i - Q[H] &gt;= N) H++;</span><br><span class="line">		<span class="keyword">while</span> (H &lt;= T &amp;&amp; Arr[Q[T]] &gt;= Arr[i]) --T;</span><br><span class="line">		Q[++T] = i;</span><br><span class="line">		<span class="keyword">if</span> (Arr[Q[H]] &gt;= Arr[i - N + <span class="number">1</span>]) ++Ans;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span> (<span class="string">"%d\n"</span>, Ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="题三：最短路径"><a href="#题三：最短路径" class="headerlink" title="题三：最短路径"></a>题三：最短路径</h2><p><strong>【问题描述】</strong></p>
<p>平面内给出 $n$个点，记横坐标最小的点为 $A$，最大的点为 $B$，现在$Zxd$想要知道在每个点经过一次（$A$点两次）的情况下从$A$走到$B$，再回到$A$的最短路径。但他是个强迫症患者，他有许多奇奇怪怪的要求与限制条件：</p>
<ul>
<li><p>从 $A$ 走到 $B$ 时，只能由横坐标小的点走到大的点。</p>
</li>
<li><p>由 $B$ 回到 $A$ 时，只能由横坐标大的点走到小的点。</p>
</li>
<li><p>有两个特殊点 $b1$ 和 $b2$， $b1$ 在 $0$ 到 $n-1$ 的路上，$b2$ 在 $n-1$ 到 $0$ 的路上。</p>
</li>
</ul>
<p>请你帮他解决这个问题助他治疗吧！</p>
<p><strong>【输入格式】</strong></p>
<p>第一行三个整数 $n,b1,b2,( 0 &lt; b1，b2 &lt; n-1 且 b1 \neq b2)$。n 表示点数，从 $0$ 到 $n-1$ 编号，$b1$ 和 $b2$ 为两个特殊点的编号。</p>
<p>以下 $n$ 行，每行两个整数 $x,y$ 表示该点的坐标$(0 &lt;= x，y &lt;= 2000)$，从 $0$ 号点顺序给出。$Doctor Gao$为了方便他的治疗，已经将给出的点按 $x$ 增序排好了。</p>
<p><strong>【输出格式】</strong></p>
<p>仅一行，输出最短路径长度（精确到小数点后面 $2$ 位）。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>【样例输入】</th>
<th>【样例输出】</th>
</tr>
</thead>
<tbody>
<tr>
<td>5 1 3<br />1 3<br />3 4<br />4 1<br />7 5<br />8 3</td>
<td>18.18</td>
</tr>
</tbody>
</table>
</div>
<p><strong>【样例解释】</strong></p>
<p>最短路径：$0-&gt;1-&gt;4-&gt;3-&gt;2-&gt;0$</p>
<p><strong>【数据范围】</strong></p>
<p>$20%$的数据$n&lt;=20$</p>
<p>$60%$的数据$n&lt;=300$</p>
<p>$100%$的数据$n&lt;=1000$</p>
<p>对于所有数据$x,y,b1,b2$如题目描述。</p>
<blockquote>
<p>对于这种问题，发现他的数据很小，考虑Dp：</p>
<blockquote>
<p>就是$Dp\left[i\right]\left[j\right]$表示来经过$i$, 回去经过$j$</p>
<p>所以有:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">k = max(i, j) + <span class="number">1</span>;</span><br><span class="line">Dp[i][k] = max(Dp[i][k], Dp[i][j] + Dis(j, k));</span><br><span class="line">Dp[k][j] = max(Dp[k][j], Dp[i][j] + Dis(i, k));</span><br></pre></td></tr></table></figure>
<p>所以就可以愉快的切掉了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> INF = <span class="number">1e9</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> N, B1, B2;</span><br><span class="line"><span class="keyword">double</span> Ans, F[Maxn][Maxn];</span><br><span class="line"><span class="keyword">int</span> X[Maxn], Y[Maxn], Pre[Maxn];</span><br><span class="line"><span class="keyword">bool</span> Vis[Maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">Get</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sqrt</span>((X[A] - X[B]) * (X[A] - X[B]) + (Y[A] - Y[B]) * (Y[A] - Y[B]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">UpDate</span><span class="params">(<span class="keyword">double</span> &amp;X, <span class="keyword">double</span> Upt)</span> </span>&#123; <span class="keyword">if</span> (Upt &lt; X) X = Upt; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	freopen (<span class="string">"paths.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">	freopen (<span class="string">"paths.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">	<span class="built_in">scanf</span> (<span class="string">"%d %d %d"</span>, &amp;N, &amp;B1, &amp;B2);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) <span class="built_in">scanf</span> (<span class="string">"%d %d"</span>, X + i, Y + i);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; ++i)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= N; ++j) </span><br><span class="line">			F[i][j] = INF;</span><br><span class="line">	F[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (i == N - <span class="number">1</span> &amp;&amp; j == N - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">int</span> K = max(i, j);</span><br><span class="line">			<span class="keyword">if</span> (K == N - <span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (i != N - <span class="number">1</span> &amp;&amp; K != B2) UpDate(F[K][j], F[i][j] + Get(i, K));</span><br><span class="line">				<span class="keyword">if</span> (j != N - <span class="number">1</span> &amp;&amp; K != B1) UpDate(F[i][K], F[i][j] + Get(j, K));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> </span><br><span class="line">			&#123;</span><br><span class="line">				++K;</span><br><span class="line">				<span class="keyword">if</span> (K != B2) UpDate(F[K][j], F[i][j] + Get(i, K));</span><br><span class="line">				<span class="keyword">if</span> (K != B1) UpDate(F[i][K], F[i][j] + Get(j, K));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span> (<span class="string">"%.2lf\n"</span>, F[N - <span class="number">1</span>][N - <span class="number">1</span>]);</span><br><span class="line">		<span class="comment">// system("pause");</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</blockquote>
]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>Dp优化</tag>
        <tag>考试</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title>T20200603</title>
    <url>/2020/06/03/T20200603/</url>
    <content><![CDATA[<h1 id="1、种树（trees-cpp-1S-128M）"><a href="#1、种树（trees-cpp-1S-128M）" class="headerlink" title="1、种树（trees. cpp/1S/128M）"></a>1、种树（trees. cpp/1S/128M）</h1><p><strong>【问题描述】</strong></p>
<p> 一条街的一边有几座房子。因为环保原因居民想要在路边种些树。路边的地区被分割成$n$块，并被编号为 $1„n$。每个块的大小为一个单位尺寸并最多可种一棵树。每个居民想在门前 种些树并指定了三个号码 $b,e,t$。这三个数表示该居民想在 $b$ 和 $e$ 之间最少种 $t$ 棵树。当 然，$b\le e$，居民必须保证在指定地区不能种多于地区被分割成块数的树，即要求 $t\le e-b+1$， 允许居民想种树的各自区域可以交叉。出于资金短缺的原因，环保部门请你求出能够满足所 有居民的要求，需要种树的最少数量。 </p>
<p><strong>【文件输入】</strong> 第一行为 $n$，表示区域的个数；第二行为 $h$，表示房子的数目；下面 $h$ 行描述居民的需要：$b\;e\;t\left(0&lt;b\le e \le 30000, r \le e-b+l\right)$分别用一个空格分开</p>
<p><strong>【文件输出】</strong> 输出为满足所有要求的最少树的数量。 </p>
<div class="table-container">
<table>
<thead>
<tr>
<th>样例输入</th>
<th>样例输出</th>
</tr>
</thead>
<tbody>
<tr>
<td>9 <br />4 <br />1 4 2 <br />4 6 2 <br />8 9 2 <br />3 5 2</td>
<td>5</td>
</tr>
</tbody>
</table>
</div>
<p><strong>【数据规模】</strong></p>
<p>$30\%$的数据满足$0&lt;n\le 1000$, $0 &lt; h \le 500$;</p>
<p>$100\%$的数据满足$n \le 30000$, $h \le 5000$;</p>
<blockquote>
<p>怎么做？</p>
<p>贪心 + 线段树维护</p>
<p>其实数据水， $N^2$也可以$AC$</p>
<p>就是要注意排序的顺序</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">3e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> N, H;</span><br><span class="line"><span class="keyword">int</span> Sum[Maxn &lt;&lt; <span class="number">2</span>], Tag[Maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> B, E, T;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;Temp) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (E == Temp.E) <span class="keyword">return</span> T &lt; Temp.T;</span><br><span class="line">        <span class="keyword">return</span> E &lt; Temp.E;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;P[Maxn];<span class="comment">//需求</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">PushUp</span><span class="params">(<span class="keyword">int</span> X)</span></span>&#123;Sum[X] = Sum[X &lt;&lt; <span class="number">1</span>] + Sum[X &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">F</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> X)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Sum[X] = (R - L + <span class="number">1</span>);</span><br><span class="line">    Tag[X] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">PushDown</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> X)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!Tag[X]) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> Mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    F(L, Mid, X &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    F(Mid + <span class="number">1</span>, R, X &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">    Tag[X] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UpDate</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> Tl, <span class="keyword">int</span> Tr, <span class="keyword">int</span> X = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L &gt;= Tl &amp;&amp; R &lt;= Tr) </span><br><span class="line">    &#123;</span><br><span class="line">        Sum[X] = R - L + <span class="number">1</span>;</span><br><span class="line">        Tag[X] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    PushDown(L, R, X);</span><br><span class="line">    <span class="keyword">int</span> Mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (Tl &lt;= Mid) UpDate(L, Mid, Tl, Tr, X &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (Tr &gt; Mid) UpDate(Mid + <span class="number">1</span>, R, Tl, Tr, X &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">    PushUp(X);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> Tl, <span class="keyword">int</span> Tr, <span class="keyword">int</span> X = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L &gt;= Tl &amp;&amp; R &lt;= Tr) <span class="keyword">return</span> Sum[X];</span><br><span class="line">    <span class="keyword">int</span> Mid = (L + R) &gt;&gt; <span class="number">1</span>, Ans(<span class="number">0</span>);</span><br><span class="line">    PushDown(L, R, X);</span><br><span class="line">    <span class="keyword">if</span> (Tl &lt;= Mid) Ans += Query(L, Mid, Tl, Tr, X &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (Tr &gt; Mid) Ans += Query(Mid + <span class="number">1</span>, R, Tl, Tr, X &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> Ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Get</span><span class="params">(<span class="keyword">int</span> TL, <span class="keyword">int</span> TR, <span class="keyword">int</span> T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    int L(TL), R(TR), Ans(TL);</span><br><span class="line">    <span class="keyword">while</span> (L &lt;= R)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> Mid = (L + R) &gt;&gt; <span class="number">1</span>, S = ((Mid - <span class="number">1</span>) &lt; TL ? <span class="number">0</span> : Query(<span class="number">1</span>, N, TL, Mid - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span> (S + TR - Mid + <span class="number">1</span> &gt;= T) Ans = Mid, L = Mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> R = Mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen ("trees.in", "r", stdin);</span></span><br><span class="line">    <span class="comment">// freopen ("trees.out", "w", stdout);</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%d %d"</span>, &amp;N, &amp;H);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; H; ++i) </span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">"%d %d %d"</span>, &amp;P[i].B, &amp;P[i].E, &amp;P[i].T);  </span><br><span class="line"></span><br><span class="line">    sort (P, P + H);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; H; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> Num = Query(<span class="number">1</span>, N, P[i].B, P[i].E);</span><br><span class="line">        <span class="keyword">if</span> (Num &gt;= P[i].T) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> Place = Get(P[i].B, P[i].E, P[i].T);</span><br><span class="line">        UpDate(<span class="number">1</span>, N, Place, P[i].E);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"%d\n"</span>, Sum[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="2-高一学堂-at-cpp-1S-256M"><a href="#2-高一学堂-at-cpp-1S-256M" class="headerlink" title="2.高一学堂 (at. cpp/1S/256M)"></a>2.高一学堂 (at. cpp/1S/256M)</h1><p><strong>【问题描述】</strong></p>
<p>在美丽的东辰中学里面，有一座高一学堂。所谓山不在高，有仙则名；水不</p>
<p>在深，有龙则灵。高一学堂，因为有了 $YJYX$，就成了现在这个样子 = =。</p>
<p>由于 $YJYX$ 的语言太过雷人，每次他发微往往都会有一石激起千层浪的效果，</p>
<p>具体就是所有关注他的人都会转发，同时$@$他，接着关注这些人的人也会转</p>
<p>发，同时$@$他关注的人（注意转发内容本身会有$@YJYX$），以此类推。这样导致每</p>
<p>次 llj 发微博都会被$@$上兆次，而 $llj$ 又特别喜欢发，$sina$ 支持不了如此庞大的数</p>
<p>据量，特出规定，每次转发时，$@$的人不能超过 $K$ 人，好友在转发时如果超过</p>
<p>了，就把最早那人删掉。现在 $YJYX$ 刚发了一条微博“求$AK$”，他想知道每个与</p>
<p>他有联系的人分别会被$@$多少次。</p>
<p><strong>【输入】</strong> </p>
<p>输入第一行有三个整数$,N,K,$表示人数和 $K$。</p>
<p>接下来 $N-1$ 行，每行有 $2$ 个整数 $a，b，$表示 $a$ 和 $b$ 有关注关系。</p>
<p>输入给出一棵以 $1$ 号点为根的树，一号点代表 $YJYX$，对于任意一个点，他的</p>
<p>儿子都关注他。</p>
<p><strong>【输出】</strong> </p>
<p>输出有 $N$ 行，每行有一个整数，这个人会被$@$多少次。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>样例输入</th>
<th>样例输出</th>
</tr>
</thead>
<tbody>
<tr>
<td>5 2<br />1 2<br />2 3<br />2 4<br />4 5</td>
<td>3<br />3<br />0<br />1<br />0</td>
</tr>
</tbody>
</table>
</div>
<p><strong>【数据规模】</strong> </p>
<p>对于 $30\%$的数据，$N≤100$；</p>
<p>对于 $60\%$的数据，$N≤2000，k≤100$；</p>
<p>对于 $100\%$的数据，$N≤100000$。</p>
<blockquote>
<p>倍增 + 树上差分一下即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> N, K, U, V, Cur;</span><br><span class="line"><span class="keyword">int</span> Sum[Maxn], Val[Maxn], CF[Maxn], F[Maxn][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> Head[Maxn], Next[Maxn &lt;&lt; <span class="number">1</span>], E[Maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> X, <span class="keyword">int</span> Fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    F[X][<span class="number">0</span>] = Fa; CF[Fa]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">19</span>; ++i) F[X][i] = F[F[X][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> TO = X, TK = K;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; TK; ++i)</span><br><span class="line">        <span class="keyword">if</span> (TK &amp; (<span class="number">1</span> &lt;&lt; i)) </span><br><span class="line">        &#123;</span><br><span class="line">            TK ^= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">            TO = F[TO][i];</span><br><span class="line">        &#125;</span><br><span class="line">    CF[F[TO][<span class="number">0</span>]]--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = Head[X]; i; i = Next[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (E[i] ==  Fa) <span class="keyword">continue</span>;</span><br><span class="line">        DFS (E[i], X);</span><br><span class="line">        CF[X] += CF[E[i]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> U, <span class="keyword">int</span> V)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Next[++Cur] = Head[U];</span><br><span class="line">    Head[U] = Cur;</span><br><span class="line">    E[Cur] = V;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    int X(0), O(getchar());</span><br><span class="line">    <span class="keyword">while</span> (O &lt; <span class="string">'0'</span> || O &gt; <span class="string">'9'</span>) O = getchar();</span><br><span class="line">    <span class="keyword">for</span> (; O &gt;= <span class="string">'0'</span> &amp;&amp; O &lt;= <span class="string">'9'</span>; O = getchar()) X = (X &lt;&lt; <span class="number">1</span>) + (X &lt;&lt; <span class="number">3</span>) + (O ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> X;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen (<span class="string">"at.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen (<span class="string">"at.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">    N = Read(), K = Read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        U = Read(), V = Read();</span><br><span class="line">        AddEdge(U, V), AddEdge(V, U);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DFS(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) <span class="built_in">printf</span> (<span class="string">"%d\n"</span>, CF[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="3-高二学堂-poker-cpp-1S-256M"><a href="#3-高二学堂-poker-cpp-1S-256M" class="headerlink" title="3.高二学堂 (poker.cpp/1S/256M)"></a>3.高二学堂 (poker.cpp/1S/256M)</h1><p><strong>【问题描述】</strong></p>
<p>在美丽的东辰中学里，有座高二学堂，同样也是因为一个人，让它们变成了</p>
<p>现在这个样子~那就是我们伟大的级主任。</p>
<p>因为他，我们又迎来了一个木有电影，只有对答案的段考日；又迎来了一个</p>
<p>不是大礼拜，而是小礼拜的周末。因为是小礼拜，同学们都不回家，所以干脆就</p>
<p>回到宿舍去玩牌了。而由于三国杀太$ out $了，所以现在他们都玩四国杀。</p>
<p>四国杀（说白了就是扑克牌~）是 $Wayne$ 发明的，源于他对升级、斗地主、</p>
<p>锄大地等等玩法都感到厌倦了。于是他提出了这个新的玩法：</p>
<p>$Wayne$ 有一副加强版的扑克牌，强大到任意取一个自然数 $x$，在牌堆里都恰</p>
<p>有 $4$ 张数值为 $x$ 的牌。每次，$Wayne$ 随机生成两个正整数 $n$ 和 $k$，然后在牌堆里</p>
<p>选取不超过 $k$ 张牌，使得牌面数字之和恰为 $n$。已知 $Wayne$ 玩了若干盘，每盘都</p>
<p>算出了对应的方案数，他想请你也算出各盘方案数，以验算他的结果是否正确。</p>
<p>结果可能比较大，你只需要求出方案数 $mod 1000000009$ 的值即可。</p>
<p><strong>【输入】</strong> </p>
<p>输入文件包含不超过 $10$ 组数据。</p>
<p>每行包含两个整数，表示上文中的 $n$ 和 $k$。</p>
<p>输入数据以两个 $0$ 表示结束。</p>
<p><strong>【输出】</strong> </p>
<p>输出文件中，每组数据输出一行，为对应的方案数。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>样例输入</th>
<th>样例输出</th>
</tr>
</thead>
<tbody>
<tr>
<td>2 1<br />2 2<br />2 3<br />50 5<br />0 0</td>
<td>4<br />10<br />10<br />1823966<br /></td>
</tr>
</tbody>
</table>
</div>
<p><strong>【数据规模】</strong> </p>
<p>对于 $10\%$的数据，$k=1$；</p>
<p>对于 $20\%$的数据，$n≤10，k≤4$；</p>
<p>对于 $40\%$的数据，$n≤1000$；</p>
<p>对于 $60\%$的数据，$n≤100000$；</p>
<p>对于另外 $20\%$的数据，只有 $1$ 组数据；</p>
<p>对于 $100\%$的数据，$n≤10^9，k≤10$。</p>
<blockquote>
<p>【算法1】</p>
<p>​    输出n，不解释。。。</p>
<p>​    期望得分：10。</p>
<p>【算法2】</p>
<p>​    利用上式对Ai和Xi进行搜索，同样不解释。。。</p>
<p>​    期望得分：20。</p>
<p>【算法3】</p>
<p>​    把牌按数值大小编号，数值相同的编上4个不同号码。</p>
<p>​    用f[i][j][k]表示现在处理完前i张牌，一共用了j张，构成和为k的方案数。转移只要使用类似背包的方法即可。</p>
<p>方程为：f’[i][j][k]=f[i][j][k]+Σf[i-1][j-1][k-w(i)]。</p>
<p>其中w(i)为i的牌面。</p>
<p>为免MLE，可把第一维省去。</p>
<p>期望得分：40。</p>
<p>【算法4】</p>
<p>​    这是Symbol提出来的方法。</p>
<p>​    如果现在所有的牌面都大于1，假设有k’张，那么把所有牌面都减小1，总和减少k’之后，问题显然是等价的；而如果有牌面等于1，那么只要把这几张牌去掉，剩下的牌面就又都是大于1的了。</p>
<p>​    所以可以使用f[i][j]表示用j张牌构成和为i的方案数，转移的时候分情况：1）所有牌面大于1，则f[i][j]+=f[i-j][j]；2）有牌面等于1，那么我们可以枚举这些牌的数量t（≤4），则f[i][j]+=f[i-j][j-t]。</p>
<p>​    最后答案就是f[n][1~k]的最小值。</p>
<p>​    时间复杂度为O(nk)。</p>
<p>​    期望得分：60。</p>
<p>【算法5】</p>
<p>​    对算法4进行优化，考虑到k比较小，而转移只需要用到前k层的值。</p>
<p>我们可以把连续k层的f压在一个矩阵内，并按一维编号，最多不超过k^2个。然后我们每次转移1层的f，也就是如果现在矩阵记录的是f[1~k][]的值，那么转移一次，矩阵记录的就变成了f[2~k+1][]的值。然后填矩阵就是了。</p>
<p>时间复杂度为O(logn*k^6)，多组数据下，这个方法会由于常数大被卡掉。</p>
<p>期望得分：80。</p>
<p>【算法6】</p>
<p>​    首先，假设牌面的集合为{xi}，集合中的每个元素对应一个ai（≤4），表示这个牌面用了多少张。那么问题就转化成了求Σai*xi=n的正整数解个数，其中x1&lt;x2&lt;…&lt;xm，Σai≤k。由于ai和k都比较小，我们可以暴力枚举所有情况，再去解方程。而现在约束还是比较多的，我们得想办法除去约束。</p>
<p>​    设yi=xi-x(i-1)，换元后方程变为Σbi*yi=n的形式，其中bi≤k。至此，我们成功把未知数单调这个棘手的约束解决了。</p>
<p>​    接下来，我们发现bi比较小（≤10），那么可以把bi的lcm算出来，最多为2520。然后把bi<em>yi表示成pi</em>lcm+qi的形式，其中qi必须能被bi整除。</p>
<p>​    现在方程转化为lcm*Σpi+Σqi=n。</p>
<p>​    考虑到Σqi还是比较小的（≤3W），可以枚举Σqi的每个可能值，那么pi的方案数就可以用经典的隔板法来计算。而对于Σqi的计算，我们可以用背包来实现。背包的时候要注意各种细节，而且注意复杂度的把握。</p>
<p>​    期望得分：100。</p>
<p>然而并没有看懂？？？</p>
<p>当时打了个表就交了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Poker Hewr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fo(i,a,b) for (int i=a; i&lt;=b; ++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fd(i,a,b) for (int i=a; i&gt;=b; --i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mo 1000000009</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mn=<span class="number">11</span>,mm=<span class="number">30010</span>;</span><br><span class="line"><span class="keyword">int</span> a[mn],d[mn],Rev[mn],f[mm],F[mm];</span><br><span class="line"><span class="keyword">int</span> n,k,m,L,Ans,NowS,N,A,B;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> c;</span><br><span class="line">	<span class="keyword">while</span> (c=(a%b)) a=b,b=c;</span><br><span class="line">	<span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (a&lt;b) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> ret=Rev[b];</span><br><span class="line">	fo (i,a-b+<span class="number">1</span>,a) ret=(LL)ret*i%mo;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (b)&#123;</span><br><span class="line">		<span class="keyword">if</span> (b&amp;<span class="number">1</span>) ret=(LL)ret*a%mo;</span><br><span class="line">		a=(LL)a*a%mo,b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	fo (i,<span class="number">0</span>,NowS) F[i]=f[i];</span><br><span class="line">	<span class="keyword">int</span> l=L/x*x;</span><br><span class="line">	fo (i,NowS+<span class="number">1</span>,min(n,NowS+l)) F[i]=<span class="number">0</span>;</span><br><span class="line">	NowS=min(n,NowS+l);</span><br><span class="line">	fo (i,<span class="number">0</span>,NowS)&#123;</span><br><span class="line">		f[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (i&gt;=x)&#123;</span><br><span class="line">			F[i]=(F[i]+(f[i]=F[i-x]))%mo;</span><br><span class="line">			<span class="keyword">if</span> (i&gt;=l+x) f[i]=(f[i]-F[i-l-x]+mo)%mo;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*int y=x;</span></span><br><span class="line"><span class="comment">	while (y&lt;=L)&#123;</span></span><br><span class="line"><span class="comment">		fd (i,min(n-y,NowS),0) f[i+y]=(f[i+y]+F[i])%mo;</span></span><br><span class="line"><span class="comment">		y+=x;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	NowS=min(n,NowS+L/x*x);*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> Ans=<span class="number">0</span>;</span><br><span class="line">	d[m]=a[m];</span><br><span class="line">	fd (i,m<span class="number">-1</span>,<span class="number">1</span>) d[i]=d[i+<span class="number">1</span>]+a[i];</span><br><span class="line">	f[<span class="number">0</span>]=<span class="number">1</span>,NowS=<span class="number">0</span>,L=<span class="number">1</span>;</span><br><span class="line">	fo (i,<span class="number">1</span>,m) L=L*d[i]/gcd(L,d[i]);</span><br><span class="line">	fo (i,<span class="number">1</span>,m) dp(d[i]);</span><br><span class="line">	fo (nn,m,NowS) <span class="keyword">if</span> (!((N=n-nn)%L) &amp;&amp; (A=f[nn]))&#123;</span><br><span class="line">		B=C(N/L+m<span class="number">-1</span>,m<span class="number">-1</span>);</span><br><span class="line">		Ans=((LL)A*B+Ans)%mo;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> M,<span class="keyword">int</span> K,<span class="keyword">int</span> W)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (M&gt;<span class="number">1</span>)&#123;</span><br><span class="line">		m=M<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">int</span> tmp=work();</span><br><span class="line">		Ans=((LL)tmp*W+Ans)%mo;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!K) <span class="keyword">return</span>;</span><br><span class="line">	fo (i,<span class="number">1</span>,<span class="number">4</span>) <span class="keyword">if</span> (i&lt;=K)&#123;</span><br><span class="line">		a[M]=i;</span><br><span class="line">		dfs(M+<span class="number">1</span>,K-i,(LL)W*C(<span class="number">4</span>,i)%mo);</span><br><span class="line">		a[M]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Rev[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	fo (i,<span class="number">1</span>,mn<span class="number">-1</span>) Rev[i]=(LL)Rev[i<span class="number">-1</span>]*Pow(i,mo<span class="number">-2</span>)%mo;</span><br><span class="line">	freopen(<span class="string">"poker.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"poker.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k)&#123;</span><br><span class="line">		<span class="keyword">if</span> (!(n+k)) <span class="keyword">break</span>;</span><br><span class="line">		Ans=<span class="number">0</span>;</span><br><span class="line">		dfs(<span class="number">1</span>,k,<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;Ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
]]></content>
      <tags>
        <tag>倍增</tag>
        <tag>数据结构</tag>
        <tag>鸽~</tag>
        <tag>考试</tag>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title>T20200610</title>
    <url>/2020/06/10/T20200610/</url>
    <content><![CDATA[<h2 id="1-第一题-eat-cpp-c-pas"><a href="#1-第一题-eat-cpp-c-pas" class="headerlink" title="1.第一题 (eat.cpp/c/pas)"></a>1.第一题 (eat.cpp/c/pas)</h2><p><strong>【问题描述】</strong></p>
<p>凶猛的XX出来吃人了!</p>
<p>每天早晨，XX从大山里出来，到达一个城市，然后花费一整天的时间把这座城市里的人 吃光。直到夜晚，XX才回到山中去。当XX经过一个城市时，不管是否吃人，它都会把这座城 市彻底破坏，以至于下次不能再到这个城市吃人了。 </p>
<p>显然，城市里的居民无法忍受这样的状况。所以，每天夜晚，每座城市里都会有一个人 逃到乡下去，到了乡下以后XX就永远吃不到他了。</p>
<p>城市之间有一些双向道路连接着。其中 1 号城市连接着大山，即XX每天的旅途的起点。 当然，XX只能沿着这些道路走。XX意识到必须抓紧时间吃人，所以它每天都要认真选取要去的城市，当然它不能选择已 经被吃过或破坏过的城市。现在问题来了，在所有城市没有人居住之前，XX最多能吃掉多少 人？ </p>
<p><strong>【输入】</strong></p>
<p>​    输入文件名为 eat.in。</p>
<p>​     第一行两个整数𝑛, 𝑚，用一个空格隔开，表示城市的个数和道路数。 </p>
<p>​    第二行𝑛个整数𝑎𝑖，表示每座城市初始的人数。两个数之间用一个空格隔开。 </p>
<p>​    接下来𝑚行，每行两个整数𝑢, 𝑣(1 ≤ 𝑢, 𝑣 ≤ 𝑛, 𝑢 ≠ 𝑣)，用一个空格隔开，表示城市𝑢和城 市𝑣之间有一条双向道路。城市 1 和大山之间也有一条双向道路。 数据保证所有城市都存在到城市 1 的路径。 </p>
<p><strong>【输出】</strong></p>
<p>​     输出文件名为 eat.out。 输出共一行一个整数，表示在所有城市没有人居住之前，**最多能吃掉的人数。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>输入</th>
<th style="text-align:left">输出</th>
</tr>
</thead>
<tbody>
<tr>
<td>5 5 <br />1 3 2 4 7 <br />1 2 <br />1 3 <br />2 3 <br />2 4 <br />3 5</td>
<td style="text-align:left">11</td>
</tr>
</tbody>
</table>
</div>
<p><strong>【数据说明】</strong> </p>
<p>​    对于 10%的数据，1 ≤ 𝑛 ≤ 5，0 ≤ 𝑚 ≤ 10，0 ≤ 𝑎𝑖 ≤ 5。 </p>
<p>​    对于 30%的数据，1 ≤ 𝑛 ≤ 200，0 ≤ 𝑚 ≤ 500，0 ≤ 𝑎𝑖 ≤ 200。 </p>
<p>​    对于 60%的数据，1 ≤ 𝑛 ≤ 2,000，0 ≤ 𝑚 ≤ 10,000，0 ≤ 𝑎𝑖 ≤ 20,000。 </p>
<p>​    对于 100%的数据，1 ≤ 𝑛 ≤ 200,000，0 ≤ 𝑚 ≤ 2,000,000，0 ≤ 𝑎𝑖 ≤ 2,000,000。</p>
<blockquote>
<p>所以怎么做呢?</p>
<p>考虑贪心: 吃的最多本着上就是走的人最少, 那么就意味着要最先吃掉人最多的地方, 能够有机会离开的人才最少</p>
</blockquote>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll Maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line">ll N, M, Ans;</span><br><span class="line">ll Num[Maxn]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(ll a, ll b)</span> </span>&#123;<span class="keyword">return</span> a &gt; b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen (<span class="string">"eat.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen (<span class="string">"eat.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%lld %lld"</span>, &amp;N, &amp;M);</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">0</span>; i &lt; N; ++i) <span class="built_in">scanf</span> (<span class="string">"%lld"</span>, Num + i);</span><br><span class="line">    sort (Num, Num + N, cmp);</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Num[i] &lt;= i) <span class="keyword">break</span>;</span><br><span class="line">        Ans += (Num[i] - i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"%lld\n"</span>, Ans);</span><br><span class="line">&#125;<span class="comment">//一定要开long long, 后面40分爆int了!!!</span></span><br></pre></td></tr></table></figure>
<h2 id="2-整数划分-division-cpp-c-pas"><a href="#2-整数划分-division-cpp-c-pas" class="headerlink" title="2.整数划分 (division.cpp/c/pas)"></a>2.整数划分 (division.cpp/c/pas)</h2><p><strong>【问题描述】</strong> </p>
<p>​    BG 得到了一个整数𝑁，他想要把𝑁分解成若干个小整数的乘积。 </p>
<p>​    BG 给出了他的分解规则： </p>
<ul>
<li>分解出的整数必须来自集合𝑆； </li>
<li>分解出的整数必须互不相同，且两两互质。 现在给出整数𝑁，集合大小𝑀和集合𝑆，求 BG 有多少种分解方法。</li>
</ul>
<p><strong>【输入】</strong> </p>
<pre><code> 输入文件名为 division.in。
</code></pre><p>​     第一行两个整数𝑁, 𝑀，表示要分解的数和集合大小。</p>
<p>​     第二行包含𝑀个互不相同的整数𝑎𝑖，描述了集合𝑆，即𝑆 = {𝑎1, 𝑎2, 𝑎3, … , 𝑎𝑀}。 </p>
<p><strong>【输出】</strong></p>
<p>​     输出文件名为 division.out。 </p>
<p>​    输出共一行一个整数，表示方案数。</p>
<p>​    数据保证答案在 64 位带符号整数范围内。 如果没有方案，输出一个 0。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>输入</th>
<th>输出</th>
</tr>
</thead>
<tbody>
<tr>
<td>12  5<br />2 3 4 5 6<br /></td>
<td>1</td>
</tr>
<tr>
<td>42 8 <br />1 2 3 6 7 14 21 42</td>
<td>10</td>
</tr>
</tbody>
</table>
</div>
<p><strong>【输入输出样例说明】</strong></p>
<p>​     共 10 种方案：42，1 × 42，2 × 21，3 × 14，6 × 7，1 × 2 × 21，1 × 3 × 14，1 × 6 × 7， 2 × 3 × 7 和 1 × 2 × 3 × 7。</p>
<blockquote>
<p>打一个表:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">6</span></span><br><span class="line"><span class="number">5</span> <span class="number">30</span></span><br><span class="line"><span class="number">7</span> <span class="number">210</span></span><br><span class="line"><span class="number">11</span> <span class="number">2310</span></span><br><span class="line"><span class="number">13</span> <span class="number">30030</span></span><br><span class="line"><span class="number">17</span> <span class="number">510510</span></span><br><span class="line"><span class="number">19</span> <span class="number">9699690</span></span><br><span class="line"><span class="number">23</span> <span class="number">223092870</span></span><br><span class="line"><span class="number">29</span> <span class="number">6469693230</span></span><br><span class="line"><span class="number">31</span> <span class="number">200560490130</span></span><br><span class="line"><span class="number">37</span> <span class="number">7420738134810</span></span><br><span class="line"><span class="number">41</span> <span class="number">304250263527210</span></span><br><span class="line"><span class="number">43</span> <span class="number">13082761331670030</span></span><br><span class="line"><span class="number">47</span> <span class="number">614889782588491410</span></span><br><span class="line"><span class="number">53</span> <span class="number">-4304329670229058502</span></span><br></pre></td></tr></table></figure>
<p>当我们乘到第$16$的质数时已经是爆$long \; long$了,  那么就是说$N$的不同的质因子最多最多就只有$15$个</p>
<p>那么再看我们的性质$2$ : 分解出的整数必须互不相同，且两两互质</p>
<p>那么说明了什么?</p>
<p>换句话讲,  就是说你每次分解出的整数中, 至少包含了一个质因子, 且这个质因子的所有指数一定会全部被分解出去</p>
<p>否则不能保证分解出的所有整数能够两两互质</p>
<p>那么剩下的就是一个状压DP惹</p>
</blockquote>
<h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span>  <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">1e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> M, P[Maxn], Q[Maxn], S[Maxn &gt;&gt; <span class="number">2</span>], p[Maxn &gt;&gt; <span class="number">2</span>][<span class="number">20</span>], q[Maxn &gt;&gt; <span class="number">2</span>][<span class="number">20</span>];<span class="comment">//p[i][j],q[i][j]分别表示i的第j个质因子的底数和指数, S是记录i有多少个质因子</span></span><br><span class="line">ll N, f[<span class="number">1</span> &lt;&lt; <span class="number">20</span>];</span><br><span class="line"><span class="built_in">map</span> &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; F;<span class="comment">//F[i] 表示质因子i的指数的值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen (<span class="string">"division.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen (<span class="string">"division.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%lld %d"</span>, &amp;N, &amp;M);</span><br><span class="line">    int n(0), nn(0);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> X;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">"%d"</span>, &amp;X);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j * j &lt;= X; ++j)</span><br><span class="line">            <span class="keyword">if</span> (X % j == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">for</span> (p[i][++S[i]] = j, P[++nn] = j; X % j == <span class="number">0</span>; X /= j, q[i][S[i]]++);<span class="comment">//记录S集合中的点的信息</span></span><br><span class="line">        <span class="keyword">if</span> (X &gt; <span class="number">1</span>) p[i][++S[i]] = X, q[i][S[i]] = <span class="number">1</span>, P[++nn] = X;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nn; ++i)</span><br><span class="line">        <span class="keyword">if</span> (N % P[i] == <span class="number">0</span> &amp;&amp; !F[P[i]])</span><br><span class="line">        &#123;</span><br><span class="line">            P[++n] = P[i], F[P[i]] = n;</span><br><span class="line">            <span class="keyword">for</span> (; N % P[i] == <span class="number">0</span>; N /= P[i], Q[n]++);<span class="comment">//分解N, 得到N的一些列质因子</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (N &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"0"</span>) &amp; <span class="number">0</span>;<span class="comment">//如果N此时还有值, 显然S集合中的数是不可行的</span></span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> X = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= S[i]; j++)</span><br><span class="line">            <span class="keyword">if</span> (F[p[i][j]] &amp;&amp; Q[F[p[i][j]]] == q[i][j]) X |= <span class="number">1</span> &lt;&lt; (F[p[i][j]] - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                X = <span class="number">-1</span>; </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (X &gt; <span class="number">-1</span>) </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) </span><br><span class="line">                <span class="keyword">if</span> (!(j &amp; X)) f[j | X] += f[j];<span class="comment">//累加贡献</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"%d\n"</span>, f[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>]);<span class="comment">//顺利切掉</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>考场上想的是暴力:</p>
<p>就是在输入$S$集合的时候，只保留$N$的因子，然后 伪$Dp$求解：</p>
</blockquote>
<h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="built_in">map</span> &lt;ll, ll&gt; Dp;</span><br><span class="line">priority_queue &lt;ll&gt; K;</span><br><span class="line">ll N, M, Temp;</span><br><span class="line"><span class="keyword">bool</span> GRD;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Gcd</span><span class="params">(ll X, ll Y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Y == <span class="number">0</span>) <span class="keyword">return</span> X;</span><br><span class="line">    <span class="keyword">return</span> Gcd (Y, X % Y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen (<span class="string">"division.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen (<span class="string">"division.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%lld %lld"</span>, &amp;N, &amp;M);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">"%lld"</span>, &amp;Temp);</span><br><span class="line">        <span class="keyword">if</span> (Temp == <span class="number">1</span>) GRD = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (Temp &lt;= N &amp;&amp; Gcd(N, Temp) != <span class="number">1</span>) K.push(Temp);</span><br><span class="line">    &#125;</span><br><span class="line">    Dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!K.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        ll Now = K.top();</span><br><span class="line">        K.pop();</span><br><span class="line">        <span class="built_in">map</span> &lt;ll, ll&gt; :: iterator P = Dp.begin();</span><br><span class="line">        <span class="keyword">while</span> (P != Dp.end())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> NewK = (P -&gt; first) * Now;</span><br><span class="line">            <span class="keyword">if</span> ((Gcd(N, NewK) == <span class="number">1</span>) || (NewK &gt; N) || (Gcd(Now, P -&gt; first) != <span class="number">1</span>)) </span><br><span class="line">            &#123;</span><br><span class="line">                ++P;</span><br><span class="line">                 <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Dp[NewK] += P -&gt; second;</span><br><span class="line">            ++P;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (GRD) Dp[N] *= <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"%lld\n"</span>, Dp[N]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为什么这份代码当时没有AC呢，非常的简单：</p>
<p>首先：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (Temp &lt;= N &amp;&amp; Gcd(N, Temp) != <span class="number">1</span>) K.push(Temp);</span><br></pre></td></tr></table></figure>
<p>这个就错了， $gcd(N,Temp)\;!= \;\&amp;\&amp; \; gcd(N, Temp) == Temp$才能保证Temp是N的约数</p>
<p>然后还有个$ZZ$错误：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> NewK = (P -&gt; first) * Now;</span><br></pre></td></tr></table></figure>
<p>$int$显然是爆掉了的</p>
<p>改了以后竟然就有90分了</p>
<p>$TLE$了$2$个点，其实这两个点就是在输入的时候，判断这个数是否取尽了$N$的质因数的指数</p>
<p>可能这样写着不太明白？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="built_in">map</span> &lt;ll, ll&gt; Dp;</span><br><span class="line">priority_queue &lt;ll&gt; K;</span><br><span class="line">ll N, M, Temp;</span><br><span class="line"><span class="keyword">bool</span> GRD;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Gcd</span><span class="params">(ll X, ll Y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Y == <span class="number">0</span>) <span class="keyword">return</span> X;</span><br><span class="line"><span class="keyword">return</span> Gcd (Y, X % Y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Check</span><span class="params">(ll X)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (X == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">ll Temp = N, B = N;</span><br><span class="line"><span class="keyword">for</span> (ll i = <span class="number">2</span>; i * i &lt;= B; ++i)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (X % i) <span class="keyword">continue</span>;</span><br><span class="line">  <span class="keyword">while</span> (X % i == <span class="number">0</span> &amp;&amp; Temp % i == <span class="number">0</span>) X /= i, Temp /= i;</span><br><span class="line">  <span class="keyword">if</span> ((Temp % i == <span class="number">0</span>) || (X % i == <span class="number">0</span>)) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//只要有一个素数的指数不相等就是不可行的方案</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (X &gt; <span class="number">1</span>) <span class="keyword">return</span> (Temp &gt;= X) &amp;&amp; (Temp % X == <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> (Temp &gt;= X);</span><br><span class="line">&#125;<span class="comment">//就是加了一个这个，Temp必须取完N中Temp有的所有素数，然后95了</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">freopen (<span class="string">"division.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">freopen (<span class="string">"division.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">"%lld %lld"</span>, &amp;N, &amp;M);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; ++i) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">scanf</span> (<span class="string">"%lld"</span>, &amp;Temp);</span><br><span class="line">  <span class="keyword">if</span> (Temp == <span class="number">1</span>) GRD = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (Check(Temp)) K.push(Temp);</span><br><span class="line">&#125;</span><br><span class="line">Dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (!K.empty())</span><br><span class="line">&#123;</span><br><span class="line">  ll Now = K.top();</span><br><span class="line">  K.pop();</span><br><span class="line">  <span class="built_in">map</span> &lt;ll, ll&gt; :: iterator P = Dp.begin();</span><br><span class="line">  <span class="keyword">while</span> (P != Dp.end())</span><br><span class="line">  &#123;</span><br><span class="line">      ll NewK = (P -&gt; first) * Now;</span><br><span class="line">      <span class="keyword">if</span> ((NewK &gt; N) || (Gcd(Now, P -&gt; first) != <span class="number">1</span>)) </span><br><span class="line">      &#123;</span><br><span class="line">          ++P;</span><br><span class="line">           <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      Dp[NewK] += P -&gt; second;</span><br><span class="line">      ++P;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (GRD) Dp[N] *= <span class="number">2</span>;</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"%lld\n"</span>, Dp[N]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><del>其实个人认为这个算法理论上是可以过的，但是只有95，猜测是Map遍历太慢了</del></p>
<p>其实就是我太菜了</p>
</blockquote>
<h2 id="3-观光旅行-trip-cpp-c-pas"><a href="#3-观光旅行-trip-cpp-c-pas" class="headerlink" title="3.观光旅行 (trip.cpp/c/pas)"></a>3.观光旅行 (trip.cpp/c/pas)</h2><p><strong>【问题描述】</strong></p>
<p> BG 来到了一个美丽的风景区旅行，这个景区共有𝑛个景点，编号从1到𝑛。这𝑛个景点之 间共有𝑚条双向的观光道路，每条观光道路都有一个魅力值，第𝑖条观光道路的魅力值为𝑤𝑖。</p>
<p> 现在 BG 想从任意一个景点出发，沿着一条路径旅行其它景点。为了避免旅途的枯燥， BG 每次经过的道路的魅力值都要严格大于之前经过的任何道路。同时，他想让旅途尽可能 长。 </p>
<p>请问在满足他的要求的情况下，路径的最长长度是多少，并求出不同的最长路径共有多 少条。路径的长度即它经过的道路数。两条路径被认为不同，当且仅当它们经过的景点序列 不同。为了防止输出的数字过大，你只需输出路径数对$1,000,000,007$取模的结果。 </p>
<p><strong>【输入】</strong></p>
<p> 输入文件名为 trip.in。 </p>
<p>输入文件的第一行有两个用一个空格隔开的整数𝑛、𝑚，表示该景区有𝑛个景点和𝑚条观 光道路。 </p>
<p>接下来𝑚行每行三个整数𝑢𝑖 , 𝑣𝑖 , 𝑤𝑖，每两个整数之间用一个空格隔开，表示第𝑖条道路的 魅力值为𝑤𝑖，在景点𝑢𝑖和𝑣𝑖之间。 输入数据保证𝑢𝑖 ≠ 𝑣𝑖，两个景点之间最多只有一条观光道路，第一问的答案至少为 2。</p>
<p><strong>【输出】</strong></p>
<p> 输出文件名为 trip.out。 </p>
<p>输出的第一行一个整数，表示最长的路径长度。 输出的第二行一个整数，表示不同的最长路径数对$1,000,000,007$取模的结果。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>输入</th>
<th>输出</th>
</tr>
</thead>
<tbody>
<tr>
<td>5 5 <br />1 2 4 <br />1 3 5 <br />2 4 3 <br />2 3 1 <br />2 5 2</td>
<td>3<br />3</td>
</tr>
</tbody>
</table>
</div>
<p><strong>【输入输出样例说明】</strong></p>
<p> 共有 3 条长度为 3 的合法路径： </p>
<p>3—2—1—3，经过道路的魅力值为 1、4、5；</p>
<p>4—2—1—3，经过道路的魅力值为 3、4、5； </p>
<p>5—2—1—3，经过道路的魅力值为 2、4、5。 </p>
<p><strong>【数据说明】</strong> </p>
<p>对于 10%的数据，1 ≤ 𝑛 ≤ 10，1 ≤ 𝑚 ≤ 20； </p>
<p>对于 30%的数据，1 ≤ 𝑛 ≤ 100，1 ≤ 𝑚 ≤ 500； </p>
<p>对于 60%的数据，1 ≤ 𝑛 ≤ 1,000，1 ≤ 𝑚 ≤ 3,000；</p>
<p>对于 80%的数据，1 ≤ 𝑛 ≤ 2,000，1 ≤ 𝑚 ≤ 100,000； </p>
<p>对于 100%的数据，1 ≤ 𝑛 ≤ 50,000，1 ≤ 𝑚 ≤ 200,000，0 ≤ 𝑤𝑖 ≤ 109。</p>
<blockquote>
<p>所以对于这道题，考试的时候我爆零了，that is 我太菜了！！！</p>
<p>怎么处理路径上的边权单调上升呢？</p>
<p>考虑：</p>
<blockquote>
<p>从小的边到大的边再建一条新的边，易证得到的新图是一个DAG</p>
<p>怎么建图？</p>
<p>首先有出边$j$的虚点$j’$向$j$ 建一条边权为$1$的边那么只要经过了这个点，就会对路径长度产生贡献</p>
<p>从入边向边权比它大的边的虚边建一条边权为$0$的点</p>
<p>然后再拓扑一便就统计答案即可</p>
</blockquote>
</blockquote>
<h2 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Pr pair<span class="meta-string">&lt;int, int&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = (<span class="number">2e5</span> + <span class="number">5</span>) * <span class="number">4</span>, Mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n, N, M, Cur, X, Y, Z;</span><br><span class="line"><span class="keyword">int</span> F[Maxn], G[Maxn], In[Maxn], Q[Maxn];</span><br><span class="line"><span class="keyword">int</span> Head[Maxn], E[Maxn &lt;&lt; <span class="number">1</span>], W[Maxn &lt;&lt; <span class="number">1</span>], Next[Maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="built_in">vector</span> &lt; Pr &gt; V[Maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> U, <span class="keyword">int</span> V, <span class="keyword">int</span> A)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Next[++Cur] = Head[U];</span><br><span class="line">	Head[U] = Cur;</span><br><span class="line">	E[Cur] = V;</span><br><span class="line">	W[Cur] = A;</span><br><span class="line">	In[V]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">UpDate</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;c, <span class="keyword">int</span> &amp;d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (a &gt; c) c = a, d = b;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (a == c) d = (d + b) % Mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n = （M + <span class="number">1</span>) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i(<span class="number">1</span>), t(<span class="number">0</span>); i &lt;= N; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		sort (V[i].begin(), V[i].end());</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j(<span class="number">0</span>), k(<span class="number">0</span>); j &lt; V[i].size(); ++j)</span><br><span class="line">		&#123;	</span><br><span class="line">			AddEdge(n + j, V[i][j].second, <span class="number">1</span>);<span class="comment">//从j'到j建一条1的边</span></span><br><span class="line">			<span class="keyword">while</span> (k &lt; V[i].size() &amp;&amp; V[i][j].first == V[i][k].first) ++k;<span class="comment">//保证严格单调</span></span><br><span class="line">			<span class="keyword">if</span> (k &lt; V[i].size()) AddEdge(V[i][j].second ^ <span class="number">1</span>, n + k, <span class="number">0</span>);<span class="comment">//从另一条边进来，从这条边（k）出去</span></span><br><span class="line">			<span class="keyword">if</span> (j) AddEdge(n + j - <span class="number">1</span>, n + j, <span class="number">0</span>);<span class="comment">//因为都是同一个点的边，所以可以0贡献换边</span></span><br><span class="line">		&#125;</span><br><span class="line">		n += V[i].size();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	freopen (<span class="string">"trip.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">	freopen (<span class="string">"trip.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">	<span class="built_in">scanf</span> (<span class="string">"%d %d"</span>, &amp;N, &amp;M);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span> (<span class="string">"%d %d %d"</span>, &amp;X, &amp;Y, &amp;Z);</span><br><span class="line">		V[X].push_back(Pr(Z, i &lt;&lt; <span class="number">1</span>));</span><br><span class="line">		V[Y].push_back(Pr(Z, i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	Build();</span><br><span class="line">	int L(1), R(0);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) </span><br><span class="line">		<span class="keyword">if</span> (!In[i]) F[i] = <span class="number">0</span>, G[i] = <span class="number">1</span>, Q[++R] = i;</span><br><span class="line">	<span class="keyword">for</span> (; L &lt;= R; ++L)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> u = Q[L], i = Head[u], v; v = E[i], i; i = Next[i])</span><br><span class="line">		&#123;</span><br><span class="line">			UpDate(F[u] + W[i], G[u], F[v], G[v]);</span><br><span class="line">			<span class="keyword">if</span> (!--In[v]) Q[++R] = v;</span><br><span class="line">		&#125;</span><br><span class="line">	int X(0), Y(0);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) UpDate(F[i], G[i], X, Y);</span><br><span class="line">	<span class="built_in">printf</span> (<span class="string">"%d\n%d\n"</span>, X, Y);</span><br><span class="line">&#125;<span class="comment">//切掉惹</span></span><br></pre></td></tr></table></figure>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>细节处理还是有问题，比如说$T1，T2$ 没有开$long\;long$少了整整$60$</p>
<p>然后加上对$T2$的优化又多$5$分， 也就是说理论应该是$200$分， 实际得分$125$</p>
<p>还要加油呀😆</p>
]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>考试</tag>
        <tag>状压</tag>
      </tags>
  </entry>
  <entry>
    <title>T20200824</title>
    <url>/2020/08/24/T20200824/</url>
    <content><![CDATA[

	<div class="row">
    <embed src="problem.pdf" width="100%" height="550" type="application/pdf">
	</div>



<h1 id="T1-基因合成"><a href="#T1-基因合成" class="headerlink" title="T1 基因合成"></a>T1 基因合成</h1><p>神奇的题面描述，这个不管</p>
<p>简言之，求通过给定操作，求到目标状态的最少操作次数</p>
<p>操作如下：</p>
<ul>
<li>在串的头部或尾部插入一个字符</li>
<li>将串复制一次，逆序接在原串的后面</li>
</ul>
<h2 id="60-分做法"><a href="#60-分做法" class="headerlink" title="$60$分做法"></a>$60$分做法</h2><p>先说说$Dp$，状态设计:</p>
<script type="math/tex; mode=display">
f(i,j)=min
\begin{cases}
f(i+1, j)+1
\\f(i,j-1)+1
\\f(i,mid)+1\quad\text{i到j长度为偶数，且这是回文串}
\end{cases}</script><p>$60$就到手了</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">205</span>;</span><br><span class="line"><span class="keyword">int</span> T, Dp[Maxn][Maxn];</span><br><span class="line"><span class="keyword">char</span> S[Maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span> (<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">	<span class="keyword">while</span> (T--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span> (<span class="string">"%s"</span>, S);</span><br><span class="line">		<span class="keyword">int</span> len = <span class="built_in">strlen</span>(S);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) Dp[i][i] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l &lt; len; ++l)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = i + l; j &lt; len; ++i, ++j)</span><br><span class="line">			&#123;</span><br><span class="line">				Dp[i][j] = min(Dp[i + <span class="number">1</span>][j], Dp[i][j - <span class="number">1</span>]);</span><br><span class="line">				<span class="keyword">if</span> (l &amp; <span class="number">1</span> == <span class="number">1</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="function"><span class="keyword">bool</span> <span class="title">k</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">					<span class="keyword">int</span> le = i, re = j;</span><br><span class="line">					<span class="keyword">for</span> (; le &lt; re; ++le, --re)</span><br><span class="line">						<span class="keyword">if</span> (S[le] != S[re]) k = <span class="number">0</span>;</span><br><span class="line">					<span class="keyword">if</span> (k) Dp[i][j] = min(Dp[i][j], min(Dp[i][le - <span class="number">1</span>], Dp[re + <span class="number">1</span>][j]));</span><br><span class="line">                    <span class="comment">//这里的话，le、re都跑过了，要往回走一步</span></span><br><span class="line">				&#125;</span><br><span class="line">				Dp[i][j]++;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="built_in">printf</span> (<span class="string">"%d\n"</span>, Dp[<span class="number">0</span>][len - <span class="number">1</span>]);	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="100-分做法"><a href="#100-分做法" class="headerlink" title="$100$分做法"></a>$100$分做法</h2><p>再看看这道题，我们发现有一个性质：</p>
<ul>
<li>某个复制操作可能是被另一个复制操作所包含的，但是两个复制操作是不可能并列的</li>
</ul>
<p>那么我们就可以找到每个长度为偶数的回文串，用$f(i)$表示在回文数下节点编号为$i$的回文串的最小生成步数，$len(i)$表示回文串长度</p>
<p>那么答案就可以这样更新$ans=min(ans,n-len(i)+f(i))$，因为回文串以外的字符只能选择插入了</p>
<p>考虑如何更新$f(i)$：</p>
<script type="math/tex; mode=display">
f(i)=\min\{f(j)+1,len(i)/2-len(tran(i))+1\}</script><p>其中$tran(i)$表示回文串$i$的某个能够通过最少次操作得到$i$的子串</p>
<p>这道题就差不多结束了</p>
<h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> S[Maxn];</span><br><span class="line"><span class="keyword">int</span> T, N, P, Q, Tot, Ans, Last, F[Maxn];</span><br><span class="line"><span class="keyword">int</span> Len[Maxn], Fail[Maxn], Tras[Maxn], Ch[Maxn][<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Fail[<span class="number">0</span>] = F[<span class="number">0</span>] = Tot = <span class="number">1</span>, S[<span class="number">0</span>] = Len[<span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">	Last = Len[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">memset</span>(Ch, <span class="number">0</span>, <span class="keyword">sizeof</span> Ch);</span><br><span class="line">	<span class="built_in">scanf</span> (<span class="string">"%s"</span>, S + <span class="number">1</span>);</span><br><span class="line">	N = Ans = <span class="built_in">strlen</span>(S + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Newnode</span><span class="params">(<span class="keyword">int</span> X)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Len[++Tot] = X;</span><br><span class="line">	<span class="keyword">return</span> Tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">GetFail</span><span class="params">(<span class="keyword">int</span> X, <span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (S[N - Len[X] - <span class="number">1</span>] != S[N]) X = Fail[X];</span><br><span class="line">	<span class="keyword">return</span> X;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">HASH</span><span class="params">(<span class="keyword">char</span> O)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (O == <span class="string">'A'</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (O == <span class="string">'G'</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (O == <span class="string">'C'</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Init ();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> X = HASH(S[i]);</span><br><span class="line">		P = GetFail (Last, i);</span><br><span class="line">		<span class="keyword">if</span> (!Ch[P][X])</span><br><span class="line">		&#123;</span><br><span class="line">			Q = Newnode(Len[P] + <span class="number">2</span>);</span><br><span class="line">			Fail[Q] = Ch[GetFail(Fail[P], i)][X];</span><br><span class="line">			Ch[P][X] = Q;</span><br><span class="line">			<span class="keyword">if</span> (Len[Q] &lt;= <span class="number">2</span>) Tras[Q] = Fail[Q];</span><br><span class="line">			<span class="keyword">else</span> </span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> Temp = Tras[P];</span><br><span class="line">				<span class="keyword">while</span> (S[i - Len[Temp] - <span class="number">1</span>] != S[i] || (Len[Temp] + <span class="number">2</span>) * <span class="number">2</span> &gt; Len[Q]) Temp = Fail[Temp];</span><br><span class="line">                Tras[Q] = Ch[Temp][X];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		Last = Ch[P][X];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">BFS</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">	Q.push (<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">while</span> (!Q.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> x = Q.front();</span><br><span class="line">		Q.pop();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">			<span class="keyword">if</span> (Ch[x][i])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> t = Ch[x][i];</span><br><span class="line">				F[t] = F[x] + <span class="number">1</span>;</span><br><span class="line">				F[t] = min(F[t], Len[t] / <span class="number">2</span> - Len[Tras[t]] + F[Tras[t]] + <span class="number">1</span>);</span><br><span class="line">				Ans = min(Ans, N - Len[t] + F[t]);</span><br><span class="line">				Q.push(t);</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span> (<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">	<span class="keyword">while</span> (T--)</span><br><span class="line">	&#123;</span><br><span class="line">		Build ();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= Tot; ++i)</span><br><span class="line">			<span class="keyword">if</span> (Len[i] &amp; <span class="number">1</span>) F[i] = Len[i];</span><br><span class="line">		BFS();</span><br><span class="line">		<span class="built_in">printf</span> (<span class="string">"%d\n"</span>, Ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T2-染色"><a href="#T2-染色" class="headerlink" title="T2 染色"></a>T2 染色</h1><p>给定一棵树，初始状态所有的点全为白点</p>
<p>有如下两种操作：</p>
<ul>
<li>$opt=1$，将$x$染为黑色</li>
<li>$opt=2$，求所有黑点到$x$的简单路径长</li>
</ul>
<h2 id="30-分做法"><a href="#30-分做法" class="headerlink" title="$30$分做法"></a>$30$分做法</h2><p>直接暴力跑，这个树是随机的，嗯就完了吧</p>
<h2 id="100-分做法-1"><a href="#100-分做法-1" class="headerlink" title="$100$分做法"></a>$100$分做法</h2><p>考虑根为$1$的树上，一对简单路径长度:</p>
<script type="math/tex; mode=display">
len = dis(u,1)+dis(v,1)-2\times dis(lca(u,v),1)</script><p>这个显然是正确的，那么所有黑点到$x$的距离为：</p>
<script type="math/tex; mode=display">
\begin{align*}
Ans&=\sum_{i=1}^{cnt}(dis(u_i)+dis(x)-2\times dis(lca(u_i,x)))
\\&=\sum_{i=1}^{cnt}dis(u_i)+cnt\times dis(x)-2\sum_{i=1}^{cnt}dis(lca(u_i,x))
\end{align*}</script><p>那么这个问题就变得相对简单了，$dis(x)$直接预处理，$\sum_{i=1}dis(u_i)$可以直接暴力加上去</p>
<p>那么问题就变成了求$\sum_{i=1}dis(lca(u_i,x))$，这个我们可以发现，$lca(u,x)$一定在$u$到根和$x$到根的路径上</p>
<p>就是说我们要求$dis(lca(u,x))$的话，可以直接求$Dis(x)$</p>
<p>即，每次插入一个黑点，将这个点到根的路径上的所有的边权的加入贡献，再求$x$到根经过的边的贡献之和</p>
<h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> N, M, U, V, Cost, Opt, Q;</span><br><span class="line"><span class="keyword">int</span> Head[Maxn], Next[Maxn &lt;&lt; <span class="number">1</span>], E[Maxn &lt;&lt; <span class="number">1</span>], Cur, W[Maxn &lt;&lt; <span class="number">1</span>], Arr[Maxn], Cnt;</span><br><span class="line"><span class="keyword">int</span> Son[Maxn], Dep[Maxn], Size[Maxn], F[Maxn], Top[Maxn], SE[Maxn], ID[Maxn];<span class="comment">//树剖</span></span><br><span class="line">ll Sum[Maxn &lt;&lt; <span class="number">2</span>], Ans[Maxn &lt;&lt; <span class="number">2</span>], Tag[Maxn &lt;&lt; <span class="number">2</span>], Len[Maxn], A;<span class="comment">//线段树</span></span><br><span class="line"><span class="keyword">int</span> Temp[Maxn];</span><br><span class="line"><span class="keyword">bool</span> Vis[Maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> X, <span class="keyword">int</span> Fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	F[X] = Fa, Dep[X] = Dep[Fa] + <span class="number">1</span>, Size[X] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = Head[X]; i; i = Next[i])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (E[i] == Fa)<span class="keyword">continue</span>;</span><br><span class="line">		Size[X] += DFS(E[i], X);</span><br><span class="line">		<span class="keyword">if</span> (Size[E[i]] &gt; Size[Son[X]]) Son[X] = E[i], SE[X] = W[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Size[X];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> X, <span class="keyword">int</span> Tp, <span class="keyword">int</span> Edge)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Top[X] = Tp, ID[X] = ++Cnt, Arr[Cnt] = Edge, Len[X] = Len[F[X]] + Edge;</span><br><span class="line">	<span class="keyword">if</span> (Son[X]) DFS(Son[X], Tp, SE[X]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = Head[X]; i; i = Next[i])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (E[i] == F[X] || E[i] == Son[X]) <span class="keyword">continue</span>;</span><br><span class="line">		DFS(E[i], E[i], W[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">PushUp</span><span class="params">(<span class="keyword">int</span> X)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Sum[X] = Sum[X &lt;&lt; <span class="number">1</span>] + Sum[X &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">	Ans[X] = Ans[X &lt;&lt; <span class="number">1</span>] + Ans[X &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Build</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> X = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (L == R) </span><br><span class="line">	&#123;</span><br><span class="line">		Sum[X] = Arr[L];</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> Mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	Build (L, Mid, X &lt;&lt; <span class="number">1</span>);</span><br><span class="line">	Build (Mid + <span class="number">1</span>, R, X &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">	PushUp(X);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Down</span><span class="params">(<span class="keyword">int</span> X, ll Val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Tag[X] += Val;</span><br><span class="line">	Ans[X] += Val * Sum[X];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">PushDown</span><span class="params">(<span class="keyword">int</span> X)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!Tag[X]) <span class="keyword">return</span> ;</span><br><span class="line">	Down (X &lt;&lt; <span class="number">1</span>, Tag[X]);</span><br><span class="line">	Down (X &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, Tag[X]);</span><br><span class="line">	Tag[X] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UpDate</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> Tl, <span class="keyword">int</span> Tr, <span class="keyword">int</span> Val, <span class="keyword">int</span> X = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (L &gt;= Tl &amp;&amp; R &lt;= Tr)</span><br><span class="line">	&#123;</span><br><span class="line">		Down(X, Val);</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	PushDown(X);</span><br><span class="line">	<span class="keyword">int</span> Mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (Tl &lt;= Mid) UpDate (L, Mid, Tl, Tr, Val, X &lt;&lt; <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (Tr &gt; Mid) UpDate (Mid + <span class="number">1</span>, R, Tl, Tr, Val, X &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">	PushUp(X);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Query</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> Tl, <span class="keyword">int</span> Tr, <span class="keyword">int</span> X = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (L &gt;= Tl &amp;&amp; R &lt;= Tr) <span class="keyword">return</span> Ans[X];</span><br><span class="line">	PushDown(X);</span><br><span class="line">	<span class="keyword">int</span> Mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="function">ll <span class="title">Ans</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="keyword">if</span> (Tl &lt;= Mid) Ans += Query (L, Mid, Tl, Tr, X &lt;&lt; <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (Tr &gt; Mid) Ans += Query (Mid + <span class="number">1</span>, R, Tl, Tr, X &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> Ans; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">UpDate</span><span class="params">(<span class="keyword">int</span> U)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (Top[U] != <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		UpDate (<span class="number">1</span>, N, ID[Top[U]], ID[U], <span class="number">1</span>);</span><br><span class="line">		U = F[Top[U]];</span><br><span class="line">	&#125;</span><br><span class="line">	UpDate (<span class="number">1</span>, N, ID[<span class="number">1</span>], ID[U], <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Query</span><span class="params">(<span class="keyword">int</span> U)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">ll <span class="title">Ans</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (Top[U] != <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Ans += Query (<span class="number">1</span>, N, ID[Top[U]], ID[U]);</span><br><span class="line">		U = F[Top[U]];</span><br><span class="line">	&#125;</span><br><span class="line">	Ans += Query (<span class="number">1</span>, N, ID[<span class="number">1</span>], ID[U]);</span><br><span class="line">	<span class="keyword">return</span> Ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	int X(0), O(getchar());</span><br><span class="line">	<span class="keyword">while</span> (O &lt; <span class="string">'0'</span> || O &gt; <span class="string">'9'</span>) O = getchar();</span><br><span class="line">	<span class="keyword">for</span> (; O &gt;= <span class="string">'0'</span> &amp;&amp; O &lt;= <span class="string">'9'</span>; O = getchar()) X = (X &lt;&lt; <span class="number">1</span>) + (X &lt;&lt; <span class="number">3</span>) + (O ^ <span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> X;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> U, <span class="keyword">int</span> V, <span class="keyword">int</span> Cost)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Next[++Cur] = Head[U];</span><br><span class="line">	Head[U] = Cur;</span><br><span class="line">	E[Cur] = V;</span><br><span class="line">	W[Cur] = Cost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	freopen (<span class="string">"color.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">	freopen (<span class="string">"color.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">	N = Read(), M = Read();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; ++i) Temp[i] = Read() + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; ++i) AddEdge(Temp[i], i, Read());</span><br><span class="line">	DFS(<span class="number">1</span>, <span class="number">0</span>), DFS(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	Build(<span class="number">1</span>, N);</span><br><span class="line">	<span class="keyword">while</span> (M--)</span><br><span class="line">	&#123;</span><br><span class="line">		Opt = Read(), U = Read() + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (Opt == <span class="number">1</span> &amp;&amp; !Vis[U]) UpDate(U), A += Len[U], Q++, Vis[U] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//这里要注意一下，因为一个点只能被染色一次，所以如果已经是黑色了就不能在操作了</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (Opt == <span class="number">2</span>) <span class="built_in">printf</span> (<span class="string">"%lld\n"</span>, A + Q * Len[U] - <span class="number">2</span> * Query(U));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T3-圈地游戏"><a href="#T3-圈地游戏" class="headerlink" title="T3 圈地游戏"></a>T3 圈地游戏</h1><p>这，我就懒得描述了</p>
<p>考场上没有思路，怎么设计状态？如何进行转移？</p>
<p>啥都没想到，都不会。。。</p>
<p><strong>BUT</strong></p>
<p><del>赛后诸葛</del>。。。</p>
<p>我这里没有部分分做法</p>
<h2 id="100-分做法-2"><a href="#100-分做法-2" class="headerlink" title="$100$分做法"></a>$100$分做法</h2><p>状态设计$f(x,y,state_t, state_b)$，表示当前位置为$(x,y)$，在路径内部的宝箱状态为$state_t$，路径障碍状态为$state_b$</p>
<p>规定射线垂直$y$轴，没有斜率方便表示</p>
<p>那么判定依据如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((New.X == Tx[i] - <span class="number">1</span> &amp;&amp; Now.X == Tx[i]) || (New.X == Tx[i] &amp;&amp; Now.X == Tx[i] - <span class="number">1</span>)) </span><br><span class="line">    New.St ^= (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<p>就是没经过这条射线一次，就对这个宝箱/障碍进行一次亦或操作，因为异或操作有一个性质，相信大家都明白，就不细说的</p>
<p>这个就很好的满足了经过奇数条边，那么就在图形内，偶数条边就在图形外的条件</p>
<p>那么最难的部分就结束了</p>
<h2 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Mx[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> My[] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> N, M, Sx, Sy;<span class="comment">//起点坐标</span></span><br><span class="line"><span class="keyword">int</span> Tx[<span class="number">10</span>], Ty[<span class="number">10</span>], TVal[<span class="number">10</span>], Tcnt;<span class="comment">//宝藏坐标、价值、计数</span></span><br><span class="line"><span class="keyword">int</span> Bx[<span class="number">10</span>], By[<span class="number">10</span>], Bcnt;<span class="comment">//陷阱坐标、计数</span></span><br><span class="line"><span class="keyword">int</span> F[<span class="number">21</span>][<span class="number">21</span>][<span class="number">256</span>][<span class="number">256</span>], Sum[<span class="number">256</span>], Ans;</span><br><span class="line"><span class="keyword">char</span> Map[<span class="number">25</span>][<span class="number">25</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> X, Y, St, Sb;</span><br><span class="line">    Node () &#123;&#125;</span><br><span class="line">    Node (<span class="keyword">int</span> X, <span class="keyword">int</span> Y, <span class="keyword">int</span> St, <span class="keyword">int</span>  Sb) : X(X), Y(Y), St(St), Sb(Sb) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">BFS</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span> &lt;Node&gt; Q;</span><br><span class="line">    F[Sx][Sy][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    Q.push(Node(Sx, Sy, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">while</span> (!Q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        Node Now = Q.front();</span><br><span class="line">        Q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> S = <span class="number">0</span>; S &lt; <span class="number">4</span>; ++S)</span><br><span class="line">        &#123;</span><br><span class="line">            Node New = Now;</span><br><span class="line">            New.X += Mx[S];</span><br><span class="line">            New.Y += My[S];<span class="comment">//在图上随机游走</span></span><br><span class="line">            <span class="keyword">if</span> (Map[New.X][New.Y] != <span class="string">'.'</span> &amp;&amp; Map[New.X][New.Y] != <span class="string">'S'</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Tcnt; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (New.Y &gt;= Ty[i]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> ((New.X == Tx[i] - <span class="number">1</span> &amp;&amp; Now.X == Tx[i]) || (New.X == Tx[i] &amp;&amp; Now.X == Tx[i] - <span class="number">1</span>))</span><br><span class="line">                    New.St ^= (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>));<span class="comment">//记录宝箱状态</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Bcnt; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (New.Y &gt;= By[i]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> ((New.X == Bx[i] - <span class="number">1</span> &amp;&amp; Now.X == Bx[i]) || (New.X == Bx[i] &amp;&amp; Now.X == Bx[i] - <span class="number">1</span>)) </span><br><span class="line">                    New.Sb ^= (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>));<span class="comment">//记录陷阱状态</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (F[New.X][New.Y][New.St][New.Sb] &lt;= F[Now.X][Now.Y][Now.St][Now.Sb] + <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            F[New.X][New.Y][New.St][New.Sb] = F[Now.X][Now.Y][Now.St][Now.Sb] + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//更新答案，我们要求的是周长最小</span></span><br><span class="line">            Q.push (New);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; Tcnt); ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= Tcnt; ++j)</span><br><span class="line">            <span class="keyword">if</span> (i &amp; (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))) Sum[i] += TVal[j];<span class="comment">//统计每种情况下宝箱权值之和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; Tcnt); ++i)</span><br><span class="line">        Ans = max(Ans, Sum[i] - F[Sx][Sy][i][<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"%d\n"</span>, Ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%d %d"</span>, &amp;N, &amp;M);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">"%s"</span>, Map[i] + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= M; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (Map[i][j] == <span class="string">'S'</span>) Sx = i, Sy = j;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (Map[i][j] &gt;= <span class="string">'0'</span> &amp;&amp; Map[i][j] &lt;= <span class="string">'9'</span>) </span><br><span class="line">                Tx[Map[i][j] - <span class="string">'0'</span>] = i, Ty[Map[i][j] - <span class="string">'0'</span>] = j, Tcnt++;<span class="comment">//记录宝箱的位置</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (Map[i][j] == <span class="string">'B'</span>) </span><br><span class="line">                Bx[++Bcnt] = i, By[Bcnt] = j;<span class="comment">//记录陷阱的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Tcnt; ++i) <span class="built_in">scanf</span> (<span class="string">"%d"</span>, TVal + i);</span><br><span class="line">    <span class="built_in">memset</span> (F, <span class="number">0x5f</span>, <span class="keyword">sizeof</span> F);</span><br><span class="line">    BFS();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这确实是非常好的一道状压$\text{Dp}$</p>
<p>这道题大家就栽在不知到如何用二进制表示宝箱、陷阱的状态</p>
<p>虽然题目对于路径内外有十分详细的描述，但是没有做过的话，还是不容易想到这种表示方法</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>Dp优化</tag>
        <tag>考试</tag>
        <tag>状压</tag>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title>T20200825</title>
    <url>/2020/08/25/T20200825/</url>
    <content><![CDATA[

	<div class="row">
    <embed src="problem.pdf" width="100%" height="550" type="application/pdf">
	</div>



<h1 id="T1-运动-move"><a href="#T1-运动-move" class="headerlink" title="T1 运动(move)"></a>T1 运动(move)</h1><p>给你两个字符串，其中第二个字符串为环状字符串，问将第二个字符串转几次（初始状态就是$0$次）可以使$A, B$串有最大匹配</p>
<h2 id="30分做法"><a href="#30分做法" class="headerlink" title="30分做法"></a>30分做法</h2><p>暴力。。。</p>
<h2 id="100分做法"><a href="#100分做法" class="headerlink" title="100分做法"></a>100分做法</h2><p>$KMP$求$A$串在$B$串中的最大匹配，就是个$O(n)$的了</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">2e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> A[Maxn], B[Maxn];</span><br><span class="line"><span class="keyword">int</span> N, Fail[Maxn], Len, Pos;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span> (<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">	<span class="built_in">scanf</span> (<span class="string">"%s %s"</span>, A + <span class="number">1</span>, B + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> j = Fail[i - <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">while</span> (j &amp;&amp; A[j + <span class="number">1</span>] != A[i]) j = Fail[j];</span><br><span class="line">		<span class="keyword">if</span> (A[j + <span class="number">1</span>] == A[i]) Fail[i] = j + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	copy (B + <span class="number">1</span>, B + N + <span class="number">1</span>, B + N + <span class="number">1</span>);</span><br><span class="line">	N &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i(<span class="number">1</span>), j(<span class="number">0</span>); i &lt;= N; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (j &amp;&amp; A[j + <span class="number">1</span>] != B[i]) j = Fail[j];</span><br><span class="line">		<span class="keyword">if</span> (A[j + <span class="number">1</span>] == B[i]) ++j;</span><br><span class="line">        <span class="comment">//j表示当前匹配长度</span></span><br><span class="line">		<span class="keyword">if</span> (j &gt; Len) Pos = i - j + <span class="number">1</span>, Len = j;<span class="comment">//Pos就是当前匹配的起点</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span> (<span class="string">"%d\n"</span>, Pos - <span class="number">1</span>);<span class="comment">//就完了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T2-烹饪-cook"><a href="#T2-烹饪-cook" class="headerlink" title="T2 烹饪(cook)"></a>T2 烹饪(cook)</h1><p>给你一串数字$1\sim n$, 然后有$m$个条件形如$a, b$表示$a$在$b$前出现</p>
<p>求问满足这$m$个条件且小的数字尽量靠前</p>
<p><del>暴力挂了，直接上100分做法</del></p>
<h2 id="100分做法-1"><a href="#100分做法-1" class="headerlink" title="100分做法"></a>100分做法</h2><p>倒叙、反向建边的拓扑</p>
<p>我们然大的数尽可能靠后，这是为啥呢</p>
<p>自己造几组数据，你就会发现这貌似是正确的？</p>
<h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> T, N, M, Cur, Tot, X, Y;</span><br><span class="line"><span class="keyword">int</span> D[Maxn], Ans[Maxn];</span><br><span class="line"><span class="keyword">int</span> Head[Maxn], E[Maxn], Next[Maxn];</span><br><span class="line">priority_queue &lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">X</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">char</span> <span class="title">O</span><span class="params">(getchar())</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (O &lt; <span class="string">'0'</span> || O &gt; <span class="string">'9'</span>) O = getchar();</span><br><span class="line">	<span class="keyword">for</span> (; O &gt;= <span class="string">'0'</span> &amp;&amp; O &lt;= <span class="string">'9'</span>; O = getchar()) X =(X &lt;&lt; <span class="number">1</span>) + (X &lt;&lt; <span class="number">3</span>) + (O ^ <span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> X;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEge</span><span class="params">(<span class="keyword">int</span> U, <span class="keyword">int</span> V)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Next[++Cur] = Head[U];</span><br><span class="line">	Head[U] = Cur;</span><br><span class="line">	E[Cur] = V;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span> (<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">	<span class="keyword">while</span> (T--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span> (<span class="string">"%d %d"</span>, &amp;N, &amp;M);</span><br><span class="line">		Cur = Tot = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">memset</span> (Head, <span class="number">0</span>, <span class="keyword">sizeof</span>(Head));</span><br><span class="line">		<span class="built_in">memset</span> (D, <span class="number">0</span>, <span class="keyword">sizeof</span>(D));</span><br><span class="line">		<span class="keyword">while</span> (M--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span> (<span class="string">"%d %d"</span>, &amp;X, &amp;Y);</span><br><span class="line">			AddEge(Y, X);</span><br><span class="line">			D[X]++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) <span class="keyword">if</span> (!D[i]) Q.push(i);</span><br><span class="line">		<span class="keyword">while</span> (!Q.empty())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> X = Q.top();</span><br><span class="line">			Q.pop();</span><br><span class="line">			Ans[++Tot] = X;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = Head[X]; i; i = Next[i])</span><br><span class="line">			&#123;</span><br><span class="line">				D[E[i]]--;</span><br><span class="line">				<span class="keyword">if</span> (!D[E[i]]) Q.push(E[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (Tot == N) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = N; i; --i) <span class="built_in">printf</span> (<span class="string">"%d "</span>, Ans[i]);</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"impossible"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T3-方块-block"><a href="#T3-方块-block" class="headerlink" title="T3 方块(block)"></a>T3 方块(block)</h1><p>鸽了鸽了，不会做。。。</p>
<p>先贴个$std$，会者自会</p>
<p><del>这不是我写的</del></p>
<h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Hash(a,b,c) Ha[a][b][c]</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">105</span>,mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">LL n;</span><br><span class="line"><span class="keyword">int</span> t=<span class="number">0</span>,a[N],Min[<span class="number">1</span>&lt;&lt;<span class="number">12</span>],ID[<span class="number">1</span>&lt;&lt;<span class="number">12</span>],Ha[<span class="number">5</span>][<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Mat</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v[N][N];</span><br><span class="line">    Mat()&#123;&#125;</span><br><span class="line">    Mat(<span class="keyword">int</span> x)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(v,<span class="number">0</span>,<span class="keyword">sizeof</span> v);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=t;i++)</span><br><span class="line">            v[i][i]=x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;M(<span class="number">0</span>);</span><br><span class="line">Mat <span class="keyword">operator</span> * (Mat A,Mat B)&#123;</span><br><span class="line">    <span class="function">Mat <span class="title">C</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=t;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=t;j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=t;k++)</span><br><span class="line">                C.v[i][j]=(<span class="number">1L</span>L*A.v[i][k]*B.v[k][j]+C.v[i][j])%mod;</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Mat <span class="title">Pow</span><span class="params">(Mat x,LL y)</span></span>&#123;</span><br><span class="line">    <span class="function">Mat <span class="title">ans</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (;y;y&gt;&gt;=<span class="number">1</span>,x=x*x)</span><br><span class="line">        <span class="keyword">if</span> (y&amp;<span class="number">1L</span>L)</span><br><span class="line">            ans=ans*x;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SwapD</span><span class="params">(<span class="keyword">int</span> &amp;v,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (((v&gt;&gt;i)^(v&gt;&gt;j))&amp;<span class="number">1</span>)</span><br><span class="line">        v^=(<span class="number">1</span>&lt;&lt;i)^(<span class="number">1</span>&lt;&lt;j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">checkWB</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">2</span>;j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">3</span>;k++)</span><br><span class="line">                <span class="keyword">if</span> (s&gt;&gt;Hash(i,j,k)&amp;<span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">if</span> ((i+j+k)&amp;<span class="number">1</span>)</span><br><span class="line">                        ans++;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        ans--;</span><br><span class="line">    <span class="keyword">return</span> ans==<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> t=<span class="number">0</span>;t&lt;<span class="number">4</span>;t++)&#123;</span><br><span class="line">        <span class="keyword">int</span> v=s;</span><br><span class="line">        <span class="keyword">if</span> (t&amp;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">2</span>;j++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">3</span>;k++)</span><br><span class="line">                    SwapD(v,Hash(<span class="number">1</span>,j,k),Hash(<span class="number">2</span>,j,k));</span><br><span class="line">        <span class="keyword">if</span> (t&gt;&gt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>;i++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">2</span>;j++)</span><br><span class="line">                    SwapD(v,Hash(i,j,<span class="number">1</span>),Hash(i,j,<span class="number">3</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> d=<span class="number">0</span>;d&lt;<span class="number">4</span>;d++,res=min(res,v))</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">3</span>;i++)&#123;</span><br><span class="line">                SwapD(v,Hash(<span class="number">1</span>,<span class="number">1</span>,i),Hash(<span class="number">1</span>,<span class="number">2</span>,i));</span><br><span class="line">                SwapD(v,Hash(<span class="number">1</span>,<span class="number">2</span>,i),Hash(<span class="number">2</span>,<span class="number">2</span>,i));</span><br><span class="line">                SwapD(v,Hash(<span class="number">2</span>,<span class="number">2</span>,i),Hash(<span class="number">2</span>,<span class="number">1</span>,i));</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">6</span>]=&#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>,<span class="number">-1</span>&#125;,_x[<span class="number">6</span>];</span><br><span class="line"><span class="keyword">int</span> dy[<span class="number">6</span>]=&#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>,<span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,_y[<span class="number">6</span>];</span><br><span class="line"><span class="keyword">int</span> dz[<span class="number">6</span>]=&#123; <span class="number">1</span>,<span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,_z[<span class="number">6</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetXYZ</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">2</span>;j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">3</span>;k++)</span><br><span class="line">                <span class="keyword">if</span> ((i+j+k)&amp;<span class="number">1</span>)</span><br><span class="line">                    cnt++,_x[cnt]=i,_y[cnt]=j,_z[cnt]=k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetM</span><span class="params">(<span class="keyword">int</span> S,<span class="keyword">int</span> v,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t&gt;<span class="number">6</span>)&#123;</span><br><span class="line">        M.v[S][ID[Min[v]]]++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    GetM(S,v,t+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> x=_x[t],y=_y[t],z=_z[t],xx,yy,zz;</span><br><span class="line">    <span class="keyword">if</span> (v&gt;&gt;Hash(x,y,z)&amp;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">        xx=x+dx[i],yy=y+dy[i],zz=z+dz[i];</span><br><span class="line">        <span class="keyword">if</span> ((<span class="number">1</span>&lt;=xx&amp;&amp;xx&lt;=<span class="number">2</span>&amp;&amp;<span class="number">1</span>&lt;=yy&amp;&amp;yy&lt;=<span class="number">2</span>&amp;&amp;<span class="number">1</span>&lt;=zz&amp;&amp;zz&lt;=<span class="number">3</span>)&amp;&amp;(~v&gt;&gt;Hash(xx,yy,zz)&amp;<span class="number">1</span>))</span><br><span class="line">            GetM(S,v^(<span class="number">1</span>&lt;&lt;Hash(x,y,z))^(<span class="number">1</span>&lt;&lt;Hash(xx,yy,zz)),t+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"block.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>),freopen(<span class="string">"block.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">int</span> sz=<span class="number">1</span>&lt;&lt;<span class="number">12</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">2</span>;j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">3</span>;k++)</span><br><span class="line">                Ha[i][j][k]=(i<span class="number">-1</span>)*<span class="number">6</span>+(j<span class="number">-1</span>)*<span class="number">3</span>+k<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sz;i++)</span><br><span class="line">        <span class="keyword">if</span> (checkWB(i))</span><br><span class="line">            <span class="keyword">if</span> ((Min[i]=calc(i))==i)</span><br><span class="line">                a[++t]=i,ID[i]=t;</span><br><span class="line">    GetXYZ();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=t;i++)</span><br><span class="line">        GetM(i,a[i]^(sz<span class="number">-1</span>),<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n);</span><br><span class="line">    M=Pow(M,n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,M.v[ID[Min[sz<span class="number">-1</span>]]][ID[Min[sz<span class="number">-1</span>]]]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>鸽~</tag>
        <tag>考试</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>T20200826</title>
    <url>/2020/08/26/T20200826/</url>
    <content><![CDATA[<h1 id="T1-砍树-tree"><a href="#T1-砍树-tree" class="headerlink" title="T1 砍树(tree)"></a>T1 砍树(tree)</h1><p>树型$Dp$吧，水水过</p>
<p>注意开$long\;long$</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line">ll N, X, U, V, Cur;</span><br><span class="line">ll Sum[Maxn], Ans[Maxn];</span><br><span class="line"><span class="keyword">int</span> Head[Maxn], E[Maxn &lt;&lt; <span class="number">1</span>], Next[Maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> U, <span class="keyword">int</span> V)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Next[++Cur] = Head[U];</span><br><span class="line">	Head[U] = Cur;</span><br><span class="line">	E[Cur] = V; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> U, <span class="keyword">int</span> F)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Ans[U] = Sum[U];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = Head[U]; i; i = Next[i])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (E[i] == F) <span class="keyword">continue</span>;</span><br><span class="line">		DFS(E[i], U);</span><br><span class="line">		Sum[U] += Ans[E[i]];<span class="comment">//Sum表示以U为根的最大答案</span></span><br><span class="line">	&#125;</span><br><span class="line">	Ans[U] = max(-X, Sum[U]);<span class="comment">//如果-X比Sum[U]大，这个节点就可以直接砍掉了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span> (<span class="string">"%lld %lld"</span>, &amp;N, &amp;X);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) <span class="built_in">scanf</span> (<span class="string">"%lld"</span>, Sum + i);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span> (<span class="string">"%lld %lld"</span>, &amp;U, &amp;V);</span><br><span class="line">		AddEdge(U, V), AddEdge(V, U); </span><br><span class="line">	&#125;</span><br><span class="line">	DFS(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span> (<span class="string">"%lld\n"</span>, Ans[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T2-异或-xor"><a href="#T2-异或-xor" class="headerlink" title="T2 异或(xor)"></a>T2 异或(xor)</h1><p>求在$1\sim n$范围内满足方程$x\otimes2x=3x$的解的个数</p>
<h2 id="做法1"><a href="#做法1" class="headerlink" title="做法1"></a>做法1</h2><p>我们发现当$x\;\&amp;\;2x=0$时，$x$就是方程的一个解</p>
<p>简言之，就是在$x\;\&amp;\;(x&lt;&lt;1)=0$时， $x$就是方程的一个解</p>
<p>这就非常显然了吧</p>
<p>我们可以统计二进制下$1\sim n$中，任意两个$1$都不相邻的树的个数</p>
<p>用$f(cnt,up,last)$表示在第$cnt$位，是否到达峰值，上一位为$last$的方案数</p>
<h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll T, N, F[<span class="number">70</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> Num[<span class="number">70</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> Cnt, <span class="keyword">int</span> Up, <span class="keyword">bool</span> Jud)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (Cnt == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (F[Cnt][Up][Jud] != <span class="number">-1</span>) <span class="keyword">return</span> F[Cnt][Up][Jud];</span><br><span class="line">	ll Ans(0), Lim;</span><br><span class="line">	<span class="keyword">if</span> (Jud) Lim = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (Up) Lim = Num[Cnt];</span><br><span class="line">	<span class="keyword">else</span> Lim = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= Lim; ++i) Ans += DFS(Cnt - <span class="number">1</span>, Up &amp;&amp; i == Num[Cnt], i == <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> F[Cnt][Up][Jud] = Ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span> (<span class="string">"%lld"</span>, &amp;T);</span><br><span class="line">	<span class="keyword">while</span> (T--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span> (<span class="string">"%lld"</span>, &amp;N);</span><br><span class="line">		ll Temp = N, Cnt(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">while</span> (Temp) Num[++Cnt] = Temp &amp; <span class="number">1</span>, Temp &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">		<span class="built_in">memset</span>(F, <span class="number">-1</span>, <span class="keyword">sizeof</span> F);</span><br><span class="line">		<span class="built_in">printf</span> (<span class="string">"%lld\n"</span>, DFS(Cnt, <span class="number">1</span>, <span class="number">0</span>) - <span class="number">1</span>); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="做法2"><a href="#做法2" class="headerlink" title="做法2"></a>做法2</h2><p>先打个表</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>: <span class="number">1</span></span><br><span class="line"><span class="number">2</span>: <span class="number">2</span></span><br><span class="line"><span class="number">4</span>: <span class="number">3</span></span><br><span class="line"><span class="number">8</span>: <span class="number">5</span></span><br><span class="line"><span class="number">16</span>: <span class="number">8</span></span><br><span class="line"><span class="number">32</span>: <span class="number">13</span></span><br><span class="line"><span class="number">64</span>: <span class="number">21</span></span><br><span class="line"><span class="number">128</span>: <span class="number">34</span></span><br><span class="line"><span class="number">256</span>: <span class="number">55</span></span><br><span class="line"><span class="number">512</span>: <span class="number">89</span></span><br><span class="line"><span class="number">1024</span>: <span class="number">144</span></span><br></pre></td></tr></table></figure>
<p>然后发先在$2^k$范围内的数确实挺像斐波那契数列的</p>
<p>那么先预处理出最高位为$1$的所有数的答案，然后去加上下一个$1$的位置的答案</p>
<p>如果某两个$1$相邻，那么先加上我们得到的答案然后$-1$，$break$掉， 就可以了</p>
<h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll T, N, Feb[<span class="number">70</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">65</span>; ++i) Feb[i] = Feb[i - <span class="number">1</span>] + Feb[i - <span class="number">2</span>];</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%lld"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        ll Res(0), Cnt(0);</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">"%lld"</span>, &amp;N);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">60</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">            <span class="keyword">if</span> ((N &gt;&gt; i) &amp; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Res += Feb[i];</span><br><span class="line">                <span class="keyword">if</span> ((N &gt;&gt; (i + <span class="number">1</span>)) &amp; <span class="number">1</span>)&#123;--Res; <span class="keyword">break</span>;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"%lld\n"</span>, Res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是$SYK$巨佬一直在讲的，打表找规律是个好方法的体现啊</p>
<h1 id="T3-等式-equ"><a href="#T3-等式-equ" class="headerlink" title="T3  等式(equ)"></a>T3  等式(equ)</h1><p>先给出两个式子：</p>
<script type="math/tex; mode=display">
\sum_{i=1}^na_ix_i=S\\
\sum_{i=1}^nb_ix_i=T</script><p>求${x}$, $x$为非负实数，使其在满足上述两个式子的情况下使$\sum_{i=1}^nc_ix_i$最大</p>
<p>求$\sum_{i=1}^nc_ix_i$， 输出五位浮点数，若无解，输出$\text{“impossible”}$</p>
<h2 id="15分做法"><a href="#15分做法" class="headerlink" title="15分做法"></a>15分做法</h2><p>那就是对$n=1$或者$n=2$的数据直接解方程</p>
<p><del>考场上的丢人代码</del></p>
<h2 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M, S, T;</span><br><span class="line"><span class="keyword">double</span> Ans;</span><br><span class="line"><span class="keyword">int</span> A[<span class="number">5</span>], B[<span class="number">5</span>], C[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">double</span> X[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">N1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (S * B[<span class="number">1</span>] != T * A[<span class="number">1</span>]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	Ans = <span class="keyword">double</span>(S) / <span class="keyword">double</span>(A[<span class="number">1</span>]) * <span class="keyword">double</span> (C[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">N2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> D = A[<span class="number">2</span>] * B[<span class="number">1</span>], E = B[<span class="number">2</span>] * A[<span class="number">1</span>], F = S * B[<span class="number">1</span>], G = T * A[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">if</span> ((D - E == <span class="number">0</span>) &amp;&amp; (G - G != <span class="number">0</span>)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	X[<span class="number">2</span>] = <span class="keyword">double</span>(F - G) / <span class="keyword">double</span>(D - E);</span><br><span class="line">	X[<span class="number">1</span>] = (<span class="keyword">double</span> (S) - A[<span class="number">2</span>] * X[<span class="number">2</span>]) / A[<span class="number">1</span>];</span><br><span class="line">	Ans = C[<span class="number">1</span>] * X[<span class="number">1</span>] + C[<span class="number">2</span>] * X[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">if</span> (X[<span class="number">1</span>] &lt; <span class="number">0</span> || X[<span class="number">2</span>] &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span> (<span class="string">"%d %d"</span>, &amp;N, &amp;M);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) <span class="built_in">scanf</span> (<span class="string">"%d %d %d"</span>, A + i, B + i, C + i);</span><br><span class="line">	<span class="keyword">while</span> (M--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span> (<span class="string">"%d %d"</span>, &amp;S, &amp;T);</span><br><span class="line">		<span class="keyword">bool</span> Flag;</span><br><span class="line">		<span class="keyword">if</span> (N == <span class="number">1</span>) Flag = N1();</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (N == <span class="number">2</span>) Flag = N2();</span><br><span class="line">		<span class="keyword">if</span> (Flag) <span class="built_in">puts</span>(<span class="string">"impossible"</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span> (<span class="string">"%.5lf\n"</span>, Ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="30分做法"><a href="#30分做法" class="headerlink" title="30分做法"></a>30分做法</h2><p>根据$XZC$巨佬的结论，答案只与其中最多两个$x_i$的值有关，那么剩下的就是一个暴力了</p>
<h2 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL int </span></span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LL x = <span class="number">0</span>,f = <span class="number">0</span>;<span class="keyword">char</span> ch = getchar();</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span>(ch==<span class="string">'-'</span>)f=<span class="number">1</span>;ch = getchar();&#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) &#123;x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;ch = getchar();&#125;</span><br><span class="line">	<span class="keyword">return</span> f ?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	LL x,y,c;</span><br><span class="line">	Point() &#123;x=<span class="number">0</span>;y=<span class="number">0</span>;c=<span class="number">0</span>;&#125;</span><br><span class="line">	Point(<span class="keyword">int</span> _x,<span class="keyword">int</span> _y,<span class="keyword">int</span> _c = <span class="number">0</span>) &#123;x=_x;y=_y;c=_c;&#125;</span><br><span class="line">	Point <span class="keyword">operator</span> + (<span class="keyword">const</span> Point a)<span class="keyword">const</span> &#123;<span class="keyword">return</span> Point(a.x+x,a.y+y);&#125;</span><br><span class="line">&#125;v[N],P;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">cross</span><span class="params">(Point a,Point b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.x * b.y - a.y * b.x;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">LL n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Point a,Point b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.c / <span class="number">1.0</span> * <span class="built_in">sqrt</span>(a.x * a.x + a.y * a.y) &gt; b.c / <span class="number">1.0</span> * <span class="built_in">sqrt</span>(b.x * b.x + b.y * b.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> limit1 = <span class="number">1e18</span>,limit2 = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	n = read(), m = read();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) v[i].x = read(), v[i].y = read(), v[i].c = read();</span><br><span class="line">	v[<span class="number">0</span>].x = <span class="number">0</span>, v[<span class="number">0</span>].y = <span class="number">0</span>, v[<span class="number">0</span>].c = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">		limit1 = min(limit1, <span class="built_in">atan2</span>(v[i].y, v[i].x));</span><br><span class="line">		limit2 = max(limit2, <span class="built_in">atan2</span>(v[i].y, v[i].x));</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="keyword">int</span> s = read(), t = read();</span><br><span class="line">		P.x = s;P.y = t;P.c = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">double</span> K = <span class="built_in">atan2</span>(P.y,P.x);</span><br><span class="line">		<span class="keyword">if</span>(K &lt; limit1 || K &gt; limit2) &#123;</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">"impossible"</span>);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">double</span> ans = <span class="number">0.0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(P.x * v[i].y == v[i].x * P.y)&#123;</span><br><span class="line">					ans = max((<span class="keyword">double</span>)P.x / v[i].x * v[i].c, ans);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span>(i == j) <span class="keyword">continue</span>;</span><br><span class="line">					<span class="keyword">double</span> X2 = <span class="number">1.0</span> * cross(v[i],P) / (<span class="keyword">double</span>)cross(v[i], v[j]);</span><br><span class="line">					<span class="keyword">double</span> X1 = (<span class="number">1.0</span> * P.x - X2 * v[j].x) / v[i].x;</span><br><span class="line">					<span class="keyword">if</span>(X1 &lt;= <span class="number">0.0</span> || X2 &lt;= <span class="number">0.0</span>) <span class="keyword">continue</span>;</span><br><span class="line">					ans = max(ans, X2 * v[j].c + X1 * v[i].c);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%.5lf\n"</span>, ans);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="100分"><a href="#100分" class="headerlink" title="100分"></a>100分</h2><p>对偶线性规划</p>
<p>平面半交</p>
<p>二分答案</p>
<p>鸽他！！</p>
]]></content>
      <tags>
        <tag>树型Dp</tag>
        <tag>鸽~</tag>
        <tag>考试</tag>
        <tag>数位Dp</tag>
      </tags>
  </entry>
  <entry>
    <title>T20200827</title>
    <url>/2020/08/27/T20200827/</url>
    <content><![CDATA[

	<div class="row">
    <embed src="problem.pdf" width="100%" height="550" type="application/pdf">
	</div>



<h1 id="T1-achen"><a href="#T1-achen" class="headerlink" title="T1 achen"></a>T1 achen</h1><p>就是考虑目标节点可能从那些地方转移过来，然后就得到了$f[i]=f[i-1]+f[i-3]$</p>
<p>然后基本上就结束了</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">ll <span class="title">X</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">char</span> <span class="title">O</span><span class="params">(getchar())</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (O &lt; <span class="string">'0'</span> || O &gt; <span class="string">'9'</span>) O = getchar();</span><br><span class="line">	<span class="keyword">for</span> (; O &gt;= <span class="string">'0'</span> &amp;&amp; O &lt;= <span class="string">'9'</span>; O = getchar()) X = (X &lt;&lt; <span class="number">1</span>) + (X &lt;&lt; <span class="number">3</span>) + (O ^ <span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> X;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll Maxn = <span class="number">1e6</span> + <span class="number">10</span>, Mod = <span class="number">998244353</span>;</span><br><span class="line">ll Feb[Maxn] = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">ll T, N, A, B;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	T = Read();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Maxn; ++i) Feb[i] %= Mod, Feb[i + <span class="number">1</span>] += Feb[i], Feb[i + <span class="number">3</span>] += Feb[i];</span><br><span class="line">	<span class="keyword">while</span> (T--)</span><br><span class="line">	&#123;</span><br><span class="line">		N = Read(), A = Read(), B = Read();</span><br><span class="line">		<span class="keyword">if</span> (A &gt; B) swap(A, B);</span><br><span class="line">		<span class="keyword">if</span> (A &gt; <span class="number">1</span>) A += <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (B &lt; N) B -= <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (B &lt; A) <span class="built_in">puts</span>(<span class="string">"0"</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span> (<span class="string">"%lld\n"</span>, Feb[B - A]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T2-Tree"><a href="#T2-Tree" class="headerlink" title="T2 Tree"></a>T2 Tree</h1><blockquote>
<p>  考场思路：</p>
<p>  对于$Subtas1$：暴力换根</p>
<p>  对于$Subtas2$：树的直径</p>
<p>  非常好，全写挂了，又因为是$Subtask$， 就只有零分</p>
</blockquote>
<h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">1e6</span> + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> Head[Maxn], Next[Maxn &lt;&lt; <span class="number">1</span>], E[Maxn &lt;&lt; <span class="number">1</span>], Cur;</span><br><span class="line"><span class="keyword">int</span> Col[Maxn], Fa[Maxn][<span class="number">20</span>], Dep[Maxn], Max[Maxn];</span><br><span class="line"><span class="keyword">int</span> In[Maxn], Se[Maxn], Out[Maxn], Tim;</span><br><span class="line"><span class="keyword">bool</span> Vis1[Maxn], Vis2[Maxn];</span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; V[Maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">X</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="keyword">char</span> O = getchar();</span><br><span class="line">	<span class="keyword">while</span> (O &lt; <span class="string">'0'</span> || O &gt; <span class="string">'9'</span>) O = getchar();</span><br><span class="line">	<span class="keyword">for</span> (; O &gt;= <span class="string">'0'</span> &amp;&amp; O &lt;= <span class="string">'9'</span>; O = getchar()) X = (X &lt;&lt; <span class="number">1</span>) + (X &lt;&lt; <span class="number">3</span>) + (O ^ <span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> X;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> U, <span class="keyword">int</span> V)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Next[++Cur] = Head[U];</span><br><span class="line">	Head[U] = Cur;</span><br><span class="line">	E[Cur] = V;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> U, <span class="keyword">int</span> F)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	In[U] = ++Tim, Max[U] = Dep[U] = Dep[Fa[U][<span class="number">0</span>] = F] + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = Head[U]; i; i = Next[i]) </span><br><span class="line">		<span class="keyword">if</span> (E[i] != F) DFS(E[i], U);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = Head[U]; i; i = Next[i])</span><br><span class="line">		<span class="keyword">if</span> (E[i] != F)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (Max[E[i]] &gt;= Max[U]) Se[U] = Max[U], Max[U] = Max[E[i]];</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (Max[E[i]] &gt;= Se[U]) Se[U] = Max[E[i]];</span><br><span class="line">		&#125;</span><br><span class="line">	Out[U] = Tim;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">F_LCA</span><span class="params">(<span class="keyword">int</span> U, <span class="keyword">int</span> V)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (Dep[U] &lt; Dep[V]) swap(U, V);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i)</span><br><span class="line">		<span class="keyword">if</span> (((Dep[U] - Dep[V]) &gt;&gt; i) &amp; <span class="number">1</span>) U = Fa[U][i];</span><br><span class="line">	<span class="keyword">if</span> (U == V) <span class="keyword">return</span> U;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">19</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">		<span class="keyword">if</span> (Fa[U][i] != Fa[V][i]) U = Fa[U][i], V = Fa[V][i];</span><br><span class="line">	<span class="keyword">return</span> Fa[U][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Cmp</span><span class="params">(<span class="keyword">int</span> X, <span class="keyword">int</span> Y)</span></span>&#123;<span class="keyword">return</span> In[X] &lt; In[Y];&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A[Maxn], L, R, Cnt, Ans;</span><br><span class="line"><span class="keyword">int</span> Ct[Maxn], Rit[Maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS_2</span><span class="params">(<span class="keyword">int</span> U, <span class="keyword">int</span> Val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = Head[U]; i; i = Next[i])</span><br><span class="line">		<span class="keyword">if</span> (!Vis1[E[i]]) Ans = max(Ans, Max[E[i]] - Dep[U] + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (Vis2[U]) Ans = max(Ans, Dep[U] + Val);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = Head[U]; i; i = Next[i])</span><br><span class="line">		<span class="keyword">if</span> (E[i] != Fa[U][<span class="number">0</span>])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (Max[E[i]] == Max[U]) DFS_2(E[i], max(Val, Se[U] - <span class="number">2</span> * Dep[U] + <span class="number">1</span>));</span><br><span class="line">			<span class="keyword">else</span> DFS_2(E[i], max(Val, Max[U] - <span class="number">2</span> * Dep[U] + <span class="number">1</span>));</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> N = Read(), M = Read(), X, Y, LCA;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) V[Col[i] = Read()].push_back(i);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		X = Read(), Y = Read();</span><br><span class="line">		AddEdge (X, Y), AddEdge(Y, X);</span><br><span class="line">	&#125;</span><br><span class="line">	DFS(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">19</span>; ++i)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; ++j)</span><br><span class="line">			Fa[j][i] = Fa[Fa[j][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		X = V[i][<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; V[i].size(); ++j)</span><br><span class="line">			LCA = F_LCA(V[i][j], V[i][j - <span class="number">1</span>]), X = Dep[X] &lt; Dep[LCA] ? X : LCA;</span><br><span class="line">		<span class="keyword">while</span> (X &amp;&amp; !Vis1[X]) Vis1[X] = <span class="number">1</span>, X = Fa[X][<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) A[In[i]] = Col[i];</span><br><span class="line">	<span class="keyword">for</span> (L = <span class="number">1</span>; L &lt;= N; ++L)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (Cnt != M &amp;&amp; R &lt;= N)</span><br><span class="line">		&#123;</span><br><span class="line">			++R;</span><br><span class="line">			<span class="keyword">if</span> (!Ct[A[R]]) ++Cnt;</span><br><span class="line">			++Ct[A[R]];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (Cnt != M &amp;&amp; R == N)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = L; i &lt;= N; ++i) Rit[i] = N + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Rit[L] = R, --Ct[A[L]];</span><br><span class="line">		<span class="keyword">if</span> (!Ct[A[L]]) --Cnt;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">		<span class="keyword">if</span> (Out[i] &gt;= Rit[In[i]]) Vis2[i] = <span class="number">1</span>;</span><br><span class="line">	DFS_2(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">printf</span> (<span class="string">"%d\n"</span>, Ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T3-easy"><a href="#T3-easy" class="headerlink" title="T3 easy"></a>T3 easy</h1><p>没看出来这道题有多么$easy$， <del>mdzz</del></p>
<blockquote>
<p>  考场$n^2$暴力：枚举$l,\;r$， 用$map$维护乱搞一通，检验连续的数的个数和区间长度的关系，就完了</p>
</blockquote>
<h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Val first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Pos second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LS (X &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RS (X &lt;&lt; 1 | 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Mid ((L + R) &gt;&gt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Node(X, Y) make_pair(X, Y)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">1e5</span> + <span class="number">10</span>, Mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M, Last[Maxn], Now[Maxn];</span><br><span class="line"><span class="keyword">int</span> A[Maxn], B[Maxn];</span><br><span class="line">ll Ans;</span><br><span class="line"><span class="keyword">int</span> Min[Maxn &lt;&lt; <span class="number">2</span>], Cnt[Maxn &lt;&lt; <span class="number">2</span>], Tag[Maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">PushUp</span><span class="params">(<span class="keyword">int</span> X)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Min[X] = min(Min[LS], Min[RS]), Cnt[X] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (Min[X] == Min[LS]) Cnt[X] += Cnt[LS];</span><br><span class="line">	<span class="keyword">if</span> (Min[X] == Min[RS]) Cnt[X] += Cnt[RS];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">F</span><span class="params">(<span class="keyword">int</span> X, <span class="keyword">int</span> V)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Min[X] += V;</span><br><span class="line">	Tag[X] += V;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">PushDown</span><span class="params">(<span class="keyword">int</span> X)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!Tag[X]) <span class="keyword">return</span> ;</span><br><span class="line">	F(LS, Tag[X]), F(RS, Tag[X]);</span><br><span class="line">	Tag[X] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Build</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> X = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (L == R)</span><br><span class="line">	&#123;</span><br><span class="line">		Min[X] = <span class="number">0</span>, Cnt[X] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Build(L, Mid, LS);</span><br><span class="line">	Build(Mid + <span class="number">1</span>, R, RS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">UpDate</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> Tl, <span class="keyword">int</span> Tr, <span class="keyword">int</span> V, <span class="keyword">int</span> X = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (L &gt;= Tl &amp;&amp; R &lt;= Tr)</span><br><span class="line">	&#123;</span><br><span class="line">		F(X, V) ;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	PushDown(X);</span><br><span class="line">	<span class="keyword">if</span> (Tl &lt;= Mid) UpDate (L, Mid, Tl, Tr, V, LS);</span><br><span class="line">	<span class="keyword">if</span> (Tr &gt; Mid) UpDate (Mid + <span class="number">1</span>, R, Tl, Tr, V, RS);</span><br><span class="line">	PushUp(X);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> Tl, <span class="keyword">int</span> Tr, <span class="keyword">int</span> X = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (L &gt;= Tl &amp;&amp; R &lt;= Tr) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (Min[X] == <span class="number">-1</span>) <span class="keyword">return</span> Cnt[X];</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">Ans</span><span class="params">(<span class="number">0</span>)</span></span>; PushDown(X);</span><br><span class="line">	<span class="keyword">if</span> (Tl &lt;= Mid) Ans += Query (L, Mid, Tl, Tr, LS);</span><br><span class="line">	<span class="keyword">if</span> (Tr &gt; Mid) Ans += Query (Mid + <span class="number">1</span>, R, Tl, Tr, RS);</span><br><span class="line">	<span class="keyword">return</span> Ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">stack</span> &lt;pair &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; Gtr, Les;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span> (<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) <span class="built_in">scanf</span> (<span class="string">"%d"</span>, A + i), B[i] = A[i];</span><br><span class="line">	sort (B + <span class="number">1</span>, B + N + <span class="number">1</span>);</span><br><span class="line">	M = unique (B + <span class="number">1</span>, B + N + <span class="number">1</span>) - B - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> Temp = lower_bound(B + <span class="number">1</span>, B + M + <span class="number">1</span>, A[i]) - B;</span><br><span class="line">		Last[i] = Now[Temp], Now[Temp] = i;</span><br><span class="line">	&#125;</span><br><span class="line">	Build(<span class="number">1</span>, N);</span><br><span class="line">	Gtr.push(Node(<span class="number">0</span>, <span class="number">0</span>)), Les.push(Node(Mod, <span class="number">0</span>));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (Les.size() &amp;&amp; Les.top().Val &lt;= A[i])</span><br><span class="line">		&#123;</span><br><span class="line">			pair &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; Top = Les.top(); Les.pop();</span><br><span class="line">			UpDate(<span class="number">1</span>, N, Les.top().Pos + <span class="number">1</span>, Top.Pos, A[i] - Top.Val);</span><br><span class="line">		&#125;</span><br><span class="line">		Les.push(Node(A[i], i));</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (Gtr.size() &amp;&amp; Gtr.top().Val &gt;= A[i])</span><br><span class="line">		&#123;</span><br><span class="line">			pair &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; Top = Gtr.top(); Gtr.pop();</span><br><span class="line">			UpDate(<span class="number">1</span>, N, Gtr.top().Pos + <span class="number">1</span>, Top.Pos, Top.Val - A[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		Gtr.push(Node(A[i], i));</span><br><span class="line"></span><br><span class="line">		UpDate(<span class="number">1</span>, N, Last[i] + <span class="number">1</span>, i, <span class="number">-1</span>);</span><br><span class="line">		Ans += Query(<span class="number">1</span>, N, <span class="number">1</span>, i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span> (<span class="string">"%lld\n"</span>, Ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><del>因为人懒，今天就先放一个官方题解吧</del></p>


	<div class="row">
    <embed src="solution.pdf" width="100%" height="550" type="application/pdf">
	</div>


]]></content>
      <tags>
        <tag>倍增</tag>
        <tag>数据结构</tag>
        <tag>鸽~</tag>
        <tag>Dp优化</tag>
        <tag>考试</tag>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title>T20200828</title>
    <url>/2020/08/29/T20200828/</url>
    <content><![CDATA[

	<div class="row">
    <embed src="problem.pdf" width="100%" height="550" type="application/pdf">
	</div>



<h1 id="T1-doubt"><a href="#T1-doubt" class="headerlink" title="T1 doubt"></a>T1 doubt</h1><p>贪心，让亦或最小的，就是二进制下最相近的亦或在一起</p>
<p>用$01$字典树贪心乱搞</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">0</span>,f = <span class="number">0</span>;<span class="keyword">char</span> ch = getchar();</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span>(ch == <span class="string">'-'</span>)f=<span class="number">1</span>;ch=getchar();&#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) &#123;x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;ch = getchar();&#125;</span><br><span class="line">	<span class="keyword">return</span> f ? -x : x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">100</span>,M = (<span class="number">2e5</span>+<span class="number">100</span>) * <span class="number">31</span>;</span><br><span class="line"><span class="keyword">int</span> rt[<span class="number">2</span>],ch[M][<span class="number">2</span>],cnt[M],si;</span><br><span class="line"><span class="keyword">int</span> A[N],B[N],n;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> t,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(t &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">int</span> i = (x&gt;&gt;t)&amp;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(!ch[a][i]) ch[a][i] = ++si;</span><br><span class="line">	cnt[ch[a][i]]++;</span><br><span class="line">	insert(ch[a][i],t<span class="number">-1</span>,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> x,<span class="keyword">int</span> t,<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(t &lt; <span class="number">0</span>) &#123;<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= num;i++) Ans.push_back(x);<span class="keyword">return</span>;&#125;</span><br><span class="line">	<span class="keyword">if</span>(cnt[ch[a][<span class="number">0</span>]] &amp;&amp; cnt[ch[b][<span class="number">0</span>]])&#123;</span><br><span class="line">		<span class="keyword">int</span> sum = min(cnt[ch[a][<span class="number">0</span>]],cnt[ch[b][<span class="number">0</span>]]);</span><br><span class="line">		sum = min(num,sum);</span><br><span class="line">		print(ch[a][<span class="number">0</span>],ch[b][<span class="number">0</span>],x,t<span class="number">-1</span>,sum);</span><br><span class="line">		cnt[ch[a][<span class="number">0</span>]] -= sum;cnt[ch[b][<span class="number">0</span>]] -= sum;num -= sum;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(cnt[ch[a][<span class="number">1</span>]] &amp;&amp; cnt[ch[b][<span class="number">1</span>]])&#123;</span><br><span class="line">		<span class="keyword">int</span> sum = min(cnt[ch[a][<span class="number">1</span>]],cnt[ch[b][<span class="number">1</span>]]);</span><br><span class="line">		sum = min(sum,num);</span><br><span class="line">		print(ch[a][<span class="number">1</span>],ch[b][<span class="number">1</span>],x,t<span class="number">-1</span>,sum);</span><br><span class="line">		cnt[ch[a][<span class="number">1</span>]] -= sum;cnt[ch[b][<span class="number">1</span>]] -= sum;num -= sum;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(cnt[ch[a][<span class="number">1</span>]] &amp;&amp; cnt[ch[b][<span class="number">0</span>]])&#123;</span><br><span class="line">		<span class="keyword">int</span> sum = min(cnt[ch[a][<span class="number">1</span>]],cnt[ch[b][<span class="number">0</span>]]);</span><br><span class="line">		sum = min(sum,num);</span><br><span class="line">		print(ch[a][<span class="number">1</span>],ch[b][<span class="number">0</span>],x+(<span class="number">1</span>&lt;&lt;t),t<span class="number">-1</span>,sum);</span><br><span class="line">		cnt[ch[a][<span class="number">1</span>]] -= sum;cnt[ch[b][<span class="number">0</span>]] -= sum;num -= sum;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(cnt[ch[a][<span class="number">0</span>]] &amp;&amp; cnt[ch[b][<span class="number">1</span>]])&#123;</span><br><span class="line">		<span class="keyword">int</span> sum = min(cnt[ch[a][<span class="number">0</span>]],cnt[ch[b][<span class="number">1</span>]]);</span><br><span class="line">		sum = min(sum,num);</span><br><span class="line">		print(ch[a][<span class="number">0</span>],ch[b][<span class="number">1</span>],x+(<span class="number">1</span>&lt;&lt;t),t<span class="number">-1</span>,sum);</span><br><span class="line">		cnt[ch[a][<span class="number">0</span>]] -= sum;cnt[ch[b][<span class="number">1</span>]] -= sum;num -= sum;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n = read();rt[<span class="number">0</span>] = ++si;rt[<span class="number">1</span>] = ++si;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) A[i] = read(),insert(rt[<span class="number">0</span>],<span class="number">30</span>,A[i]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) B[i] = read(),insert(rt[<span class="number">1</span>],<span class="number">30</span>,B[i]);</span><br><span class="line">	print(rt[<span class="number">0</span>],rt[<span class="number">1</span>],<span class="number">0</span>,<span class="number">30</span>,n);</span><br><span class="line">	sort(Ans.begin(),Ans.end());</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; Ans.size();i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>,Ans[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T2-block"><a href="#T2-block" class="headerlink" title="T2 block"></a>T2 block</h1><p>日常鸽一题</p>
<p>状压Dp</p>
<h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = (<span class="keyword">int</span>) <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = (<span class="keyword">int</span>) <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, h[MAXN], sorted[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; x &gt; <span class="number">0</span>; x &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &amp; <span class="number">1</span>)</span><br><span class="line">            res = <span class="number">1L</span>L * res * a % MOD;</span><br><span class="line">        a = <span class="number">1L</span>L * a * a % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> added[MAXN];</span><br><span class="line"><span class="keyword">int</span> R_L[MAXN], L_R[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[MAXN][<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> last_h[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> dp_l[<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>], <span class="keyword">int</span> dp_r[<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>], <span class="keyword">int</span> res[<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp[<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(tmp, <span class="number">0</span>, <span class="keyword">sizeof</span> tmp);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; <span class="number">2</span>; ++l)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; <span class="number">2</span>; ++r) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> ll = <span class="number">0</span>; ll &lt; <span class="number">2</span>; ++ll)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> rr = <span class="number">0</span>; rr &lt; <span class="number">2</span>; ++rr)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> sl = <span class="number">0</span>; sl &lt; <span class="number">2</span>; ++sl)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> sr = <span class="number">0</span>; sr &lt; <span class="number">2</span>; ++sr) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = sl | sr | (ll == rr);</span><br><span class="line">            tmp[l][r][t] = (tmp[l][r][t] + <span class="number">1L</span>L * dp_l[l][ll][sl] * dp_r[rr][r][sr]) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memcpy</span>(res, tmp, <span class="keyword">sizeof</span> tmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> h_now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (last_h[L] == h_now) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> tmp[<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> t = (last_h[L] - h_now) &amp; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; <span class="number">2</span>; ++l)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; <span class="number">2</span>; ++r) &#123;</span><br><span class="line">        tmp[l][r][<span class="number">1</span>] = dp[L][l ^ t][r ^ t][<span class="number">1</span>];</span><br><span class="line">        tmp[l][r][<span class="number">0</span>] = <span class="number">1L</span>L * (dp[L][l][r][<span class="number">0</span>] + dp[L][l ^ <span class="number">1</span>][r ^ <span class="number">1</span>][<span class="number">0</span>]) * qpow(<span class="number">2</span>, last_h[L] - h_now - <span class="number">1</span>) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(dp[L], tmp, <span class="keyword">sizeof</span> tmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LOCAL</span></span><br><span class="line">    freopen(<span class="string">"block.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"block.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, h + i);</span><br><span class="line">        sorted[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::sort(sorted + <span class="number">1</span>, sorted + n + <span class="number">1</span>, [&amp;] (<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">        <span class="keyword">return</span> h[a] &gt; h[b];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = sorted[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> tmp[<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> L = j, R = j;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(tmp, <span class="number">0</span>, <span class="keyword">sizeof</span> tmp);</span><br><span class="line">        tmp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = tmp[<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (R_L[j - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">int</span> l = R_L[j - <span class="number">1</span>], r = j - <span class="number">1</span>;</span><br><span class="line">            L_R[l] = R_L[r] = <span class="number">0</span>;</span><br><span class="line">            calc(l, h[j]);</span><br><span class="line">            merge(dp[l], tmp, tmp);</span><br><span class="line">            L = l;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (L_R[j + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">int</span> l = j + <span class="number">1</span>, r = L_R[j + <span class="number">1</span>];</span><br><span class="line">            L_R[l] = R_L[r] = <span class="number">0</span>;</span><br><span class="line">            calc(l, h[j]);</span><br><span class="line">            merge(tmp, dp[l], tmp);</span><br><span class="line">            R = r;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        added[j] = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>(dp[L], tmp, <span class="keyword">sizeof</span> tmp);</span><br><span class="line">        L_R[L] = R;</span><br><span class="line">        R_L[R] = L;</span><br><span class="line">        last_h[L] = h[j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (h[sorted[n]] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = (h[sorted[n]] - <span class="number">1</span>) &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp[<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; <span class="number">2</span>; ++l)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; <span class="number">2</span>; ++r) &#123;</span><br><span class="line">            tmp[l][r][<span class="number">1</span>] = dp[<span class="number">1</span>][l ^ t][r ^ t][<span class="number">1</span>];</span><br><span class="line">            tmp[l][r][<span class="number">0</span>] = <span class="number">1L</span>L * (dp[<span class="number">1</span>][l][r][<span class="number">0</span>] + dp[<span class="number">1</span>][l ^ <span class="number">1</span>][r ^ <span class="number">1</span>][<span class="number">0</span>]) * qpow(<span class="number">2</span>, h[sorted[n]] - <span class="number">1</span> - <span class="number">1</span>) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">memcpy</span>(dp[<span class="number">1</span>], tmp, <span class="keyword">sizeof</span> tmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; ++j)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span>; ++k) &#123;</span><br><span class="line">        ans = (ans + dp[<span class="number">1</span>][i][j][k]) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//std码风好评</span></span><br></pre></td></tr></table></figure>
<h1 id="T3-road"><a href="#T3-road" class="headerlink" title="T3 road"></a>T3 road</h1><p>考场上只有<a href="https://widsnoy.top/" target="_blank" rel="noopener"><strong>widsnoy​</strong></a>巨佬想到了正解， %%%</p>
<p>这道就是说，给你$n$个点，$n+1$条边，让你随意删一条边都能使这个图联通的连边方案数</p>
<blockquote>
<p>  问题转化：</p>
<blockquote>
<p>我们发现，不能有点的度数为$1$</p>
<p>所以绝大多数的点的度数为$2$</p>
<p>那么就有如下两种情况：</p>
<ul>
<li>有一个点度数为$4$</li>
<li>有两个点度数为$3$</li>
</ul>
</blockquote>
</blockquote>
<p>那么有这样一个式子：$Ans = \frac{n!(n-3)}4+\frac{n!(n-4)}8+\frac{n!(n-3)(n-4)}{24}$</p>
<p>然后分段打表处理阶乘</p>
<h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>, inv2 = <span class="number">5e8</span> + <span class="number">4</span>, inv3 = <span class="number">333333336</span>;</span><br><span class="line">ll n, ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;n);</span><br><span class="line">	ll mi = <span class="number">1</span>, t = inv2 * inv2 % mod;<span class="comment">//4</span></span><br><span class="line">	<span class="keyword">for</span> (ll i = <span class="number">2</span>; i &lt;= n; ++i) mi = mi * i % mod;<span class="comment">//n!</span></span><br><span class="line">	ans += (n - <span class="number">3</span>) * t % mod;</span><br><span class="line">	t = t * inv2 % mod;</span><br><span class="line">	ans += (n - <span class="number">4</span>) * t % mod;<span class="comment">//8</span></span><br><span class="line">	ans += (n - <span class="number">3</span>) * (n - <span class="number">4</span>) % mod * t % mod * inv3 % mod;</span><br><span class="line">	ans = ans % mod * mi % mod;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


	<div class="row">
    <embed src="solution.pdf" width="100%" height="550" type="application/pdf">
	</div>



]]></content>
      <tags>
        <tag>字典树</tag>
        <tag>数学</tag>
        <tag>鸽~</tag>
        <tag>考试</tag>
        <tag>状压</tag>
      </tags>
  </entry>
  <entry>
    <title>T20200831</title>
    <url>/2020/08/31/T20200831/</url>
    <content><![CDATA[

	<div class="row">
    <embed src="problem.pdf" width="100%" height="550" type="application/pdf">
	</div>



<h1 id="T1-教师节的问候"><a href="#T1-教师节的问候" class="headerlink" title="T1 教师节的问候"></a>T1 教师节的问候</h1><p>那么就是说，我们有一个矩阵</p>
<script type="math/tex; mode=display">
\begin{vmatrix}
 0&a_1+a_2&a_1+a_3&\cdots&a_1+a_n
 \\a_2+a_1&0&a_2+a_3&\cdots&a_2+a_n
 \\a_3+a_1&a_3+a_2&0&\cdots&a_3+a_n
 \\\vdots&\vdots&\vdots&\ddots&\vdots
 \\a_n+a_1&a_n+a_2&a_n+a_3&\cdots&0
 \end{vmatrix}</script><p>康康最前面两行，我们发现从第三项开始$a_1-a_2=(a_1+a_3)-(a_2+a_3)$</p>
<p>那么就有了$a_1+a_2=x$和$a_1-a_2=y$</p>
<p>那么$a_1$和$a_2$就都可以解出来了</p>
<p>那么所有的元素都可以解出来了</p>
<p>但是要注意的是，当<code>n = 2</code>时可以乱搞的</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">1005</span>;</span><br><span class="line"><span class="keyword">int</span> N, S[Maxn][Maxn], A[Maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span> (<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; ++j)</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>, S[i] + j), S[i][<span class="number">0</span>] += S[i][j];</span><br><span class="line">	<span class="keyword">if</span> (N == <span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">printf</span> (<span class="string">"2 %d"</span>, S[<span class="number">1</span>][<span class="number">2</span>] - <span class="number">2</span>), <span class="number">0</span>;</span><br><span class="line">	A[<span class="number">1</span>] = (S[<span class="number">1</span>][<span class="number">2</span>] + (S[<span class="number">1</span>][<span class="number">0</span>] - S[<span class="number">2</span>][<span class="number">0</span>]) / (N - <span class="number">2</span>)) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; ++i) A[i] = S[i][i - <span class="number">1</span>] - A[i - <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) <span class="built_in">printf</span> (<span class="string">"%d "</span>, A[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T2-追逐闹剧"><a href="#T2-追逐闹剧" class="headerlink" title="T2 追逐闹剧"></a>T2 追逐闹剧</h1><p>这个就是正反一边最短路，还只能用$\text{SPFA}$</p>
<p>对于加油点扩展的话，离开加油点时，我们就可以把他的$\text{dis}$设为$0$</p>
<p>然后对可以卖油的点处理一下即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> N, M, C, P, U, V, L;</span><br><span class="line"><span class="keyword">int</span> Head[Maxn], Next[Maxn], E[Maxn], W[Maxn], Cur;</span><br><span class="line"><span class="keyword">int</span> Bead[Maxn], Bext[Maxn], B[Maxn];</span><br><span class="line"><span class="keyword">int</span> Dist[Maxn], Bist[Maxn], Ans(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">bool</span> Vis[Maxn], Plus[Maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> U, <span class="keyword">int</span> V, <span class="keyword">int</span> L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Next[++Cur] = Head[U], Head[U] = Cur;</span><br><span class="line">	E[Cur] = V, W[Cur] = L;</span><br><span class="line">	</span><br><span class="line">	Bext[Cur] = Bead[V], Bead[V] = Cur;</span><br><span class="line">	B[Cur] = U;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span> (Dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> Dist);</span><br><span class="line">	<span class="built_in">memset</span> (Vis, <span class="number">0</span>, <span class="keyword">sizeof</span> Vis);</span><br><span class="line">	Dist[S] = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">	Q.push(S);</span><br><span class="line">	<span class="keyword">while</span> (!Q.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> Now = Q.front();</span><br><span class="line">		Vis[Now] = <span class="number">0</span>;</span><br><span class="line">		Q.pop();</span><br><span class="line">		<span class="keyword">if</span> (Plus[Now]) Dist[Now] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = Head[Now]; i; i = Next[i])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (Dist[E[i]] &lt;= Dist[Now] + W[i]) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span> (Dist[Now] + W[i] &gt; C) <span class="keyword">continue</span>;</span><br><span class="line">			Dist[E[i]] = Dist[Now] + W[i];</span><br><span class="line">			<span class="keyword">if</span> (!Vis[E[i]]) Q.push(E[i]), Vis[E[i]] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">BSPFA</span><span class="params">(<span class="keyword">int</span> S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span> (Bist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> Bist);</span><br><span class="line">	<span class="built_in">memset</span> (Vis, <span class="number">0</span>, <span class="keyword">sizeof</span> Vis);</span><br><span class="line">	Bist[S] = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">	Q.push(S);</span><br><span class="line">	<span class="keyword">while</span> (!Q.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> Now = Q.front();</span><br><span class="line">		Vis[Now] = <span class="number">0</span>;</span><br><span class="line">		Q.pop();</span><br><span class="line">		<span class="keyword">if</span> (Plus[Now]) Bist[Now] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = Bead[Now]; i; i = Bext[i])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (Bist[B[i]] &lt;= Bist[Now] + W[i]) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span> (Bist[Now] + W[i] &gt; C) <span class="keyword">continue</span>;</span><br><span class="line">			Bist[B[i]] = Bist[Now] + W[i];</span><br><span class="line">			<span class="keyword">if</span> (!Vis[B[i]]) Q.push(B[i]), Vis[B[i]] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span> (<span class="string">"%d %d %d"</span>, &amp;N, &amp;M, &amp;C);</span><br><span class="line">	<span class="keyword">while</span> (M--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span> (<span class="string">"%d %d %d"</span>, &amp;U, &amp;V, &amp;L);</span><br><span class="line">		AddEdge(U, V, L);</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="built_in">scanf</span> (<span class="string">"%d"</span>, &amp;P);</span><br><span class="line">	<span class="keyword">while</span> (P--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span> (<span class="string">"%d"</span>, &amp;U);</span><br><span class="line">		Plus[U] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">scanf</span> (<span class="string">"%d"</span>, &amp;P);</span><br><span class="line">	SPFA(<span class="number">1</span>), BSPFA(N);</span><br><span class="line">	<span class="keyword">if</span> (Dist[N] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"-1"</span>) &amp; <span class="number">0</span>; </span><br><span class="line">	<span class="keyword">while</span> (P--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span> (<span class="string">"%d %d"</span>, &amp;U, &amp;L);</span><br><span class="line">		<span class="keyword">if</span> (Plus[U]) Ans = max(Ans, C * L);</span><br><span class="line">		<span class="keyword">else</span> Ans = max(Ans, L * (C - Dist[U] - Bist[U]));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span> (<span class="string">"%d\n"</span>, Ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T3-chase"><a href="#T3-chase" class="headerlink" title="T3 chase"></a>T3 chase</h1><p>就是用总的减去不合法的</p>
<p>不合法的就是达不到$2048$的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">1e5</span> + <span class="number">10</span>, Mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">int</span> N, Temp, T[<span class="number">20</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>, <span class="number">256</span>, <span class="number">512</span>, <span class="number">1024</span>, <span class="number">2048</span>&#125;;</span><br><span class="line">ll Fac[Maxn] = &#123;<span class="number">1</span>&#125;, Inv[Maxn], C[Maxn] = &#123;<span class="number">1</span>&#125;, F[Maxn], Cnt[Maxn];</span><br><span class="line"><span class="keyword">bool</span> Vis[Maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll X, <span class="keyword">int</span> Y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">ll <span class="title">Ans</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (Y)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (Y &amp; <span class="number">1</span>) Ans = Ans * X % Mod;</span><br><span class="line">		X = X * X % Mod;</span><br><span class="line">		Y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="built_in">scanf</span> (<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i(<span class="number">0</span>); T[i]; ++i) Vis[T[i]] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100000</span>; ++i) Fac[i] = Fac[i - <span class="number">1</span>] * i % Mod;</span><br><span class="line">	Inv[<span class="number">100000</span>] = Pow(Fac[<span class="number">100000</span>], Mod - <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">99999</span>; i &gt;= <span class="number">0</span>; --i) Inv[i] = Inv[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % Mod;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span> (<span class="string">"%d"</span>, &amp;Temp);</span><br><span class="line">		<span class="keyword">if</span> (!Vis[Temp]) Temp = <span class="number">0</span>;</span><br><span class="line">		Cnt[Temp]++;</span><br><span class="line">	&#125;</span><br><span class="line">	F[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2047</span>; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">		<span class="keyword">if</span> (Cnt[i])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> j = Cnt[i];</span><br><span class="line">			<span class="keyword">if</span> (<span class="number">2048</span> / i &lt; j) j = <span class="number">2048</span> / i;</span><br><span class="line">			<span class="keyword">for</span> (; j &gt;= <span class="number">0</span>; --j) C[j] = Fac[Cnt[i]] * Inv[Cnt[i] - j] % Mod * Inv[j] % Mod;</span><br><span class="line">			<span class="keyword">for</span> (j = <span class="number">2047</span>; j &gt;= <span class="number">0</span>; --j)</span><br><span class="line">				<span class="keyword">if</span> (F[j])</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= Cnt[i]; ++k)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="keyword">int</span> L = j + i * k;</span><br><span class="line">						<span class="keyword">if</span> (L &gt;= <span class="number">2048</span>) <span class="keyword">break</span>;</span><br><span class="line">						F[L] = (F[L] + F[j] * C[k]) % Mod;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">					</span><br><span class="line">		&#125;</span><br><span class="line">	ll Ans = Pow(<span class="number">2</span>, N);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2048</span>; ++i) Ans = (Ans - F[i] * Pow(<span class="number">2</span>, Cnt[<span class="number">0</span>]) % Mod + Mod) % Mod;</span><br><span class="line">	<span class="built_in">printf</span> (<span class="string">"%lld\n"</span>, Ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>图论</tag>
        <tag>考试</tag>
      </tags>
  </entry>
  <entry>
    <title>T20200901</title>
    <url>/2020/09/01/T20200901/</url>
    <content><![CDATA[

	<div class="row">
    <embed src="problem.pdf" width="100%" height="550" type="application/pdf">
	</div>



<h1 id="T1-锻造-forging"><a href="#T1-锻造-forging" class="headerlink" title="T1 锻造(forging)"></a>T1 锻造(forging)</h1><p>就是一期望$\text{Dp}$</p>
<script type="math/tex; mode=display">
\begin{align*}
f(i)&=f(i-1)+f(i-2)+(1-K)(f(i)-f(i-2))\\
f(i)&=f(i-1)+f(i-2)+f(i)-f(i-2)-Kf(i)+Kf(i-2)\\
Kf(i)&=f(i-1)+Kf(i-2)\\
f(i)&=\frac{c_{i-1}}kf(i-1)+f(i-2)
\end{align*}</script><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">1e7</span> + <span class="number">15</span>, Mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">int</span> n, a;</span><br><span class="line"><span class="keyword">int</span> bx, by, cx, cy, p;</span><br><span class="line"><span class="keyword">int</span> b[Maxn], c[Maxn], f[Maxn], inv[Maxn] = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span> (<span class="string">"%d %d"</span>, &amp;n, &amp;a);</span><br><span class="line">	<span class="built_in">scanf</span> (<span class="string">"%d %d %d %d %d"</span>, &amp;bx, &amp;by, &amp;cx, &amp;cy,&amp;p);</span><br><span class="line">	b[n] = b[<span class="number">0</span>] = by + <span class="number">1</span>, c[n] = c[<span class="number">0</span>] = cy + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		b[i] = (<span class="number">1l</span>l * b[i - <span class="number">1</span>] * bx + by) % p + <span class="number">1</span>; b[n] = max(b[i], b[n]);</span><br><span class="line">		c[i] = (<span class="number">1l</span>l * c[i - <span class="number">1</span>] * cx + cy) % p + <span class="number">1</span>; c[n] = max(c[i], c[n]);</span><br><span class="line">	&#125;</span><br><span class="line">	b[n] = max(b[n], c[n]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= b[n]; ++i) inv[i] = <span class="number">1l</span>l * (Mod - Mod / i) * inv[Mod % i] % Mod;</span><br><span class="line">	f[<span class="number">0</span>] = a, f[<span class="number">1</span>] = (<span class="number">1l</span>l * inv[min(c[<span class="number">0</span>], b[<span class="number">0</span>])] * c[<span class="number">0</span>] % Mod * f[<span class="number">0</span>] % Mod + f[<span class="number">0</span>]) % Mod;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) f[i] = (<span class="number">1l</span>l * inv[min(c[i - <span class="number">1</span>], b[i - <span class="number">2</span>])] * c[i - <span class="number">1</span>] % Mod * f[i - <span class="number">1</span>] % Mod + f[i - <span class="number">2</span>]) % Mod;</span><br><span class="line">	<span class="built_in">printf</span> (<span class="string">"%d\n"</span>, f[n] % Mod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T2-整除-division"><a href="#T2-整除-division" class="headerlink" title="T2  整除(division)"></a>T2  整除(division)</h1><p>$n|x^m-x$，求在$[1,n]$有多少个解</p>
<p>考虑乱搞一下式子</p>
<script type="math/tex; mode=display">
x^m-x=kn\\
x^m\equiv x\pmod n</script><p>然后$\text{n}$又是一个无平方因子数</p>
<p>所以时可以拆开乱搞的</p>
<p>对$\text{n}$的每个因子进行一次操作，把答案乘起来即可</p>
<p>这个严格的证明应该是同余方程之类的东西？</p>
<p><del>做题的话其实是可以猜结论的</del></p>
<h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">1e4</span>, Mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">int</span> ID, T;</span><br><span class="line"><span class="keyword">int</span> C, M, Tmp;</span><br><span class="line"><span class="keyword">int</span> Pr[Maxn + <span class="number">10</span>], Pw[Maxn + <span class="number">10</span>];</span><br><span class="line"><span class="keyword">bool</span> Vis[Maxn + <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">X</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">char</span> <span class="title">O</span><span class="params">(getchar())</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (O &lt; <span class="string">'0'</span> || O &gt; <span class="string">'9'</span>) O = getchar();</span><br><span class="line">	<span class="keyword">for</span> (; O &gt;= <span class="string">'0'</span> &amp;&amp; O &lt;= <span class="string">'9'</span>; O = getchar()) X = (X &lt;&lt; <span class="number">1</span>) + (X &lt;&lt; <span class="number">3</span>) + (O ^ <span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> X;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= Maxn; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!Vis[i]) Pr[++Pr[<span class="number">0</span>]] = i;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= Pr[<span class="number">0</span>] &amp;&amp; i * Pr[j] &lt;= Maxn; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			Vis[i * Pr[j]] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (i % Pr[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> X, <span class="keyword">int</span> Y, <span class="keyword">int</span> Mod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">Ans</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (Y)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (Y &amp; <span class="number">1</span>) Ans = <span class="number">1l</span>l * Ans * X % Mod;</span><br><span class="line">		X = X * X % Mod;</span><br><span class="line">		Y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Ans % Mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">GetAns</span><span class="params">(<span class="keyword">int</span> M, <span class="keyword">int</span> P)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Pw[<span class="number">1</span>]= <span class="number">1</span>, Pw[P] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; P; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!Vis[i]) Pw[i] = Pow(i, M, P);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= Pr[<span class="number">0</span>] &amp;&amp; i * Pr[j] &lt;= P; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			Pw[i * Pr[j]] = Pw[i] * Pw[Pr[j]] % P;</span><br><span class="line">			<span class="keyword">if</span> (i % P == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; P; ++i)</span><br><span class="line">		<span class="keyword">if</span> (Pw[i] == i) ++Pw[P];</span><br><span class="line">	<span class="keyword">return</span> Pw[P];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	freopen (<span class="string">"division.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">	freopen (<span class="string">"division.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">	Init();</span><br><span class="line">	ID = Read(), T = Read();</span><br><span class="line">	<span class="keyword">while</span> (T--)</span><br><span class="line">	&#123;</span><br><span class="line">		 C = Read(), M = Read();</span><br><span class="line">		 <span class="function"><span class="keyword">int</span> <span class="title">Ans</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">		 <span class="keyword">while</span> (C--) Ans = <span class="number">1l</span>l * Ans * GetAns(M, Read()) % Mod;</span><br><span class="line">		 <span class="built_in">printf</span> (<span class="string">"%d\n"</span>, Ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T3-欠钱-money"><a href="#T3-欠钱-money" class="headerlink" title="T3 欠钱(money)"></a>T3 欠钱(money)</h1><p>树上启发式合并</p>
<p>有根树$LCT$</p>
<p>鸽着？</p>
<h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><p>$\text{YJYX}$巨佬的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(int i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(int i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR_SIDE(i,A) for(int i=Head[A];i;i=Next[i])</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>,MAXM=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Last,Total,Test;</span><br><span class="line"><span class="keyword">int</span> Next[MAXM&lt;&lt;<span class="number">1</span>],End[MAXM&lt;&lt;<span class="number">1</span>],Head[MAXN],Val[MAXM&lt;&lt;<span class="number">1</span>],Kind[MAXM&lt;&lt;<span class="number">1</span>],Cur;</span><br><span class="line"><span class="keyword">int</span> Root[MAXN],Dep[MAXN],Size[MAXN];</span><br><span class="line"><span class="keyword">int</span> Anc[MAXN][<span class="number">20</span>],Min[MAXN][<span class="number">20</span>],Dir[MAXN][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> u,v,w,Opt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"money.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"money.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> New,<span class="keyword">int</span> Pre,<span class="keyword">int</span> Top)</span> </span>&#123;</span><br><span class="line">	Root[New]=Top;</span><br><span class="line">	Dep[New]=Dep[Pre]+<span class="number">1</span>;</span><br><span class="line">	FOR(i,<span class="number">1</span>,<span class="number">17</span>) &#123;</span><br><span class="line">		Anc[New][i]=Anc[Anc[New][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">		Min[New][i]=min(Min[New][i<span class="number">-1</span>],Min[Anc[New][i<span class="number">-1</span>]][i<span class="number">-1</span>]);</span><br><span class="line">		Dir[New][i]=(Dir[New][i<span class="number">-1</span>] | Dir[Anc[New][i<span class="number">-1</span>]][i<span class="number">-1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	FOR_SIDE(i,New) &#123;</span><br><span class="line">		<span class="keyword">if</span>(End[i]==Pre) <span class="keyword">continue</span>;</span><br><span class="line">		Anc[End[i]][<span class="number">0</span>]=New;</span><br><span class="line">		Min[End[i]][<span class="number">0</span>]=Val[i];</span><br><span class="line">		Dir[End[i]][<span class="number">0</span>]=(Kind[i] ^ <span class="number">3</span>);</span><br><span class="line">		DFS(End[i],New,Top);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add_Edge</span><span class="params">(<span class="keyword">int</span> From,<span class="keyword">int</span> To,<span class="keyword">int</span> Temp)</span> </span>&#123;</span><br><span class="line">	Next[++Cur]=Head[From];</span><br><span class="line">	Head[From]=Cur;</span><br><span class="line">	End[Cur]=To;</span><br><span class="line">	Val[Cur]=Temp;</span><br><span class="line">	Kind[Cur]=<span class="number">1</span>;</span><br><span class="line">	Next[++Cur]=Head[To];</span><br><span class="line">	Head[To]=Cur;</span><br><span class="line">	End[Cur]=From;</span><br><span class="line">	Val[Cur]=Temp;</span><br><span class="line">	Kind[Cur]=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Update</span><span class="params">(<span class="keyword">int</span> From,<span class="keyword">int</span> To,<span class="keyword">int</span> Temp)</span> </span>&#123;</span><br><span class="line">	Add_Edge(From,To,Temp);</span><br><span class="line">	<span class="keyword">int</span> Base=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(Size[Root[From]]&gt;Size[Root[To]]) Base=<span class="number">2</span>,swap(From,To);</span><br><span class="line">	Size[Root[To]]+=Size[Root[From]];</span><br><span class="line">	Anc[From][<span class="number">0</span>]=To;</span><br><span class="line">	Min[From][<span class="number">0</span>]=Temp;</span><br><span class="line">	Dir[From][<span class="number">0</span>]=Base;</span><br><span class="line">	DFS(From,To,Root[To]);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Get</span><span class="params">(<span class="keyword">int</span> From,<span class="keyword">int</span> To)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> Base=<span class="number">1</span>,Ans=INF;</span><br><span class="line">	<span class="keyword">if</span>(Dep[From]&lt;Dep[To]) Base=<span class="number">2</span>,swap(From,To);</span><br><span class="line">	BOR(i,<span class="number">17</span>,<span class="number">0</span>) </span><br><span class="line">		<span class="keyword">if</span>(Dep[From]-(<span class="number">1</span>&lt;&lt;i)&gt;=Dep[To]) &#123;</span><br><span class="line">			<span class="keyword">if</span>(Dir[From][i]!=Base) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			Ans=min(Ans,Min[From][i]);</span><br><span class="line">			From=Anc[From][i];</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">if</span>(From==To) <span class="keyword">return</span> Ans;</span><br><span class="line">	BOR(i,<span class="number">17</span>,<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(Anc[From][i]!=Anc[To][i]) &#123;</span><br><span class="line">			<span class="keyword">if</span>(Dir[From][i]!=Base || Dir[To][i]!=(Base ^ <span class="number">3</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			Ans=min(Ans,min(Min[From][i],Min[To][i]));</span><br><span class="line">			From=Anc[From][i]; </span><br><span class="line">			To=Anc[To][i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(Dir[From][<span class="number">0</span>]!=Base || Dir[To][<span class="number">0</span>]!=(Base ^ <span class="number">3</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	Ans=min(Ans,min(Min[From][<span class="number">0</span>],Min[To][<span class="number">0</span>]));</span><br><span class="line">	<span class="keyword">return</span> Ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	File();</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;Total,&amp;Test);</span><br><span class="line">	FOR(i,<span class="number">1</span>,Total) Root[i]=i,Size[i]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(Test--) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;Opt,&amp;u,&amp;v);</span><br><span class="line">		u=(u+Last)%Total+<span class="number">1</span>;</span><br><span class="line">		v=(v+Last)%Total+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(Opt==<span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;w);</span><br><span class="line">			w=(w+Last)%Total+<span class="number">1</span>;</span><br><span class="line">			Update(u,v,w);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123; <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,Last=Get(u,v)); &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数学</tag>
        <tag>鸽~</tag>
        <tag>考试</tag>
        <tag>期望Dp</tag>
        <tag>启发式合并</tag>
      </tags>
  </entry>
  <entry>
    <title>T20200902</title>
    <url>/2020/09/02/T20200902/</url>
    <content><![CDATA[

	<div class="row">
    <embed src="problem.pdf" width="100%" height="550" type="application/pdf">
	</div>



<h1 id="T1-石头剪刀布-rps"><a href="#T1-石头剪刀布-rps" class="headerlink" title="T1 石头剪刀布(rps)"></a>T1 石头剪刀布(rps)</h1><p>那么，我们就枚举最后赢得人是谁</p>
<p>然后归并保证字典序最小</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, _a[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> s[] = <span class="string">"RPS"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">Get</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!n) &#123;</span><br><span class="line">		<span class="built_in">string</span> ans;</span><br><span class="line">		ans.push_back(s[x]);</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">string</span> a = Get(n - <span class="number">1</span>, x), b = Get(n - <span class="number">1</span>, (x + <span class="number">1</span>) % <span class="number">3</span>);</span><br><span class="line">	<span class="keyword">return</span> a &lt; b ? a + b : b + a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Check</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">3</span>] = &#123;&#125;, a0[<span class="number">3</span>] = &#123;&#125;;</span><br><span class="line">	a[x] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">2</span>; ++j) a0[j] = a[j];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">2</span>; ++j) a[(j + <span class="number">1</span>) % <span class="number">3</span>] += a0[j];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">2</span>; ++i) <span class="keyword">if</span> (a[i] != _a[i]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; Get(n, x) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span> (<span class="string">"%d %d %d"</span>, _a + <span class="number">0</span>, _a + <span class="number">1</span>, _a + <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">while</span> ((<span class="number">1</span> &lt;&lt; n) != _a[<span class="number">0</span>] + _a[<span class="number">1</span>] + _a[<span class="number">2</span>]) ++n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">2</span>; ++i)</span><br><span class="line">		<span class="keyword">if</span> (Check(i)) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"IMPOSSIBLE"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T2-投票-vote"><a href="#T2-投票-vote" class="headerlink" title="T2 投票(vote)"></a>T2 投票(vote)</h1><p>将 $p_i$ 从小到大排好序，则存在一个最优方案，其中选择的同学是一段前缀和一段后缀</p>
<blockquote>
<p>  证明：</p>
<p>  ​    假设有一个选择的同学，他前后都存在未选的同学，考虑固定其他选中的同学时这个同学的概率的贡献，是一个一次函数，所以换成前后一定不劣。</p>
<p>  Q.E.D</p>
</blockquote>
<p>现在的问题是，对 $\forall i$，求出选择前$i$个和后$k-i$个时平票的概率</p>
<p>一个想法是支持插入删除的 $dp$，但有精度问题</p>
<p>$pre<em>{i,j},\;suf</em>{i,j}$表示选择前/后$i$个同学，有 个投”好”的概率</p>
<p>时间复杂度$O(n)$</p>
<h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">2000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"><span class="keyword">double</span> p[Maxn], ans;</span><br><span class="line"><span class="keyword">double</span> Pre[Maxn][Maxn], Suf[Maxn][Maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span> (<span class="string">"%d %d"</span>, &amp;n, &amp;k);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span> (<span class="string">"%lf"</span>, p + i);</span><br><span class="line">	sort (p + <span class="number">1</span>, p + n + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	Pre[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &gt;= <span class="number">1</span>; --j) Pre[i][j] = p[i] * Pre[i - <span class="number">1</span>][j - <span class="number">1</span>] + (<span class="number">1</span> - p[i]) * Pre[i - <span class="number">1</span>][j];</span><br><span class="line">		Pre[i][<span class="number">0</span>] = (<span class="number">1</span> - p[i]) * Pre[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Suf[n + <span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &gt;= <span class="number">1</span>; --j) Suf[i][j] = p[i] * Suf[i + <span class="number">1</span>][j - <span class="number">1</span>] + (<span class="number">1</span> - p[i]) * Suf[i + <span class="number">1</span>][j];</span><br><span class="line">		Suf[i][<span class="number">0</span>] = (<span class="number">1</span> - p[i]) * Suf[i + <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	m = k &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> j = n + i + <span class="number">1</span> - k;</span><br><span class="line">		<span class="function"><span class="keyword">double</span> <span class="title">temp</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt;= k; ++t) temp += Pre[i][t] * Suf[j][m - t];</span><br><span class="line">		ans = max(ans, temp);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span> (<span class="string">"%.9f"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T3-工厂-factory"><a href="#T3-工厂-factory" class="headerlink" title="T3 工厂(factory)"></a>T3 工厂(factory)</h1><p><del>还没有改</del></p>
<p>首先把问题转化为二分图模型，左边 $n$ 个点表示工人，右边 $n$ 个点表示机器，左右两个点有边当且仅当对应工人会操作对应机器。无论哪种情况下所有机器都能有人操作，就等价于，任意一个极大匹配都是完美匹配</p>
<p>考虑问题的一个弱化版本：判断是否任意一个极大匹配都是完美匹配</p>
<p>观察发现，任意一个极大匹配都是完美匹配$(a)$ ，如果任意一个联通块都是左右点数相等的完全二分图$(b)$。</p>
<p>证明：</p>
<p>从$b$推出$a$是显然的，下面只用证明从$a$推出$b$。</p>
<p>反证法。</p>
<p>假设存在一张二分图，存在一个联通块不是左右点数相等的完全二分图，同时满足任意一个极大匹配都是完美匹配。如果这个联通块左右点数不相等，那么它就不存在完美匹配，显然矛盾。否则这个联通块不是完全二分图，设左边的$a$点和右边的$b$点之间没有边，随便找一条从$a$到$b$的简单路径，记作$p$。选择$p$上的奇数边，再随便选一些边构造一个极大匹配，那么这个极大匹配必定是完美匹配。把奇数边改成偶数边，其他的边不变，那么除了$a,b$以外的点都在匹配上，所以得到了一个非完美匹配的极大匹配，矛盾。</p>
<p>Q.E.D.</p>
<p>回到原问题，对每个联通块求出它在左右的点数，记作$(x<em>i, y_i)$ ，现在的问题相当于，将 $(x_i,y_i)$ 分成若干个集合，$\forall s$ 满足$\sum</em>{i\in s}x<em>i=\sum</em>{i\in s}y<em>i$，最小化 $\sum_s(\sum</em>{i\in s}x_i)^2$。</p>
<p>状压 $dp$。 $dp_{s,i}$表示集合 中已经划出的满足要求的集合的 $\sum x=i$ 的最小代价。</p>
<p>转移就枚举 $x$，从$dp<em>s$ 转移到 $dp</em>{s\cup{x}}$。</p>
<p>对所有相同的 $(x_i,y_i)$ 只用关心个数，当 $n=30$ 时，本质不同的集合个数的最大值是 $173032$ ，可以通过本题。</p>
<h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">chmin</span><span class="params">(T &amp;x,<span class="keyword">const</span> T &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;y)x=y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,l,r) for(int i=l;i&lt;=r;++i)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">30</span>+<span class="number">2</span>,U=<span class="number">2e5</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> s[N][N];</span><br><span class="line"><span class="keyword">int</span> dp[U][N];</span><br><span class="line">pii q[N*<span class="number">2</span>];<span class="keyword">int</span> m,cnt[N*<span class="number">2</span>],w[N*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[N*<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">pii <span class="keyword">operator</span> +(<span class="keyword">const</span> pii &amp;a,<span class="keyword">const</span> pii &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> pii(a.first+b.first,a.second+b.second);</span><br><span class="line">&#125;</span><br><span class="line">pii <span class="keyword">operator</span> *(<span class="keyword">const</span> pii &amp;a,<span class="keyword">int</span> x)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> pii(a.first*x,a.second*x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span> +=(pii &amp;a,<span class="keyword">const</span> pii &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">	a=a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sqr</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x*x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">		rep(i,<span class="number">1</span>,n)<span class="built_in">scanf</span>(<span class="string">"%s"</span>,s[i]+<span class="number">1</span>);</span><br><span class="line">		m=<span class="number">0</span>;</span><br><span class="line">		rep(i,<span class="number">1</span>,n*<span class="number">2</span>)vis[i]=<span class="number">0</span>;</span><br><span class="line">		rep(i,<span class="number">1</span>,n*<span class="number">2</span>)</span><br><span class="line">		<span class="keyword">if</span>(!vis[i])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;nq;</span><br><span class="line">			<span class="keyword">auto</span> push=[&amp;](<span class="keyword">int</span> x) &#123; <span class="keyword">if</span>(!vis[x])&#123;nq.push_back(x);vis[x]=<span class="number">1</span>;&#125; &#125;; </span><br><span class="line">			push(i);</span><br><span class="line">			pii now=pii(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">			<span class="keyword">while</span>(!nq.empty())</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> x=nq.front();nq.pop_front();</span><br><span class="line">				<span class="keyword">if</span>(x&lt;=n)</span><br><span class="line">				&#123;</span><br><span class="line">					++now.first;</span><br><span class="line">					rep(y,<span class="number">1</span>,n)</span><br><span class="line">					<span class="keyword">if</span>(s[x][y]==<span class="string">'1'</span>)push(y+n);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					++now.second;</span><br><span class="line">					rep(y,<span class="number">1</span>,n)</span><br><span class="line">					<span class="keyword">if</span>(s[y][x-n]==<span class="string">'1'</span>)push(y);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			q[++m]=now;</span><br><span class="line">		&#125;</span><br><span class="line">		sort(q+<span class="number">1</span>,q+m+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">int</span> m0=m;m=<span class="number">1</span>;</span><br><span class="line">		cnt[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">		rep(i,<span class="number">2</span>,m0)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(q[i]==q[m])++cnt[m];</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				q[++m]=q[i];</span><br><span class="line">				cnt[m]=<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; </span><br><span class="line">		w[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">		rep(i,<span class="number">2</span>,m+<span class="number">1</span>)w[i]=w[i<span class="number">-1</span>]*(cnt[i<span class="number">-1</span>]+<span class="number">1</span>);</span><br><span class="line">		rep(s,<span class="number">0</span>,w[m+<span class="number">1</span>]<span class="number">-1</span>)</span><br><span class="line">		rep(i,<span class="number">0</span>,n)dp[s][i]=N*N;</span><br><span class="line">		dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">cerr</span>&lt;&lt;w[m+<span class="number">1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		rep(s,<span class="number">0</span>,w[m+<span class="number">1</span>]<span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			pii sum=pii(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">			rep(i,<span class="number">1</span>,m)sum+=q[i]*(s%w[i+<span class="number">1</span>]/w[i]);</span><br><span class="line">			<span class="keyword">if</span>(sum.first==sum.second)</span><br><span class="line">			&#123;</span><br><span class="line">				rep(i,<span class="number">0</span>,sum.first<span class="number">-1</span>)chmin(dp[s][sum.first],dp[s][i]+sqr(sum.first-i));</span><br><span class="line">			&#125;</span><br><span class="line">			rep(i,<span class="number">1</span>,m)</span><br><span class="line">			<span class="keyword">if</span>(s%w[i+<span class="number">1</span>]/w[i]&lt;cnt[i])</span><br><span class="line">			rep(j,<span class="number">0</span>,n)chmin(dp[s+w[i]][j],dp[s][j]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">		rep(i,<span class="number">1</span>,n)</span><br><span class="line">		rep(j,<span class="number">1</span>,n)sum+=s[i][j]==<span class="string">'1'</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp[w[m+<span class="number">1</span>]<span class="number">-1</span>][n]-sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数学</tag>
        <tag>鸽~</tag>
        <tag>考试</tag>
        <tag>概率</tag>
      </tags>
  </entry>
  <entry>
    <title>T20200903赛后总结(转载)</title>
    <url>/2020/09/03/T20200903(%E8%BD%AC%E8%BD%BD)/</url>
    <content><![CDATA[<h2 id="特别鸣谢：DeNeRATe"><a href="#特别鸣谢：DeNeRATe" class="headerlink" title="特别鸣谢：DeNeRATe"></a>特别鸣谢：<a href="https://denerate-cool.github.io/DeNeRATe.github.io/" target="_blank" rel="noopener">DeNeRATe</a></h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次是真的全考<strong>数学</strong>了<strong>/kk</strong></p>
<p><strong>死磕T1</strong>，结果自我感觉最难的就是T1了。。。</p>
<p>最后直接<strong>雪崩</strong>。。。</p>
<p><img src="https://i.loli.net/2020/09/03/AqSZ17Qp6j28UWe.gif" alt="T20200903-1.gif"></p>
<h2 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h2><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p><strong>构造</strong></p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/09/03/VrWSsyaoKw95gX6.png" alt="T20200903-A.png"></p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><hr>
<p>我们先考虑<strong>弱化版</strong>：</p>
<script type="math/tex; mode=display">
Ans = \sum^{n}_{i=1} \sum^{n}_{j=i+1} \sum^{n}_{k=j+1} (A_i \bigoplus A_j) \times (A_j \bigoplus A_k)</script><p>发现，非常简单，<strong>化简一下</strong></p>
<script type="math/tex; mode=display">
Ans = \sum^{n}_{j=1} \sum^{j-1}_{i=1} \sum^{n}_{k=j+1} (A_i \bigoplus A_j) \times (A_j \bigoplus A_k) \\
=\sum^{n}_{j=1} \left( \sum^{j-1}_{i=1} A_i \bigoplus A_j \right) \times \left( \sum^{n}_{k=j+1} A_j \bigoplus A_k \right)</script><p>我们令</p>
<script type="math/tex; mode=display">
L[j] = \sum^{j-1}_{i=1} A_i \bigoplus A_j \\
R[j] = \sum^{n}_{k=j+1} A_j \bigoplus A_k</script><p>所以我们可以得到</p>
<script type="math/tex; mode=display">
Ans = \sum^{n}_{j=1} L[j] \times R[j]</script><p>我们进而化简</p>
<p>设，$ Bit(i,j) $表示$i$的第$j$位是$ 1/0 $</p>
<script type="math/tex; mode=display">
L[j] = \sum^{30}_{k=0} 2^k \times \sum^{j-1}_{i=0} [Bit(A_j,k) \neq Bit(A_i,k)] \\
R[j] = \sum^{30}_{k=0} 2^k \times \sum^{n}_{i=j+1} [Bit(A_j,k) \neq Bit(A_i,k)]</script><hr>
<p>有了上边的<strong>基础</strong></p>
<p>对于<strong>升级版</strong></p>
<p>我们就可以<strong>轻松切了</strong></p>
<p>（当时推到这儿了，结果还是没有维护出来。。。<strong>wtcl</strong>）</p>
<script type="math/tex; mode=display">
Ans = \sum_{i<j<k} (A_i \bigoplus A_j) \times (A_j \bigoplus A_k) \times (A_i \bigoplus A_k) \\
= \sum_{i<j<k} (A_i \bigoplus A_j) \times (A_j \bigoplus A_k) \times \sum^{30}_{b=0} 2^b \times (Bit(A_i,b) \neq Bit(A_k,b)) \\
= \sum^{30}_{b=0} 2^b \times \sum_{i<j<K} (A_i \bigoplus A_j) \times (A_j \bigoplus A_k) \times (Bit(A_i,b) \neq Bit(A_k,b))</script><p>所以，我们只需要枚举$ Bit(A_i,b) \neq Bit(A_k,b) $时的<strong>每一位</strong>即可统计答案</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><strong>吐槽一下：</strong>实现是真的<strong>闹心</strong>。。。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//xor </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(LL i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(LL i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> LL MAXN=<span class="number">2e5</span>+<span class="number">10</span>,Limit=<span class="number">35</span>;</span><br><span class="line"></span><br><span class="line">LL Total,Num[MAXN],Ans;</span><br><span class="line">LL L[MAXN][<span class="number">2</span>],R[MAXN][<span class="number">2</span>];</span><br><span class="line">LL Suf[Limit][<span class="number">2</span>][<span class="number">2</span>],Pre[Limit][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">LL Two[Limit]=&#123;<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"xor.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"xor.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Solve</span><span class="params">(LL Temp)</span> </span>&#123;</span><br><span class="line">	Cl(Suf,<span class="number">0</span>);</span><br><span class="line">	FOR(i,<span class="number">1</span>,Total) &#123;</span><br><span class="line">		L[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">		L[i][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">		FOR(j,<span class="number">0</span>,<span class="number">30</span>) &#123;</span><br><span class="line">			LL Loc=((Num[i] &amp; (<span class="number">1</span>&lt;&lt;j))&gt;<span class="number">0</span>);</span><br><span class="line">			(L[i][<span class="number">0</span>]+=Suf[j][Loc ^ <span class="number">1</span>][<span class="number">0</span>])%=MOD;</span><br><span class="line">			(L[i][<span class="number">1</span>]+=Suf[j][Loc ^ <span class="number">1</span>][<span class="number">1</span>])%=MOD;</span><br><span class="line">		&#125;</span><br><span class="line">		LL Bit=((Num[i] &amp; (<span class="number">1</span>&lt;&lt;Temp))&gt;<span class="number">0</span>);</span><br><span class="line">		FOR(j,<span class="number">0</span>,<span class="number">30</span>) &#123;</span><br><span class="line">			LL Loc=((Num[i] &amp; (<span class="number">1</span>&lt;&lt;j))&gt;<span class="number">0</span>);</span><br><span class="line">			(Suf[j][Loc][Bit]+=Two[j])%=MOD;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	Cl(Pre,<span class="number">0</span>);</span><br><span class="line">	BOR(i,Total,<span class="number">1</span>) &#123;</span><br><span class="line">		R[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">		R[i][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">		FOR(j,<span class="number">0</span>,<span class="number">30</span>) &#123;</span><br><span class="line">			LL Loc=((Num[i] &amp; (<span class="number">1</span>&lt;&lt;j))&gt;<span class="number">0</span>);</span><br><span class="line">			(R[i][<span class="number">0</span>]+=Pre[j][Loc ^ <span class="number">1</span>][<span class="number">0</span>])%=MOD;</span><br><span class="line">			(R[i][<span class="number">1</span>]+=Pre[j][Loc ^ <span class="number">1</span>][<span class="number">1</span>])%=MOD;</span><br><span class="line">		&#125;</span><br><span class="line">		LL Bit=((Num[i] &amp; (<span class="number">1</span>&lt;&lt;Temp))&gt;<span class="number">0</span>);</span><br><span class="line">		FOR(j,<span class="number">0</span>,<span class="number">30</span>) &#123;</span><br><span class="line">			LL Loc=((Num[i] &amp; (<span class="number">1</span>&lt;&lt;j))&gt;<span class="number">0</span>);</span><br><span class="line">			(Pre[j][Loc][Bit]+=Two[j])%=MOD;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	LL Res=<span class="number">0</span>;</span><br><span class="line">	FOR(i,<span class="number">1</span>,Total) &#123;</span><br><span class="line">		LL Val=(L[i][<span class="number">0</span>]*R[i][<span class="number">1</span>]+L[i][<span class="number">1</span>]*R[i][<span class="number">0</span>])%MOD;</span><br><span class="line">		(Res+=(Val*Two[Temp]))%=MOD;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Res%MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">File</span>();</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;Total);</span><br><span class="line">	FOR(i,<span class="number">1</span>,<span class="number">30</span>) Two[i]=Two[i<span class="number">-1</span>]*<span class="number">2</span>%MOD;</span><br><span class="line">	FOR(i,<span class="number">1</span>,Total) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;Num[i]);</span><br><span class="line">	FOR(Loc,<span class="number">0</span>,<span class="number">30</span>) (Ans+=Solve(Loc))%=MOD;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,Ans%MOD);</span><br><span class="line">	fclose(<span class="built_in">stdin</span>);</span><br><span class="line">	fclose(<span class="built_in">stdout</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h2><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><p><strong>动态规划+构造</strong></p>
<h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/09/03/ocVUwvBbyXCkKgZ.png" alt="T20200903-B.png"></p>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p><strong>吐槽一下：</strong>由于我把题读错了？导致对着<strong>题解</strong>搞了好久</p>
<p>我们如果直接枚举$n,k$状态，那么算重是一定的了</p>
<p>所以，我们需要<strong>枚举每一个数选的个数</strong></p>
<p>自然，我们就可以设计出状态<code>DP[i][j]</code>表示<strong>选了$i$个数，总和位$j$的集合数</strong></p>
<p>所以我们可以先求出<code>DP[i][j]</code>，最后来枚举每一个数的个数即可</p>
<p>但我们不能像通常一样枚举$i,j$，这样是$ O(n^3) $</p>
<p>我们可以考虑两种<strong>转移方式</strong>：</p>
<ul>
<li>在当前集合状态下<strong>加一个1</strong></li>
<li>将当前集合中的<strong>所有数加1</strong></li>
</ul>
<p>所以，我们的转移就是$ O(n^2) $了</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//set</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Lowbit(X) (X&amp;(-X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Lson (X&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Rson (X&lt;&lt;1|1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(LL i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(LL i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR_SIDE(i,A) for(LL i=Head[A];i;i=Next[i])</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> LL MAXN=<span class="number">5e3</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">LL DP[MAXN][MAXN],Ans;</span><br><span class="line">LL Total,Base,Limit;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"set.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"set.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Fast</span><span class="params">(LL A,LL B)</span> </span>&#123;</span><br><span class="line">	LL Res=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(B) &#123;</span><br><span class="line">		<span class="keyword">if</span>(B &amp; <span class="number">1</span>) &#123; Res=(Res*A)%MOD; &#125;</span><br><span class="line">		A=(A*A)%MOD; B&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> Res%MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">File</span>();</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld %lld %lld"</span>,&amp;Total,&amp;Limit,&amp;Base);</span><br><span class="line">	DP[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	FOR(i,<span class="number">0</span>,Limit<span class="number">-1</span>) </span><br><span class="line">		FOR(j,<span class="number">0</span>,Total) &#123;</span><br><span class="line">			(DP[i+<span class="number">1</span>][j+<span class="number">1</span>]+=DP[i][j])%=MOD;</span><br><span class="line">			<span class="keyword">if</span>(i &amp;&amp; j+i&lt;=Total) (DP[i][j+i]+=DP[i][j])%=MOD;</span><br><span class="line">		&#125;</span><br><span class="line">	FOR(i,<span class="number">1</span>,Total) &#123;</span><br><span class="line">		LL Sum=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(LL j=<span class="number">1</span>;j&lt;=(Total/i) &amp;&amp; j&lt;=Limit;j++) </span><br><span class="line">			(Sum+=DP[Limit-j][Total-i*j])%=MOD;</span><br><span class="line">		(Ans+=Sum*Fast(i,Base))%=MOD;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,Ans%MOD);</span><br><span class="line">    fclose(<span class="built_in">stdin</span>); fclose(<span class="built_in">stdout</span>);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h2><h3 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h3><p><strong>组合数学+构造</strong></p>
<h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/09/03/decQ8gDUjRNKpi6.png" alt="T20200903-C.png"></p>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>因为我们直接<strong>正面解决</strong>问题是很困难的</p>
<p>所以我们考虑计算无法满足题目要求的集合的个数，即：</p>
<ul>
<li><strong>最大值不超过$k$</strong></li>
<li><strong>所有数异或之和位0</strong></li>
</ul>
<hr>
<h4 id="引理"><a href="#引理" class="headerlink" title="引理"></a>引理</h4><p><strong>从高到低</strong>考虑，<strong>一定存在</strong>一个$A_i$满足$ Bit(A_i,j) \neq Bit(k,j) $</p>
<p>证明<strong>显然</strong>，<strong>故咕</strong></p>
<p>因为$ \forall i \in [1,n],A_i \leq k $</p>
<p>所以当存在时，<strong>当且仅当</strong>$A_i$的第$j$位为<strong>0</strong></p>
<hr>
<p>有了这个引理，这道题基本就可以<strong>宣告结束</strong>了</p>
<p>对于剩下的$n-1$个数，他们的剩下$j-1$位可以<strong>乱填</strong>都是没有问题的</p>
<p>所以我们来考虑$ Bit(A_i,j)==0 $，他的$ [0,j-1] $有$ 2^j $种情况</p>
<p>对于$ Bit(A_i,j)==1 $，他的$ [0,j-1] $有$ k \,\,\, \&amp; \,\,\, (2^j-1)+1 $</p>
<p>所以，我们可以<strong>枚举</strong>满足$ Bit(A_i,j)==0 $的数的个数</p>
<p><strong>方案数</strong>为：</p>
<script type="math/tex; mode=display">
{n \choose v} \times (2^j)^{v-1} \times (k \,\,\, \& \,\,\, (2^j-1)+1)^{n-v}</script><p>我们必须要保证$v$和$n$的<strong>奇偶性相同</strong>，才能使得最后异或和为0</p>
<p>进而，我们可以通过<strong>二项式定理</strong>来化简</p>
<p>对于$n$为<strong>偶数</strong>的情况（<strong>奇数</strong>很简单的啦）</p>
<script type="math/tex; mode=display">
Ans = (2^{-j-1}) \times \sum^{n}_{n=2} {n \choose v} \times (2^j)^v \times (k \,\,\, \& \,\,\, (2^j-1)+1)^{n-v} \times ((-1)^v + 1^v)</script><p>所以</p>
<script type="math/tex; mode=display">
(2^{-j-1}) \times \sum^{n}_{v=2} {n \choose v} \times (2^j)^v \times (k \,\,\, \& \,\,\, (2^j-1)+1)^{n-v} \times (-1)^v \\
\Rightarrow (2^{-j-1}) \times ((k \,\,\, \& \,\,\, (2^j-1)+1-2^j)^n - (k \,\,\, \& \,\,\, (2^j-1)+1)^n) \\
(2^{-j-1}) \times \sum^{n}_{v=2} {n \choose v} \times (2^j)^v \times (k \,\,\, \& \,\,\, (2^j-1)+1)^{n-v} \times 1^v \\
\Rightarrow (2^{-j-1}) \times ((k \,\,\, \& \,\,\, (2^j-1)+1+2^j)^n - (k \,\,\, \& \,\,\, (2^j-1)+1)^n)</script><p><strong>时间复杂度：$ O(log^2n) $</strong></p>
<p><strong>期望得分：100分</strong></p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//xor2 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(LL i=A;i&lt;=B;i++) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(LL i=A;i&gt;=B;i--) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">LL Total,Ans,Limit,Temp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"xor2.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"xor2.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Fast</span><span class="params">(LL A,LL B)</span> </span>&#123;</span><br><span class="line">	LL Res=<span class="number">1</span>;</span><br><span class="line">	A=((A%MOD+MOD)%MOD);</span><br><span class="line">	<span class="keyword">while</span>(B) &#123;</span><br><span class="line">		<span class="keyword">if</span>(B &amp; <span class="number">1</span>) Res=(Res*A)%MOD;</span><br><span class="line">		A=(A*A)%MOD; B&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> Res%MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">File</span>();</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;Total,&amp;Limit);</span><br><span class="line">	<span class="keyword">if</span>(!(Total%<span class="number">2</span>)) Temp++;</span><br><span class="line">	BOR(i,<span class="number">29</span>,<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(Limit &amp; (<span class="number">1</span>&lt;&lt;i)) &#123;</span><br><span class="line">			LL Last=(Limit &amp; ((<span class="number">1</span>&lt;&lt;i)<span class="number">-1</span>))+<span class="number">1</span>;</span><br><span class="line">			LL Val=(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">			<span class="keyword">if</span>(Total%<span class="number">2</span>==<span class="number">0</span>) &#123;</span><br><span class="line">				Ans=Fast(Last+Val,Total)%MOD;</span><br><span class="line">				(Ans+=Fast(Last-Val,Total))%=MOD;</span><br><span class="line">				(Ans*=((MOD+<span class="number">1</span>)/<span class="number">2</span>))%=MOD;</span><br><span class="line">				Ans=((Ans-Fast(Last,Total))%MOD+MOD)%MOD;</span><br><span class="line">				(Temp+=(Ans*Fast(Val,MOD<span class="number">-2</span>)))%=MOD;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				Ans=Fast(Last+Val,Total)%MOD;</span><br><span class="line">				Ans=((Ans-Fast(Last-Val,Total))%MOD+MOD)%MOD;</span><br><span class="line">				(Ans*=((MOD+<span class="number">1</span>)/<span class="number">2</span>))%=MOD;</span><br><span class="line">				(Temp+=Ans*Fast(Val,MOD<span class="number">-2</span>)%MOD)%=MOD;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(Total &amp; <span class="number">1</span>)<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,((Fast(Limit+<span class="number">1</span>,Total)-Temp)%MOD+MOD)%MOD);</span><br><span class="line">	fclose(<span class="built_in">stdin</span>);</span><br><span class="line">	fclose(<span class="built_in">stdout</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>考试</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>T20200903</title>
    <url>/2020/09/03/T20200903/</url>
    <content><![CDATA[

	<div class="row">
    <embed src="problem.pdf" width="100%" height="550" type="application/pdf">
	</div>



<p>今天先鸽一鸽</p>
<h1 id="T1-异或统计-xor"><a href="#T1-异或统计-xor" class="headerlink" title="T1 异或统计(xor)"></a>T1 异或统计(xor)</h1><p>求</p>
<script type="math/tex; mode=display">
\sum_{i=1}^n\sum_{j=i+1}^n\sum_{k=j+1}^n(a_i\oplus a_j)(a_j\oplus a_k)(a_k\oplus a_j)</script><h1 id="T2-集合统计-set"><a href="#T2-集合统计-set" class="headerlink" title="T2 集合统计(set)"></a>T2 集合统计(set)</h1><h1 id="T3-异或统计2-xor2"><a href="#T3-异或统计2-xor2" class="headerlink" title="T3 异或统计2(xor2)"></a>T3 异或统计2(xor2)</h1>]]></content>
      <tags>
        <tag>鸽~</tag>
        <tag>考试</tag>
      </tags>
  </entry>
  <entry>
    <title>T20200904</title>
    <url>/2020/09/04/T20200904/</url>
    <content><![CDATA[

	<div class="row">
    <embed src="day8(8.25).pdf" width="100%" height="550" type="application/pdf">
	</div>



<h1 id="T1-count"><a href="#T1-count" class="headerlink" title="T1(count)"></a>T1(count)</h1><h2 id="45分做法"><a href="#45分做法" class="headerlink" title="45分做法"></a>45分做法</h2><p>直接暴力乱搞！！！</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, nm(<span class="number">1</span>), cnt, ans;</span><br><span class="line"><span class="keyword">int</span> son[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> dep, <span class="keyword">int</span> fac)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (fac &gt; nm) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (dep == m * <span class="number">2</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		++ans;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i)</span><br><span class="line">		dfs(dep + <span class="number">1</span>, fac * son[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	freopen (<span class="string">"count.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">	freopen (<span class="string">"count.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">	<span class="built_in">scanf</span> (<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) nm *= n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		<span class="keyword">if</span> (n % i == <span class="number">0</span>) son[++cnt] = i;</span><br><span class="line">	dfs(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span> (<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为你大概算一下，发现其实$100$以内的答案还是真的挺少的</p>
<h2 id="100分做法"><a href="#100分做法" class="headerlink" title="100分做法"></a>100分做法</h2><p>下面上PDF，先鸽着</p>
<h1 id="T2-delet"><a href="#T2-delet" class="headerlink" title="T2(delet)"></a>T2(delet)</h1><p>题解说，贪心删即可</p>
<p>然后根据某高级定理</p>
<p>每次删除一个最长单调的链，他的长度大概是一个$\log$级别的</p>
<p>所以最多$800$次可以删完</p>
<p>然后题解保证的是$500$次能删完</p>
<p>那么有$n\log n$求最长上升/下降子序列的做法</p>
<p>总时间复杂度$O(500\;n\log n)$</p>
<p>乱搞也能过。。。</p>
<h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">64005</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[maxn],a0[maxn],n,tot,f[maxn],g[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec[maxn];</span><br><span class="line"><span class="keyword">int</span> mx1[maxn],mx2[maxn],bac[maxn],del[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,tot);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> len=vec[i].size();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>,len);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j=len<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d%c"</span>,vec[i][j],<span class="string">" \n"</span>[j==<span class="number">0</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert1</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=x;i&lt;=n;i+=i&amp;-i)</span><br><span class="line">		mx1[i]=max(mx1[i],v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=x;i;i-=i&amp;-i)</span><br><span class="line">		mx2[i]=max(mx2[i],v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query1</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=x;i;i-=i&amp;-i)</span><br><span class="line">		res=max(res,mx1[i]);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=x;i&lt;=n;i+=i&amp;-i)</span><br><span class="line">		res=max(res,mx2[i]);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DP</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	++tot;</span><br><span class="line">	<span class="built_in">memset</span>(mx1,<span class="number">0</span>,n+<span class="number">1</span>&lt;&lt;<span class="number">2</span>);</span><br><span class="line">	<span class="built_in">memset</span>(mx2,<span class="number">0</span>,n+<span class="number">1</span>&lt;&lt;<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">int</span> ans1=<span class="number">0</span>,ans2=<span class="number">0</span>;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		f[i]=query1(a[i])+<span class="number">1</span>;</span><br><span class="line">		g[i]=query2(a[i])+<span class="number">1</span>;</span><br><span class="line">		insert1(a[i],f[i]);</span><br><span class="line">		insert2(a[i],g[i]);</span><br><span class="line">		ans1=max(ans1,f[i]);</span><br><span class="line">		ans2=max(ans2,g[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">memset</span>(del,<span class="number">0</span>,n+<span class="number">1</span>&lt;&lt;<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">if</span> (ans1&gt;ans2) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> t=ans1,i=n;t;i--)</span><br><span class="line">			<span class="keyword">if</span> (f[i]==t) del[a[i]]=<span class="number">1</span>,t--,vec[tot].pb(a0[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> t=ans2,i=n;t;i--)</span><br><span class="line">			<span class="keyword">if</span> (g[i]==t) del[a[i]]=<span class="number">1</span>,t--,vec[tot].pb(a0[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		bac[i]=bac[i<span class="number">-1</span>]+<span class="number">1</span>-del[i];</span><br><span class="line">	<span class="keyword">int</span> pos=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">if</span> (!del[a[i]]) a0[++pos]=a0[i],a[pos]=bac[a[i]];</span><br><span class="line">	n=pos;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">		freopen(<span class="string">"delete.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">		freopen(<span class="string">"delete.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]),a0[i]=a[i];</span><br><span class="line">	<span class="keyword">while</span> (n) DP();</span><br><span class="line">	Print();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//std</span></span><br></pre></td></tr></table></figure>
<h1 id="T3-floor"><a href="#T3-floor" class="headerlink" title="T3(floor)"></a>T3(floor)</h1><p>这是我今天特别失败的地方</p>
<p>我$TM$花了$2h$来打表找规律，结果，结果！！</p>
<p>我$TM$打错表了！！！</p>
<p><img src="https://i.loli.net/2020/09/03/AqSZ17Qp6j28UWe.gif" alt="T20200903-1.gif"></p>
<p>最后还是搞出来了，真是惊悚啊</p>
<h2 id="打表"><a href="#打表" class="headerlink" title="打表"></a>打表</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1   	1</span><br><span class="line">2    	3</span><br><span class="line">4 		4</span><br><span class="line">6 	 	7</span><br><span class="line">11 		11</span><br><span class="line">17  	18</span><br><span class="line">29   	29</span><br><span class="line">46   	47</span><br><span class="line">76   	76</span><br><span class="line">122     123</span><br><span class="line">199     199</span><br><span class="line">321     322</span><br><span class="line">521     .</span><br><span class="line">842     .</span><br><span class="line">1364    .</span><br><span class="line">2206    .</span><br><span class="line">3571    .</span><br><span class="line">5777    .</span><br><span class="line">9349    .</span><br><span class="line">15126   .</span><br></pre></td></tr></table></figure>
<p>左边这个是没有取模的值</p>
<p>右边这个是不是有点像斐波那契数列呢？</p>
<p>看看数据范围$n\le10^{18}$</p>
<p>矩阵乘法，那就结束了？</p>
<script type="math/tex; mode=display">
\begin{vmatrix}f_i&f_{i-1}\\0&0\end{vmatrix}\qquad \begin{vmatrix}1&1\\1&0\end{vmatrix}</script><p>就用这两个矩阵做快速幂</p>
<p>然后因为没有对$1$做贡献的数，所以我们让矩阵的$0$次方的值为$3$</p>
<p>如果$n$是个偶数，那么答案还要减一</p>
<h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line">ll n, p;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">matrix</span>&#123;</span>ll a[<span class="number">2</span>][<span class="number">2</span>];&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">matrix <span class="title">ppt</span> <span class="params">(matrix x, matrix y)</span> </span>&#123;</span><br><span class="line">	matrix ans;</span><br><span class="line">	<span class="built_in">memset</span> (ans.a, <span class="number">0</span>, <span class="keyword">sizeof</span> ans.a);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">1</span>; ++i)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">1</span>; ++j)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">1</span>; ++k)</span><br><span class="line">				ans.a[i][j] = (ans.a[i][j] + x.a[i][k] * y.a[k][j] % p) % p;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	matrix x, ans;</span><br><span class="line">	x.a[<span class="number">0</span>][<span class="number">0</span>] = x.a[<span class="number">0</span>][<span class="number">1</span>] = x.a[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	ans.a[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">3</span>, ans.a[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	ans.a[<span class="number">1</span>][<span class="number">0</span>] = ans.a[<span class="number">1</span>][<span class="number">1</span>] = x.a[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (y) &#123;</span><br><span class="line">		<span class="keyword">if</span> (y &amp; <span class="number">1</span>) ans = ppt(ans, x);</span><br><span class="line">		x = ppt(x, x);</span><br><span class="line">		y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans.a[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; p;</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"0"</span>) &amp; <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (!n || n == <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"1"</span>) &amp; <span class="number">0</span>;</span><br><span class="line">	ll ans = Pow(n - <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">if</span> (!(n % <span class="number">2</span>)) --ans;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


	<div class="row">
    <embed src="solution.pdf" width="100%" height="550" type="application/pdf">
	</div>


]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>鸽~</tag>
        <tag>考试</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>T20200922</title>
    <url>/2020/09/22/T20200922/</url>
    <content><![CDATA[

	<div class="row">
    <embed src="problem.pdf" width="100%" height="550" type="application/pdf">
	</div>



<h1 id="T1-集合均值-mos"><a href="#T1-集合均值-mos" class="headerlink" title="T1 集合均值(mos)"></a>T1 集合均值(mos)</h1><p>就是暴力+线性求逆元即可</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(LL i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(LL i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Lowbit(X) (X &amp; (-X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Rson (X&lt;&lt;1|1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Lson (X&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Mod 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> LL MaxN=<span class="number">2e7</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">LL N,M;</span><br><span class="line">LL Num[MaxN],Inv[MaxN];</span><br><span class="line">LL Ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Fast</span><span class="params">(LL A,LL B)</span> </span>&#123;</span><br><span class="line">    LL Res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(B) &#123;</span><br><span class="line">        <span class="keyword">if</span>(B &amp; <span class="number">1</span>) Res=(Res*A)%Mod;</span><br><span class="line">        A=(A*A)%Mod;</span><br><span class="line">        B&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Res%Mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> A,<span class="keyword">int</span> B)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a=<span class="number">1</span>,b=<span class="number">1</span>;</span><br><span class="line">	FOR(i,A-B+<span class="number">1</span>,A) (a*=i)%=Mod;</span><br><span class="line">	FOR(i,<span class="number">1</span>,B) (b*=i)%=Mod;</span><br><span class="line">	<span class="keyword">return</span> A*Fast(b,Mod<span class="number">-2</span>)%Mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;N&gt;&gt;M;</span><br><span class="line">    LL Sum=<span class="number">0</span>;</span><br><span class="line">    FOR(i,<span class="number">1</span>,N) <span class="built_in">cin</span>&gt;&gt;Num[i],Sum+=Num[i];</span><br><span class="line">    LL S=N*M;</span><br><span class="line">    Sum*=M;</span><br><span class="line">    LL Ans=Sum%Mod*Fast(S,Mod<span class="number">-2</span>)%Mod;</span><br><span class="line">    LL Temp=<span class="number">0</span>;</span><br><span class="line">    Inv[<span class="number">0</span>]=Inv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    LL Res=<span class="number">0</span>;</span><br><span class="line">    FOR(i,<span class="number">2</span>,S+<span class="number">1</span>) Inv[i]=(Mod-Mod/i)*Inv[Mod%i]%Mod,(Res+=Inv[i])%Mod;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;Ans*(((S-Res)%Mod+Mod)%Mod)%Mod&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T2-聚烷撑乙二醇-pag"><a href="#T2-聚烷撑乙二醇-pag" class="headerlink" title="T2 聚烷撑乙二醇(pag)"></a>T2 聚烷撑乙二醇(pag)</h1><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>考虑清楚“最优操作”到底是什么样的，这题就很简单 </p>
<p>假设只有两个发生器，那么如果放弃第一个选用第二个，第二个发生器产生的数的期望是</p>
<script type="math/tex; mode=display">
Y=\frac{L_2+R_2}{2}</script><p> 不难想到如果第一个发生器产生了 $X$，$X&lt;Y$ 时放弃 $X$ 更优，否则拿走 $x$ 更优。</p>
<p> 更一般的，假设当前在使用第 $i$ 个发生器，其产生了 $X$，设从第 $i$ 个发生器开始游戏得到的最优答案是 $f<em>{i+1}$ ，那么比较 $X$ 和 $f</em>{i+1}$ 的大小关系就可以确定是否拿走 $X$ 。那么 $f_i$ 的计算就是一个分段的一次函数的积分，来个加权平均数什么的算一下就好了。</p>
<p>时间复杂度$O(n)$</p>
<h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(...) fprintf(stderr, __VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">double</span> ld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000005</span>;</span><br><span class="line"><span class="keyword">int</span> l[maxn], r[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen (<span class="string">"pag.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">	freopen (<span class="string">"pag.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">	<span class="keyword">int</span> n = read;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) <span class="built_in">scanf</span> (<span class="string">"%d %d"</span>, l + i, r + i);</span><br><span class="line"></span><br><span class="line">	ld ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; i --) &#123;</span><br><span class="line">		<span class="keyword">int</span> L = l[i], R = r[i];</span><br><span class="line">		<span class="keyword">if</span> (ans &lt; L)</span><br><span class="line">			ans = ld(L + R) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (ans &lt; R)</span><br><span class="line">			ans = (ans * (ans - L) + (ans + R) / <span class="number">2</span> * (R - ans)) / (R - L);</span><br><span class="line">		<span class="comment">/* else */</span></span><br><span class="line">		<span class="comment">/* 	ans = ans; */</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%.5Lf\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T3-技术情报局-tio"><a href="#T3-技术情报局-tio" class="headerlink" title="T3 技术情报局(tio)"></a>T3 技术情报局(tio)</h1><p>对于$20$分的数据，暴力枚举即可</p>
<p>这个最大值太突兀了，不难想到枚举每个数，考虑其作为最大值的区间的贡献。</p>
<p> 建大根笛卡尔树，设 $i$ 在笛卡尔树上管辖的区间为 $[l,r]$，那么当区间 $[L,R]$ 满足 $L\in[l,i]\land R\in[i,R]$ 时 $i$ 恰好作为 $[L,R]$ 的最大值。在笛卡尔树上做些信息合并即可统计答案。</p>
<h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e7</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[maxn], mod;</span><br><span class="line"><span class="keyword">int</span> ls[maxn], rs[maxn];</span><br><span class="line"><span class="keyword">int</span> stk[maxn], top;</span><br><span class="line">ll ans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> __read()</span><br><span class="line">&#123;</span><br><span class="line">    int x(0), t(1);</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">'0'</span> || o &gt; <span class="string">'9'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">'-'</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">'0'</span> &amp;&amp; o &lt;= <span class="string">'9'</span>; o = getchar()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> GenHelper &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> z1, z2, z3, z4, b;</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">rand_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        b = ((z1 &lt;&lt; <span class="number">6</span>) ^ z1) &gt;&gt; <span class="number">13</span>;</span><br><span class="line">        z1 = ((z1 &amp; <span class="number">4294967294U</span>) &lt;&lt; <span class="number">18</span>) ^ b;</span><br><span class="line">        b = ((z2 &lt;&lt; <span class="number">2</span>) ^ z2) &gt;&gt; <span class="number">27</span>;</span><br><span class="line">        z2 = ((z2 &amp; <span class="number">4294967288U</span>) &lt;&lt; <span class="number">2</span>) ^ b;</span><br><span class="line">        b = ((z3 &lt;&lt; <span class="number">13</span>) ^ z3) &gt;&gt; <span class="number">21</span>;</span><br><span class="line">        z3 = ((z3 &amp; <span class="number">4294967280U</span>) &lt;&lt; <span class="number">7</span>) ^ b;</span><br><span class="line">        b = ((z4 &lt;&lt; <span class="number">3</span>) ^ z4) &gt;&gt; <span class="number">12</span>;</span><br><span class="line">        z4 = ((z4 &amp; <span class="number">4294967168U</span>) &lt;&lt; <span class="number">13</span>) ^ b;</span><br><span class="line">        <span class="keyword">return</span> (z1 ^ z2 ^ z3 ^ z4);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125; <span class="comment">// namespace GenHelper</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get</span> <span class="params">(<span class="keyword">int</span> n, <span class="keyword">unsigned</span> s, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> GenHelper;</span><br><span class="line">    z1 = s;</span><br><span class="line">    z2 = <span class="keyword">unsigned</span>((~s) ^ <span class="number">0x233333333</span>U);</span><br><span class="line">    z3 = <span class="keyword">unsigned</span>(s ^ <span class="number">0x1234598766</span>U);</span><br><span class="line">    z4 = (~s) + <span class="number">51</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = rand_() &amp; <span class="number">32767</span>;</span><br><span class="line">        <span class="keyword">int</span> y = rand_() &amp; <span class="number">32767</span>;</span><br><span class="line">        a[i] = (l + (x * <span class="number">32768</span> + y) % (r - l + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ll p, q, x;</span><br><span class="line">    Data <span class="keyword">operator</span> + (<span class="keyword">const</span> Data &amp;r) <span class="keyword">const</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            (p + x * r.p) % mod,</span><br><span class="line">            (r.q + r.x * q) % mod,</span><br><span class="line">            x * r.x % mod</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Data <span class="title">Slove</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!i) <span class="keyword">return</span> &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    Data L = Slove(ls[i], l, i - <span class="number">1</span>);</span><br><span class="line">    Data R = Slove(rs[i], i + <span class="number">1</span>, r);</span><br><span class="line">    Data D = &#123;a[i], a[i], a[i]&#125;;</span><br><span class="line">    ans = (ans + (L.q + <span class="number">1</span>) * (R.p + <span class="number">1</span>) % mod * a[i] % mod * a[i] % mod) % mod;</span><br><span class="line">    <span class="keyword">return</span> L + D + R;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = __read(), s = __read(), l = __read(), r = __read();</span><br><span class="line">    mod = __read();</span><br><span class="line">    get(n, <span class="keyword">unsigned</span>(s), l, r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (top <span class="keyword">and</span> a[stk[top]] &lt; a[i]) ls[i] = stk[top--];</span><br><span class="line">        <span class="keyword">if</span> (top) rs[stk[top]] = i;</span><br><span class="line">        stk[++top] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    Slove(stk[<span class="number">1</span>], <span class="number">1</span>, n);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T4-肯德基-KFC"><a href="#T4-肯德基-KFC" class="headerlink" title="T4 肯德基(KFC)"></a>T4 肯德基(KFC)</h1><p>先吐槽一下，这道题是真的战术失误</p>
<p>我当时不知道是傻了还是怎么了，只想到了统计无平方因字数的个数的做法</p>
<p>竟然没想到怎么加权。。。</p>
<p>害，学艺不精啊。。。</p>
<p>关于无平方因字数的个数<a href="https://alansblog.ink/2020/07/28/从1开始的数论/" target="_blank" rel="noopener">看这里</a></p>
<p>记$[1,n]$范围内无平方因字数的个数为$Count_n$，那么有：</p>
<script type="math/tex; mode=display">
Count_n=\sum_{i=1}^\sqrt n\mu(i)\left\lfloor\frac n{i^2}\right\rfloor</script><p>在此基础上，加上$i^2$的贡献即为答案啊</p>
<p>我是真的蠢了</p>
<p>所以得到：</p>
<script type="math/tex; mode=display">
ans=\sum_{i=1}^\sqrt n\mu(i)i^2S(\left\lfloor\frac n{i^2}\right\rfloor)</script><p>然后就是关于这个$std$的玄学优化了，表示没看得很明白</p>
<p>不加优化的话，那就只有$80$分的好成绩，对于我来说就够啦</p>
<h2 id="Code-80"><a href="#Code-80" class="headerlink" title="Code(80)"></a>Code(80)</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll maxn = <span class="number">1e7</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">ll n, pr[maxn], mu[maxn];</span><br><span class="line">ll cnt, g[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> ll __read()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">ll <span class="title">x</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">'0'</span> || o &gt; <span class="string">'9'</span>) </span><br><span class="line">        o = getchar();</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">'0'</span> &amp;&amp; o &lt;= <span class="string">'9'</span>; o = getchar()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">2</span>; i &lt; maxn; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) pr[++cnt] = i, mu[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (ll j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; pr[j] * i &lt; maxn; ++j) &#123;</span><br><span class="line">            vis[i * pr[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % pr[j]) mu[i * pr[j]] = -mu[i];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt; maxn; ++i) g[i] = mu[i] * i * i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">S</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &amp; <span class="number">1</span>) <span class="keyword">return</span> ((x + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) * x;</span><br><span class="line">    <span class="keyword">return</span> (x &gt;&gt; <span class="number">1</span>) * (x + <span class="number">1</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen (<span class="string">"kfc.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen (<span class="string">"kfc.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    init();</span><br><span class="line">    ll T = __read();</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        ll n = __read();</span><br><span class="line">        <span class="function">ll <span class="title">ans</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (ll i = <span class="number">1</span>; i * i &lt;= n; ++i) </span><br><span class="line">            ans += g[i] * S(n / i / i);</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"%llu\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Code-100"><a href="#Code-100" class="headerlink" title="Code(100)"></a>Code(100)</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll maxn = <span class="number">2e7</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">ll n, pr[maxn], mu[maxn];</span><br><span class="line">ll cnt, g[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> ll __read()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">ll <span class="title">x</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">'0'</span> || o &gt; <span class="string">'9'</span>) </span><br><span class="line">        o = getchar();</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">'0'</span> &amp;&amp; o &lt;= <span class="string">'9'</span>; o = getchar()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">2</span>; i &lt; maxn; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) pr[++cnt] = i, mu[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (ll j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; pr[j] * i &lt; maxn; ++j) &#123;</span><br><span class="line">            vis[i * pr[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % pr[j]) mu[i * pr[j]] = -mu[i];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt; maxn; ++i) g[i] = g[i - <span class="number">1</span>] + mu[i] * i * i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">S</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &amp; <span class="number">1</span>) <span class="keyword">return</span> ((x + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) * x;</span><br><span class="line">    <span class="keyword">return</span> (x &gt;&gt; <span class="number">1</span>) * (x + <span class="number">1</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen (<span class="string">"kfc.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen (<span class="string">"kfc.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    init();</span><br><span class="line">    ll T = __read();</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        ll n = __read();</span><br><span class="line">        <span class="function">ll <span class="title">ans</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> B = <span class="keyword">int</span>(powl(n, <span class="number">1.0l</span> / <span class="number">3</span>));</span><br><span class="line">        <span class="keyword">int</span> m = <span class="keyword">int</span> (n / B / B);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= B <span class="keyword">and</span> n / i / i &gt; m; ++i) </span><br><span class="line">            ans += (g[i] - g[i - <span class="number">1</span>]) * S(n / i / i);</span><br><span class="line">        <span class="keyword">for</span> (ll i = m; i; --i) </span><br><span class="line">            ans += S(i) * (g[<span class="keyword">int</span>(sqrtl(n / i))] - g[<span class="keyword">int</span>(<span class="built_in">sqrt</span>(n / (i + <span class="number">1</span>)))]);</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"%llu\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我竟然来更新了</p>
<p>发现$\left\lfloor\frac n{i^2}\right\rfloor$这个东西可以直接分块</p>
<p>那么就可以直接写了</p>
<p>才不需要什么其他的三次方根之类的鬼畜玩意儿呢！！！</p>
<h2 id="Code-100-1"><a href="#Code-100-1" class="headerlink" title="Code(100+)"></a>Code(100+)</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll maxn = <span class="number">2e7</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">ll n, pr[maxn], mu[maxn];</span><br><span class="line">ll cnt, g[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> ll __read()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">ll <span class="title">x</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">'0'</span> || o &gt; <span class="string">'9'</span>) </span><br><span class="line">        o = getchar();</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">'0'</span> &amp;&amp; o &lt;= <span class="string">'9'</span>; o = getchar()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">2</span>; i &lt; maxn; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) pr[++cnt] = i, mu[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (ll j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; pr[j] * i &lt; maxn; ++j) &#123;</span><br><span class="line">            vis[i * pr[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % pr[j]) mu[i * pr[j]] = -mu[i];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt; maxn; ++i) g[i] = g[i - <span class="number">1</span>] + mu[i] * i * i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">S</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &amp; <span class="number">1</span>) <span class="keyword">return</span> ((x + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) * x;</span><br><span class="line">    <span class="keyword">return</span> (x &gt;&gt; <span class="number">1</span>) * (x + <span class="number">1</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen (<span class="string">"kfc.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen (<span class="string">"kfc.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    init();</span><br><span class="line">    ll T = __read();</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        ll n = __read();</span><br><span class="line">        <span class="function">ll <span class="title">ans</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (ll l = <span class="number">1</span>, r; l * l &lt;= n; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">            r = <span class="built_in">sqrt</span>(n / (n / l / l));</span><br><span class="line">            ans += (g[r] - g[l - <span class="number">1</span>]) * S(n / l / l);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"%llu\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<center> <a href="./solution.pdf">附件下载 </center>

]]></content>
      <tags>
        <tag>莫比乌斯反演</tag>
        <tag>数据结构</tag>
        <tag>鸽~</tag>
        <tag>考试</tag>
        <tag>期望Dp</tag>
        <tag>笛卡尔树</tag>
      </tags>
  </entry>
  <entry>
    <title>T20200924</title>
    <url>/2020/09/25/T20200924/</url>
    <content><![CDATA[

	<div class="row">
    <embed src="problem.pdf" width="100%" height="550" type="application/pdf">
	</div>



<h1 id="T1-吃屎题"><a href="#T1-吃屎题" class="headerlink" title="T1(吃屎题)"></a>T1(吃屎题)</h1><p><del>这个题，当时交错文件了，真该吃屎</del></p>
<p>就是说，当前的字符作为开头是否是一个更优的选择</p>
<p>如果是，那么就可以清空字符</p>
<p>否则，找到最优的位置插进去</p>
<p>就是一裸的贪心</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e7</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len, cnt;</span><br><span class="line"><span class="keyword">char</span> temp[maxn];</span><br><span class="line"><span class="keyword">char</span> ans[maxn], opt[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">char</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    int l(0), r(cnt), rp(cnt);</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= ans[cnt - <span class="number">1</span>]) <span class="keyword">return</span> rp;</span><br><span class="line">    ans[cnt] = <span class="string">'a'</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (ans[mid] &lt; x) rp = mid, r = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%d %s"</span>, &amp;len, temp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i(<span class="number">0</span>); i &lt; len; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ans[<span class="number">0</span>] &gt;= temp[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> p = Find(temp[i]);</span><br><span class="line">            ans[cnt = p] = temp[i];</span><br><span class="line">            ++cnt; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cnt = <span class="number">0</span>;</span><br><span class="line">            ans[cnt] = temp[i];</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; ++i) <span class="built_in">putchar</span>(ans[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T2-掉分提"><a href="#T2-掉分提" class="headerlink" title="T2(掉分提)"></a>T2(掉分提)</h1><p>首先考虑$1$的代价</p>
<ul>
<li>我们要删除$1$，无论$1$在哪里，他的最优决策一定是用$1$的代价删除</li>
<li>然后，忽略数列中的所有$1$，它就可以看作是一的$k$段的数列</li>
</ul>
<p>那么现在得到的就是$k$段不含$1$的数列，假设它为$a,b,c,d,e,f\cdots z$</p>
<p>然后我们假设现在通过最优策略进行删除操作，那么得到了这样一个东西：</p>
<ul>
<li>$x(p_1),y,z(p_2)$</li>
<li>$x$表示$y$的左边最小的数，得到他的代价为$p_1$</li>
<li>$z$表示$y$的右边最小的数，得到他的代价为$p_2$</li>
</ul>
<p>那么合并$x,y,z$的方案就有两种：</p>
<ul>
<li>先合并中间的$y$，总花费为：$cost=xyz+xz+\min(x,z)$</li>
<li>县合并两边，总花费为：$cost=xy+yz+min(x,y,z)$</li>
</ul>
<p>显然，$\min(x,y,z)\le\min(x,z)$，且$y(x+z)\le yxz$</p>
<p>所以可以证明，从每一段的两边开始取的答案一定最优</p>
<p>那么每一小段答案就可以记作</p>
<script type="math/tex; mode=display">
ans=\sum_{i=2}^nai*a_{i-1}+\min_{i=1}^na_i</script><p>最后加起来，再加上所有$1$的贡献，就可以了</p>
<h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> __read()</span><br><span class="line">&#123;</span><br><span class="line">    int x(0), t(1);</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">'0'</span> || o &gt; <span class="string">'9'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">'-'</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">'0'</span> &amp;&amp; o &lt;= <span class="string">'9'</span>; o = getchar()) &#123;</span><br><span class="line">        x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll a, b, minx, ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen (<span class="string">"b.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen (<span class="string">"b.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">int</span> n = __read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        b = __read();</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">1</span>) &#123;</span><br><span class="line">            ans += <span class="number">1</span>;</span><br><span class="line">            a = b = <span class="number">0</span>;</span><br><span class="line">            ans += minx;</span><br><span class="line">            minx = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += a * b;</span><br><span class="line">        a = b;</span><br><span class="line">        <span class="keyword">if</span> (!minx || a &lt; minx) minx = a;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans + minx &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T3-爆零题"><a href="#T3-爆零题" class="headerlink" title="T3(爆零题)"></a>T3(爆零题)</h1><p>就是说，可以把从$S\rightarrow T$的某条最短路上的边权改成$0$</p>
<p>然后问$X\rightarrow Y$的最短路径长度为多少</p>
<p>这道题是被欧歌爆砍$100$的</p>
<p>于是呢，我也是按照欧歌的改的</p>
<p>从$X\rightarrow Y$的路径长度，首先可以直接跑最短路</p>
<p>怎么处理$S\rightarrow T$的最短路边权为$0$呢？</p>
<p>看张图：</p>
<p><img src="https://i.loli.net/2020/09/25/zfekEoWrL6hGYHS.png" alt="q.png"></p>
<p>嗯，感觉就挺显然的了，就是看再$S\rightarrow T$的最短路径上的点到$X\rightarrow Y$的最短路径之和</p>
<p>就跑$3$次最短路即可</p>
<h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid (l+r)/2</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> ll INF=<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5e6</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,s,t,x,y;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> e,next;</span><br><span class="line">	ll w;</span><br><span class="line">&#125;edge[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[N],cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> e,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	edge[++cnt].e=e;</span><br><span class="line">	edge[cnt].w=w;</span><br><span class="line">	edge[cnt].next=head[s];</span><br><span class="line">	head[s]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line">ll diss[N],dist[N],disy[N],disx[N];</span><br><span class="line">ll Minx[N],Miny[N],ans=INF;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> start,ll dis[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	dis[start]=<span class="number">0</span>;q.push_front(start);</span><br><span class="line">	vis[start]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> now=q.front();</span><br><span class="line">		q.pop_front();</span><br><span class="line">		vis[now]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=head[now];i;i=edge[i].next)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> to=edge[i].e;</span><br><span class="line">			<span class="keyword">if</span>(dis[to]&gt;dis[now]+edge[i].w)</span><br><span class="line">			&#123;</span><br><span class="line">				dis[to]=dis[now]+edge[i].w;</span><br><span class="line">				<span class="keyword">if</span>(!vis[to])</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span>(q.empty()||dis[q.front()]&gt;dis[to]) q.push_front(to);</span><br><span class="line">					<span class="keyword">else</span> q.push_back(to);</span><br><span class="line">					vis[to]=<span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> from,ll d1,ll d2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	d1=min(d1,disx[now]);</span><br><span class="line">	d2=min(d2,disy[now]);</span><br><span class="line">	ans=min(ans,d1+d2);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=head[now];i;i=edge[i].next)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> to=edge[i].e;</span><br><span class="line">		<span class="keyword">if</span>(diss[now]==diss[to]+edge[i].w)</span><br><span class="line">			dfs(to,now,d1,d2);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;s,&amp;t);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> u,v;ll w;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%lld"</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">		add(u,v,w);</span><br><span class="line">		add(v,u,w);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memset</span>(diss,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(diss));</span><br><span class="line">	<span class="built_in">memset</span>(disx,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(disx));</span><br><span class="line">	<span class="built_in">memset</span>(disy,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(disy));</span><br><span class="line">	SPFA(s,diss);</span><br><span class="line">	SPFA(x,disx);</span><br><span class="line">	SPFA(y,disy);</span><br><span class="line">	dfs(t,<span class="number">0</span>,INF,INF);</span><br><span class="line">	ans=min(ans,disx[y]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>欧歌牛逼！！！</p>
<h1 id="T4-退役题"><a href="#T4-退役题" class="headerlink" title="T4(退役题)"></a>T4(退役题)</h1><p>这，先贴一个$STD$，有题解的时候再回来看看吧</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ge getchar()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Re read()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">0</span>, ch;</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch = ge)) ;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + (ch ^ <span class="number">48</span>), ch = ge;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Base[] = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">15</span>, <span class="number">30</span>, <span class="number">60</span>, <span class="number">120</span>, <span class="number">240</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1004535809</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> cnt[<span class="number">500</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> T <span class="title">Mod</span><span class="params">(T x)</span> </span>&#123; <span class="keyword">return</span> x &lt; <span class="number">0</span> ? (x % mod + mod) : (x &lt; mod ? x : (x &lt; (mod &lt;&lt; <span class="number">1</span>) ? x - mod : x % mod)); &#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(T&amp;x, T y)</span> </span>&#123; x = Mod(x + y); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tot;</span><br><span class="line"><span class="keyword">int</span> pri[<span class="number">500</span>];</span><br><span class="line"><span class="keyword">int</span> chk[<span class="number">500</span>];</span><br><span class="line"><span class="keyword">int</span> Min[<span class="number">500</span>];</span><br><span class="line"><span class="keyword">int</span> pw[<span class="number">310000</span>];</span><br><span class="line"><span class="keyword">int</span> fac[<span class="number">500</span>];</span><br><span class="line"><span class="keyword">int</span> inv[<span class="number">500</span>];</span><br><span class="line"><span class="keyword">int</span> ifac[<span class="number">500</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> mx)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= mx; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(!chk[i]) pri[++tot] = i, Min[i] = i;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(i * pri[j] &gt; mx) <span class="keyword">break</span>;</span><br><span class="line">			chk[i * pri[j]] = <span class="number">1</span>;</span><br><span class="line">			Min[i * pri[j]] = pri[j];</span><br><span class="line">			<span class="keyword">if</span>(i % pri[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	pw[<span class="number">0</span>] = fac[<span class="number">0</span>] = fac[<span class="number">1</span>] = inv[<span class="number">0</span>] = inv[<span class="number">1</span>] = ifac[<span class="number">0</span>] = ifac[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">300000</span>; i++) pw[i] = Mod(pw[i - <span class="number">1</span>] &lt;&lt; <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= mx; i++) &#123;</span><br><span class="line">		fac[i] = Mod(<span class="number">1L</span>L * fac[i - <span class="number">1</span>] * i);</span><br><span class="line">		inv[i] = Mod(<span class="number">1L</span>L * (mod - mod / i) * inv[mod % i]);</span><br><span class="line">		ifac[i] = Mod(<span class="number">1L</span>L * ifac[i - <span class="number">1</span>] * inv[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">	Node() &#123; <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a)); &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(!(v &amp; <span class="number">1</span>)) ++a[<span class="number">0</span>], v &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(v % <span class="number">3</span> == <span class="number">0</span>) ++a[<span class="number">1</span>], v /= <span class="number">3</span>;</span><br><span class="line">		<span class="keyword">while</span>(v % <span class="number">5</span> == <span class="number">0</span>) ++a[<span class="number">2</span>], v /= <span class="number">5</span>;</span><br><span class="line">		<span class="keyword">while</span>(v % <span class="number">7</span> == <span class="number">0</span>) ++a[<span class="number">3</span>], v /= <span class="number">7</span>;</span><br><span class="line">		<span class="keyword">while</span>(v % <span class="number">11</span> == <span class="number">0</span>) ++a[<span class="number">4</span>], v /= <span class="number">11</span>;</span><br><span class="line">		<span class="keyword">while</span>(v % <span class="number">13</span> == <span class="number">0</span>) ++a[<span class="number">5</span>], v /= <span class="number">13</span>;</span><br><span class="line">		<span class="keyword">while</span>(v % <span class="number">17</span> == <span class="number">0</span>) ++a[<span class="number">6</span>], v /= <span class="number">17</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">			a[i] = v % Base[i + <span class="number">1</span>] / Base[i];</span><br><span class="line">		a[<span class="number">6</span>] = v / Base[<span class="number">6</span>];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Merge</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line">			a[i] = max(a[i], x.a[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">val</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line">			res += a[i] * Base[i];</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;Num[<span class="number">310</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[<span class="number">500</span>][<span class="number">500</span>];</span><br><span class="line"><span class="keyword">int</span> g[<span class="number">500</span>][<span class="number">500</span>];</span><br><span class="line"><span class="keyword">int</span> h[<span class="number">500</span>][<span class="number">500</span>];</span><br><span class="line"><span class="keyword">int</span> G[<span class="number">9</span>][<span class="number">6</span>][<span class="number">4</span>][<span class="number">3</span>][<span class="number">3</span>][<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">500</span>];</span><br><span class="line"><span class="keyword">int</span> nu[<span class="number">500</span>][<span class="number">500</span>];</span><br><span class="line"><span class="keyword">int</span> mx[<span class="number">500</span>][<span class="number">500</span>];</span><br><span class="line"><span class="keyword">int</span> ct[<span class="number">500</span>];</span><br><span class="line"><span class="keyword">int</span> sum[<span class="number">500</span>];</span><br><span class="line"><span class="keyword">int</span> Pw[<span class="number">500</span>][<span class="number">500</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> p, Node x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> v = x.val();</span><br><span class="line">	<span class="keyword">if</span>(g[p][v]) <span class="keyword">return</span> f[p][v];</span><br><span class="line">	g[p][v] = <span class="number">1</span>; <span class="keyword">int</span>&amp;F = f[p][v];</span><br><span class="line">	<span class="keyword">if</span>(p == <span class="number">7</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> a0 = <span class="number">0</span>; a0 &lt; <span class="number">9</span>; ++a0)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> a1 = <span class="number">0</span>; a1 &lt; <span class="number">6</span>; ++a1)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> a2 = <span class="number">0</span>; a2 &lt; <span class="number">4</span>; ++a2)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> a3 = <span class="number">0</span>; a3 &lt; <span class="number">3</span>; ++a3)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> a4 = <span class="number">0</span>; a4 &lt; <span class="number">3</span>; ++a4)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> a5 = <span class="number">0</span>; a5 &lt; <span class="number">3</span>; ++a5)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> a6 = <span class="number">0</span>; a6 &lt; <span class="number">3</span>; ++a6) &#123;</span><br><span class="line">			<span class="keyword">if</span>(!G[a0][a1][a2][a3][a4][a5][a6]) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">int</span> Prd = <span class="number">1</span>;</span><br><span class="line">			Prd = Mod(<span class="number">1L</span>L * Prd * Pw[<span class="number">0</span>][max(a0, x.a[<span class="number">0</span>])]);</span><br><span class="line">			Prd = Mod(<span class="number">1L</span>L * Prd * Pw[<span class="number">1</span>][max(a1, x.a[<span class="number">1</span>])]);</span><br><span class="line">			Prd = Mod(<span class="number">1L</span>L * Prd * Pw[<span class="number">2</span>][max(a2, x.a[<span class="number">2</span>])]);</span><br><span class="line">			Prd = Mod(<span class="number">1L</span>L * Prd * Pw[<span class="number">3</span>][max(a3, x.a[<span class="number">3</span>])]);</span><br><span class="line">			Prd = Mod(<span class="number">1L</span>L * Prd * Pw[<span class="number">4</span>][max(a4, x.a[<span class="number">4</span>])]);</span><br><span class="line">			Prd = Mod(<span class="number">1L</span>L * Prd * Pw[<span class="number">5</span>][max(a5, x.a[<span class="number">5</span>])]);</span><br><span class="line">			Prd = Mod(<span class="number">1L</span>L * Prd * Pw[<span class="number">6</span>][max(a6, x.a[<span class="number">6</span>])]);</span><br><span class="line">			F = Mod(F + <span class="number">1L</span>L * G[a0][a1][a2][a3][a4][a5][a6] * Prd);</span><br><span class="line">		&#125; <span class="keyword">return</span> F;</span><br><span class="line">	&#125; F = solve(p - <span class="number">1</span>, x); Node now, sta;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> a0 = <span class="number">0</span>; a0 &lt;= mx[p][<span class="number">0</span>]; ++a0)</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> a1 = <span class="number">0</span>; a1 &lt;= mx[p][<span class="number">1</span>]; ++a1)</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> a2 = <span class="number">0</span>; a2 &lt;= mx[p][<span class="number">2</span>]; ++a2)</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> a3 = <span class="number">0</span>; a3 &lt;= mx[p][<span class="number">3</span>]; ++a3)</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> a4 = <span class="number">0</span>; a4 &lt;= mx[p][<span class="number">4</span>]; ++a4)</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> a5 = <span class="number">0</span>; a5 &lt;= mx[p][<span class="number">5</span>]; ++a5)</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> a6 = <span class="number">0</span>; a6 &lt;= mx[p][<span class="number">6</span>]; ++a6) &#123;</span><br><span class="line">		sta.a[<span class="number">0</span>] = a0, sta.a[<span class="number">1</span>] = a1, sta.a[<span class="number">2</span>] = a2;</span><br><span class="line">		sta.a[<span class="number">3</span>] = a3, sta.a[<span class="number">4</span>] = a4, sta.a[<span class="number">5</span>] = a5;</span><br><span class="line">		sta.a[<span class="number">6</span>] = a6;</span><br><span class="line">		<span class="keyword">if</span>(!h[p][sta.val()]) <span class="keyword">continue</span>;</span><br><span class="line">		now = x, now.Merge(sta);</span><br><span class="line">		F = Mod(F + <span class="number">1L</span>L * h[p][sta.val()] * solve(p - <span class="number">1</span>, now));</span><br><span class="line">	&#125; <span class="keyword">return</span> F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"d.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"d.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">	n = Re; init(<span class="number">300</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ++cnt[Re];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">300</span>; i++) Num[i].init(i);</span><br><span class="line">	Pw[<span class="number">0</span>][<span class="number">0</span>] = Pw[<span class="number">1</span>][<span class="number">0</span>] = Pw[<span class="number">2</span>][<span class="number">0</span>] = Pw[<span class="number">3</span>][<span class="number">0</span>] = Pw[<span class="number">4</span>][<span class="number">0</span>] = Pw[<span class="number">5</span>][<span class="number">0</span>] = Pw[<span class="number">6</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		Pw[<span class="number">0</span>][i] = Mod(<span class="number">2L</span>L * Pw[<span class="number">0</span>][i - <span class="number">1</span>]);</span><br><span class="line">		Pw[<span class="number">1</span>][i] = Mod(<span class="number">3L</span>L * Pw[<span class="number">1</span>][i - <span class="number">1</span>]);</span><br><span class="line">		Pw[<span class="number">2</span>][i] = Mod(<span class="number">5L</span>L * Pw[<span class="number">2</span>][i - <span class="number">1</span>]);</span><br><span class="line">		Pw[<span class="number">3</span>][i] = Mod(<span class="number">7L</span>L * Pw[<span class="number">3</span>][i - <span class="number">1</span>]);</span><br><span class="line">		Pw[<span class="number">4</span>][i] = Mod(<span class="number">11L</span>L * Pw[<span class="number">4</span>][i - <span class="number">1</span>]);</span><br><span class="line">		Pw[<span class="number">5</span>][i] = Mod(<span class="number">13L</span>L * Pw[<span class="number">5</span>][i - <span class="number">1</span>]);</span><br><span class="line">		Pw[<span class="number">6</span>][i] = Mod(<span class="number">17L</span>L * Pw[<span class="number">6</span>][i - <span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">8</span>; i &lt;= tot; i++) &#123;</span><br><span class="line">		h[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">7</span>; j++) &#123;</span><br><span class="line">			<span class="keyword">int</span> p = pri[j + <span class="number">1</span>], prd = pri[i];</span><br><span class="line">			<span class="keyword">while</span>(prd * p &lt;= <span class="number">300</span>) ++mx[i][j], prd *= p;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = pri[i]; j &lt;= <span class="number">300</span>; j += pri[i]) &#123;</span><br><span class="line">			<span class="keyword">int</span> Prd = pw[cnt[j]] - <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(!Prd) <span class="keyword">continue</span>;</span><br><span class="line">			vis[j] = <span class="number">1</span>; Node sta, tmp;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> s = <span class="number">479</span>; ~s; s--) &#123;</span><br><span class="line">				<span class="keyword">if</span>(!h[i][s]) <span class="keyword">continue</span>;</span><br><span class="line">				sta.unlock(s), sta.Merge(Num[j]);</span><br><span class="line">				Add(h[i][sta.val()], <span class="keyword">int</span>(Mod(<span class="number">1L</span>L * h[i][s] * Prd)));</span><br><span class="line">				sta = tmp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; --h[i][<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; <span class="number">480</span>; s++)</span><br><span class="line">			h[i][s] = Mod(<span class="number">1L</span>L * h[i][s] * pri[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	G[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">300</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(!vis[i]) &#123;</span><br><span class="line">			<span class="keyword">int</span> Prd = pw[cnt[i]] - <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(!Prd) <span class="keyword">continue</span>;</span><br><span class="line">			Node sta; sta = Num[i];</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> a0 = <span class="number">8</span>; ~a0; --a0)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> a1 = <span class="number">5</span>; ~a1; --a1)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> a2 = <span class="number">3</span>; ~a2; --a2)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> a3 = <span class="number">2</span>; ~a3; --a3)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> a4 = <span class="number">2</span>; ~a4; --a4)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> a5 = <span class="number">2</span>; ~a5; --a5)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> a6 = <span class="number">2</span>; ~a6; --a6) &#123;</span><br><span class="line">				<span class="keyword">int</span> A0 = max(a0, sta.a[<span class="number">0</span>]);</span><br><span class="line">				<span class="keyword">int</span> A1 = max(a1, sta.a[<span class="number">1</span>]);</span><br><span class="line">				<span class="keyword">int</span> A2 = max(a2, sta.a[<span class="number">2</span>]);</span><br><span class="line">				<span class="keyword">int</span> A3 = max(a3, sta.a[<span class="number">3</span>]);</span><br><span class="line">				<span class="keyword">int</span> A4 = max(a4, sta.a[<span class="number">4</span>]);</span><br><span class="line">				<span class="keyword">int</span> A5 = max(a5, sta.a[<span class="number">5</span>]);</span><br><span class="line">				<span class="keyword">int</span> A6 = max(a6, sta.a[<span class="number">6</span>]);</span><br><span class="line">				Add(G[A0][A1][A2][A3][A4][A5][A6], <span class="keyword">int</span>(Mod(<span class="number">1L</span>L * Prd * G[a0][a1][a2][a3][a4][a5][a6])));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, solve(tot, Num[<span class="number">1</span>]));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码不长，也就$200$行，溜了溜了</p>
<p>鸽着的啊~</p>
]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>二分</tag>
        <tag>鸽~</tag>
        <tag>最短路</tag>
        <tag>考试</tag>
      </tags>
  </entry>
  <entry>
    <title>T20200929</title>
    <url>/2020/09/29/T20200929/</url>
    <content><![CDATA[<h1 id="T1维护序列"><a href="#T1维护序列" class="headerlink" title="T1维护序列"></a>T1<a href="https://www.luogu.com.cn/problem/P2023" target="_blank" rel="noopener">维护序列</a></h1><p>线段树二的板子题，没什么好说的吧。。。</p>
<blockquote>
<p>失算了，区间乘法可以乘$0$，我直接忽略了</p>
<p>对拍的时候，压根就没有生成$0$的数据，拍了好多组都没问题，结果。。。</p>
</blockquote>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls (x &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs (x &lt;&lt; 1| 1)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> __read()</span><br><span class="line">&#123;</span><br><span class="line">    int x(0), t(1);</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">'0'</span> || o &gt; <span class="string">'9'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">'-'</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">'0'</span> &amp;&amp; o &lt;= <span class="string">'9'</span>; o = getchar()) &#123;</span><br><span class="line">        x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, p;</span><br><span class="line"><span class="keyword">int</span> tagt[maxn &lt;&lt; <span class="number">2</span>], tagp[maxn &lt;&lt; <span class="number">2</span>], ans[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ans[x] = (ans[ls] + ans[rs]) % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tagt[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        ans[x] = __read() % p;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    Build(l, mid, ls);</span><br><span class="line">    Build(mid + <span class="number">1</span>, r, rs);</span><br><span class="line">    push_up(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> valt, <span class="keyword">int</span> valp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ans[x] = <span class="number">1l</span>l * ans[x] * valt % p;</span><br><span class="line">    ans[x] = (ans[x] + <span class="number">1l</span>l * valp * (r - l + <span class="number">1</span>) % p) % p;</span><br><span class="line">    tagp[x] = (<span class="number">1l</span>l * tagp[x] * valt % p + valp) % p;</span><br><span class="line">    tagt[x] = <span class="number">1l</span>l * tagt[x] * valt % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    f(ls, l, mid, tagt[x], tagp[x]);</span><br><span class="line">    f(rs, mid + <span class="number">1</span>, r, tagt[x], tagp[x]);</span><br><span class="line">    tagt[x] = <span class="number">1</span>, tagp[x] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> tl, <span class="keyword">int</span> tr, <span class="keyword">int</span> valt, <span class="keyword">int</span> valp, <span class="keyword">int</span> x = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= tl &amp;&amp; r &lt;= tr) &#123;</span><br><span class="line">        f(x, l, r, valt, valp);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    push_down(x, l, r);</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (tl &lt;= mid) update(l, mid, tl, tr, valt, valp, ls);</span><br><span class="line">    <span class="keyword">if</span> (tr &gt; mid) update(mid + <span class="number">1</span>, r, tl, tr, valt, valp, rs);</span><br><span class="line">    push_up(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> tl, <span class="keyword">int</span> tr, <span class="keyword">int</span> x = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= tl &amp;&amp; r &lt;= tr) <span class="keyword">return</span> ans[x] % p;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    push_down(x, l, r);</span><br><span class="line">    <span class="function">ll <span class="title">res</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (tl &lt;= mid) res = Query(l, mid, tl, tr, ls);</span><br><span class="line">    <span class="keyword">if</span> (tr &gt; mid) res = (res + Query(mid + <span class="number">1</span>, r, tl, tr, rs)) % p;</span><br><span class="line">    <span class="keyword">return</span> res % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = __read(), p = __read();</span><br><span class="line">    Build(<span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">int</span> m = __read();</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="keyword">int</span> opt = __read(), l = __read(), r = __read();</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">3</span>) <span class="built_in">printf</span> (<span class="string">"%d\n"</span>, Query(<span class="number">1</span>, n, l, r) % p);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = __read();</span><br><span class="line">            update(<span class="number">1</span>, n, l, r, <span class="number">1</span>, x);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> x = __read();</span><br><span class="line">            update(<span class="number">1</span>, n, l, r, x, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T2公路修建"><a href="#T2公路修建" class="headerlink" title="T2公路修建"></a>T2<a href="https://www.luogu.com.cn/problem/P2323" target="_blank" rel="noopener">公路修建</a></h1><p>最小生成树，其实我觉得应该排两次序才能保证答案的正确性</p>
<p>但就是过了，就不用管了</p>
<h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> __read()</span><br><span class="line">&#123;</span><br><span class="line">    int x(0), t(1);</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">'0'</span> || o &gt; <span class="string">'9'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">'-'</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">'0'</span> &amp;&amp; o &lt;= <span class="string">'9'</span>; o = getchar()) &#123;</span><br><span class="line">        x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, id;</span><br><span class="line">    <span class="keyword">int</span> val[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;T) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (val[<span class="number">0</span>] ^ T.val[<span class="number">0</span>]) <span class="keyword">return</span> val[<span class="number">0</span>] &lt; T.val[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> val[<span class="number">1</span>] &lt; T.val[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edge[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">OPT</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id, c;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> OPT &amp;t) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id &lt; t.id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Ans[maxn], Tmp[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_f</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (f[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> f[x] = get_f(f[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Check</span><span class="params">(<span class="keyword">int</span> lim)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span> (Tmp, <span class="number">0</span>, <span class="keyword">sizeof</span> Tmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) f[i] = i;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cnt</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (edge[i].val[<span class="number">0</span>] &gt; lim) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> fx = get_f(edge[i].u), fy = get_f(edge[i].v);</span><br><span class="line">        <span class="keyword">if</span> (fx == fy) <span class="keyword">continue</span>;</span><br><span class="line">        f[fx] = fy;</span><br><span class="line">        Tmp[++cnt] = &#123;edge[i].id, <span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cnt &lt; k) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (edge[i].val[<span class="number">1</span>] &gt; lim) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> fx = get_f(edge[i].u), fy = get_f(edge[i].v);</span><br><span class="line">        <span class="keyword">if</span> (fx == fy) <span class="keyword">continue</span>;</span><br><span class="line">        f[fx] = fy;</span><br><span class="line">        Tmp[++cnt] = &#123;edge[i].id, <span class="number">2</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// printf ("%d\n", cnt);</span></span><br><span class="line">    <span class="keyword">return</span> cnt == (n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = __read(), k = __read(), m = __read();</span><br><span class="line">    int l(0), r(30000), ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        edge[i].u = __read(), edge[i].v = __read();</span><br><span class="line">        edge[i].val[<span class="number">0</span>] = __read(), edge[i].val[<span class="number">1</span>] = __read();</span><br><span class="line">        edge[i].id = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort (edge + <span class="number">1</span>, edge + m + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (Check(mid)) &#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(Ans, Tmp, <span class="keyword">sizeof</span> (Ans));</span><br><span class="line">            ans = mid;</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    sort (Ans + <span class="number">1</span>, Ans + n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"%d %d\n"</span>, Ans[i].id, Ans[i].c);</span><br><span class="line"></span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T3三色二叉树"><a href="#T3三色二叉树" class="headerlink" title="T3三色二叉树"></a>T3<a href="https://www.luogu.com.cn/problem/P2585" target="_blank" rel="noopener">三色二叉树</a></h1><p>看一眼就可以开始乱写的$Dp$</p>
<p>无脑乱搞即可</p>
<h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> __read()</span><br><span class="line">&#123;</span><br><span class="line">    int x(0), t(1);</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">'0'</span> || o &gt; <span class="string">'9'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">'-'</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">'0'</span> &amp;&amp; o &lt;= <span class="string">'9'</span>; o = getchar()) &#123;</span><br><span class="line">        x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">int</span> mx[maxn][<span class="number">3</span>], mn[maxn][<span class="number">3</span>];</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = ++id, size = s[p] - <span class="string">'0'</span>;</span><br><span class="line">    mx[p][<span class="number">0</span>] = mn[p][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> son[<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">        son[i] = dfs();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">1</span>) &#123;</span><br><span class="line">        mx[p][<span class="number">0</span>] = max(mx[son[<span class="number">0</span>]][<span class="number">1</span>], mx[son[<span class="number">0</span>]][<span class="number">2</span>]) + <span class="number">1</span>;</span><br><span class="line">        mx[p][<span class="number">1</span>] = max(mx[son[<span class="number">0</span>]][<span class="number">0</span>], mx[son[<span class="number">0</span>]][<span class="number">2</span>]);</span><br><span class="line">        mx[p][<span class="number">2</span>] = max(mx[son[<span class="number">0</span>]][<span class="number">0</span>], mx[son[<span class="number">0</span>]][<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        mn[p][<span class="number">0</span>] = min(mn[son[<span class="number">0</span>]][<span class="number">1</span>], mn[son[<span class="number">0</span>]][<span class="number">2</span>]) + <span class="number">1</span>;</span><br><span class="line">        mn[p][<span class="number">1</span>] = min(mn[son[<span class="number">0</span>]][<span class="number">0</span>], mn[son[<span class="number">0</span>]][<span class="number">2</span>]);</span><br><span class="line">        mn[p][<span class="number">2</span>] = min(mn[son[<span class="number">0</span>]][<span class="number">0</span>], mn[son[<span class="number">0</span>]][<span class="number">1</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (size == <span class="number">2</span>) &#123;</span><br><span class="line">        mx[p][<span class="number">0</span>] = max(mx[son[<span class="number">0</span>]][<span class="number">1</span>] + mx[son[<span class="number">1</span>]][<span class="number">2</span>], mx[son[<span class="number">0</span>]][<span class="number">2</span>] + mx[son[<span class="number">1</span>]][<span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">        mx[p][<span class="number">1</span>] = max(mx[son[<span class="number">0</span>]][<span class="number">0</span>] + mx[son[<span class="number">1</span>]][<span class="number">2</span>], mx[son[<span class="number">0</span>]][<span class="number">2</span>] + mx[son[<span class="number">1</span>]][<span class="number">0</span>]);</span><br><span class="line">        mx[p][<span class="number">2</span>] = max(mx[son[<span class="number">0</span>]][<span class="number">1</span>] + mx[son[<span class="number">1</span>]][<span class="number">0</span>], mx[son[<span class="number">0</span>]][<span class="number">0</span>] + mx[son[<span class="number">1</span>]][<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        mn[p][<span class="number">0</span>] = min(mn[son[<span class="number">0</span>]][<span class="number">1</span>] + mn[son[<span class="number">1</span>]][<span class="number">2</span>], mn[son[<span class="number">0</span>]][<span class="number">2</span>] + mn[son[<span class="number">1</span>]][<span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">        mn[p][<span class="number">1</span>] = min(mn[son[<span class="number">0</span>]][<span class="number">0</span>] + mn[son[<span class="number">1</span>]][<span class="number">2</span>], mn[son[<span class="number">0</span>]][<span class="number">2</span>] + mn[son[<span class="number">1</span>]][<span class="number">0</span>]);</span><br><span class="line">        mn[p][<span class="number">2</span>] = min(mn[son[<span class="number">0</span>]][<span class="number">1</span>] + mn[son[<span class="number">1</span>]][<span class="number">0</span>], mn[son[<span class="number">0</span>]][<span class="number">0</span>] + mn[son[<span class="number">1</span>]][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%s"</span>, s + <span class="number">1</span>);</span><br><span class="line">    dfs();</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"%d %d\n"</span>, max(mx[<span class="number">1</span>][<span class="number">0</span>], max(mx[<span class="number">1</span>][<span class="number">1</span>], mx[<span class="number">1</span>][<span class="number">2</span>])), min(mn[<span class="number">1</span>][<span class="number">0</span>], min(mn[<span class="number">1</span>][<span class="number">1</span>], mn[<span class="number">1</span>][<span class="number">2</span>])));</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T4采花"><a href="#T4采花" class="headerlink" title="T4采花"></a>T4<a href="https://www.luogu.com.cn/problem/P4113" target="_blank" rel="noopener">采花</a></h1><p>这个稍微难想一点点</p>
<p>画图吧</p>
<p><img src="https://s1.ax1x.com/2020/09/29/0e30kn.png" alt=""></p>
<p>那么就可以只维护左端点，然后感觉一下就完了</p>
<h2 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> __read()</span><br><span class="line">&#123;</span><br><span class="line">    int x(0), t(1);</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">'0'</span> || o &gt; <span class="string">'9'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">'-'</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">'0'</span> &amp;&amp; o &lt;= <span class="string">'9'</span>; o = getchar()) &#123;</span><br><span class="line">        x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, c, m, p(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> pre[maxn][<span class="number">2</span>], lst[maxn];</span><br><span class="line"><span class="keyword">int</span> sum[maxn], clo[maxn];</span><br><span class="line"><span class="keyword">int</span> ans[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x &lt;= n) &#123;</span><br><span class="line">        sum[x] += val;</span><br><span class="line">        x += lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ans</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (x) &#123;</span><br><span class="line">        ans += sum[x];</span><br><span class="line">        x -= lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, id;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;t) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> r &lt; t.r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;que[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = __read(), c = __read(), m = __read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        clo[i] = __read();</span><br><span class="line">        pre[i][<span class="number">0</span>] = lst[clo[i]];</span><br><span class="line">        pre[i][<span class="number">1</span>] = pre[pre[i][<span class="number">0</span>]][<span class="number">0</span>];</span><br><span class="line">        lst[clo[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        que[i].l = __read(), que[i].r = __read();</span><br><span class="line">        que[i].id = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort (que + <span class="number">1</span>, que + m + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (p &lt;= que[i].r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pre[p][<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pre[p][<span class="number">1</span>]) update(pre[p][<span class="number">1</span>], <span class="number">-1</span>);</span><br><span class="line">                update(pre[p][<span class="number">0</span>], <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ++p;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[que[i].id] = query(que[i].r) - query(que[i].l - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) <span class="built_in">printf</span> (<span class="string">"%d\n"</span>, ans[i]);</span><br><span class="line">    <span class="comment">// system("pause");</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5 3 5</span></span><br><span class="line"><span class="comment">1 2 2 3 1</span></span><br><span class="line"><span class="comment">1 5</span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">2 2</span></span><br><span class="line"><span class="comment">2 3</span></span><br><span class="line"><span class="comment">3 5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>二分</tag>
        <tag>数据结构</tag>
        <tag>生成树</tag>
        <tag>考试</tag>
      </tags>
  </entry>
  <entry>
    <title>Telephone Line S</title>
    <url>/2020/09/15/Telephone-Line-S/</url>
    <content><![CDATA[<h1 id="Telephone-Line-S"><a href="#Telephone-Line-S" class="headerlink" title="Telephone Line S"></a><a href="https://ac.nowcoder.com/acm/problem/24950" target="_blank" rel="noopener">Telephone Line S</a></h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意:"></a>题目大意:</h2><p>首先你有一张图，问你从$1$到$n$的路径中第$k+1$条最大的边最小有多大</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>这个题很显然是可以二分答案的</p>
<p>但是我们考虑换一种做法：分层图</p>
<p>那么就是跨层的时候让其代价为$0$，那么一共就有$k+1$层图</p>
<p>在跑一个类似最短路的东西就可以了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x7f7f7f7f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> __read()</span><br><span class="line">&#123;</span><br><span class="line">    int x(0), t(1);</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">'0'</span> || o &gt; <span class="string">'9'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">'-'</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">'0'</span> &amp;&amp; o &lt;= <span class="string">'9'</span>; o = getchar()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, p, k, cur;</span><br><span class="line"><span class="keyword">int</span> head[maxn], edge[maxn], __prev[maxn], cost[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _addedge(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span><br><span class="line">&#123;</span><br><span class="line">    __prev[++cur] = head[u];</span><br><span class="line">    head[u] = cur;</span><br><span class="line">    edge[cur] = v;</span><br><span class="line">    cost[cur] = w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> __addedge(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span><br><span class="line">&#123;</span><br><span class="line">    _addedge(u, v, w), _addedge(v, u, w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dis[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">SPFA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span> (dis, <span class="number">0x7f</span>, <span class="keyword">sizeof</span> dis);</span><br><span class="line">    <span class="built_in">deque</span> &lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    Q.push_back(<span class="number">1</span>);</span><br><span class="line">    dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> now = Q.front();</span><br><span class="line">        Q.pop_front();</span><br><span class="line">        vis[now] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[now]; i; i = __prev[i]) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> v = edge[i];</span><br><span class="line">            <span class="keyword">if</span> (dis[v] &lt;= max(dis[now], cost[i])) <span class="keyword">continue</span>;</span><br><span class="line">            dis[v] = max(dis[now], cost[i]);</span><br><span class="line">            <span class="keyword">if</span> (vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (Q.empty() || dis[v] &lt;= dis[Q.front()]) Q.push_front(v);</span><br><span class="line">            <span class="keyword">else</span> Q.push_back(v);</span><br><span class="line">            vis[v] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dis[n * (k + <span class="number">1</span>)] == inf) <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span> (<span class="string">"%d\n"</span>, dis[n * (k + <span class="number">1</span>)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = __read(), p = __read(), k = __read();</span><br><span class="line">    <span class="keyword">while</span> (p--) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = __read(), v = __read(), a = __read();</span><br><span class="line">        __addedge(u, v, a);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">            __addedge(i * n + u, i * n + v, a);</span><br><span class="line">            _addedge((i - <span class="number">1</span>) * n + u, i * n + v, <span class="number">0</span>);</span><br><span class="line">            _addedge((i - <span class="number">1</span>) * n + v, i * n + u, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SPFA();</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>最短路</tag>
        <tag>分层图</tag>
      </tags>
  </entry>
  <entry>
    <title>Tree</title>
    <url>/2020/09/15/Tree/</url>
    <content><![CDATA[<h1 id="Tree"><a href="#Tree" class="headerlink" title="Tree"></a><a href="https://ac.nowcoder.com/acm/problem/112609" target="_blank" rel="noopener">Tree</a></h1><h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><ul>
<li>首先，我们有$Q$次操作</li>
</ul>
<blockquote>
<ul>
<li>操作$1$：在节点$R$下面再加一个权值为$W$的点</li>
<li>操作$2$：询问从点$X$开始往上走，（每次遇到权值大于当前选过的最后一个点的点必定会选），问最多能选多少点</li>
</ul>
</blockquote>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>我们可以很容易的发现，我们选中的点一定是一个单调不下降序列</p>
<p>那么就是说，我们可以稍微改动一下操作一，让每一条链都一定是单调不上升的（从根出发的链）</p>
<p>然后，我们每次加入的点必定不会是已经存在的某个点的祖先，所以我们改变他的位置对原来的树是没有影响的</p>
<p>若有节点成为了这个被我们认为操作的节点的儿子，它的值依赖于我们人为操作的那个点，所以这个答案也不会因为我们的操作出现问题</p>
<p>那么我们就可以在加入节点的时候，找到第一个权值大于该节点的点做为这个点的父节点</p>
<p>顺便跟新一下前缀和</p>
<p>这个用倍增实现就好了<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddPoint</span><span class="params">(ll u, ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll v = ++cnt;</span><br><span class="line">    wight[v] = p;</span><br><span class="line">    <span class="keyword">if</span> (wight[u] &gt;= wight[v]) &#123;</span><br><span class="line">        father[v][<span class="number">0</span>] = u;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (ll i = <span class="number">19</span>; ~i; --i)</span><br><span class="line">            <span class="keyword">if</span> (wight[father[u][i]] &lt; wight[v])</span><br><span class="line">                u = father[u][i];</span><br><span class="line">        father[v][<span class="number">0</span>] = father[u][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    sum[v][<span class="number">0</span>] = wight[father[v][<span class="number">0</span>]]; </span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt; <span class="number">20</span>; ++i) &#123;</span><br><span class="line">        father[v][i] = father[father[v][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (sum[v][i - <span class="number">1</span>] &lt; inf &amp;&amp; father[v][i]) &#123;</span><br><span class="line">            sum[v][i] = sum[v][i - <span class="number">1</span>] + sum[father[v][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后查询的话，能跳就跳，每次向上跳了更新一下限制即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Query</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (wight[x] &gt; limit) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="function">ll <span class="title">ans</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    limit -= wight[x];</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">19</span>; ~i; --i)</span><br><span class="line">        <span class="keyword">if</span> (sum[x][i] &lt;= limit) &#123;</span><br><span class="line">            ans += (<span class="number">1</span> &lt;&lt; i);<span class="comment">//向上跳了2的i次方层，那就有2的i次方个点</span></span><br><span class="line">            limit -= sum[x][i];</span><br><span class="line">            x = father[x][i];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll maxn = <span class="number">4e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> ll inf = <span class="number">0x6f6f6f6f6f6f6f6f</span>;</span><br><span class="line"></span><br><span class="line">ll father[maxn][<span class="number">20</span>], wight[maxn], cnt(<span class="number">1</span>);</span><br><span class="line">ll sum[maxn][<span class="number">20</span>], lastans, limit;</span><br><span class="line">ll Q, Opt, X, Y;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddPoint</span><span class="params">(ll u, ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll v = ++cnt;</span><br><span class="line">    wight[v] = p;</span><br><span class="line">    <span class="keyword">if</span> (wight[u] &gt;= wight[v]) &#123;</span><br><span class="line">        father[v][<span class="number">0</span>] = u;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (ll i = <span class="number">19</span>; ~i; --i)</span><br><span class="line">            <span class="keyword">if</span> (wight[father[u][i]] &lt; wight[v])</span><br><span class="line">                u = father[u][i];</span><br><span class="line">        father[v][<span class="number">0</span>] = father[u][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    sum[v][<span class="number">0</span>] = wight[father[v][<span class="number">0</span>]]; </span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt; <span class="number">20</span>; ++i) &#123;</span><br><span class="line">        father[v][i] = father[father[v][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (sum[v][i - <span class="number">1</span>] &lt; inf &amp;&amp; father[v][i]) &#123;</span><br><span class="line">            sum[v][i] = sum[v][i - <span class="number">1</span>] + sum[father[v][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Query</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (wight[x] &gt; limit) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="function">ll <span class="title">ans</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    limit -= wight[x];</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">19</span>; ~i; --i)</span><br><span class="line">        <span class="keyword">if</span> (sum[x][i] &lt;= limit) &#123;</span><br><span class="line">            ans += (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">            limit -= sum[x][i];</span><br><span class="line">            x = father[x][i];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ll <span class="title">x</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">o</span><span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">'0'</span> || o &gt; <span class="string">'9'</span>) o = getchar();</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">'0'</span> &amp;&amp; o &lt;= <span class="string">'9'</span>; o = getchar()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span> (sum, <span class="number">0x6f</span>, <span class="keyword">sizeof</span> sum);</span><br><span class="line">    wight[<span class="number">0</span>] = inf;</span><br><span class="line">    Q = Read();</span><br><span class="line">    <span class="keyword">while</span> (Q--)</span><br><span class="line">    &#123;</span><br><span class="line">        Opt = Read(), X = Read() ^ lastans, Y = Read() ^ lastans;</span><br><span class="line">        <span class="keyword">if</span> (Opt == <span class="number">1</span>) AddPoint(X, Y);</span><br><span class="line">        <span class="keyword">else</span> limit = Y, <span class="built_in">printf</span> (<span class="string">"%lld\n"</span>, lastans = Query(X));</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title>ToMyself</title>
    <url>/2020/07/23/ToMyself/</url>
    <content><![CDATA[<p>我在怕什么?</p>
<p>我在躲什么?</p>
<p>我真的就甘愿沦落至此吗?</p>
<p>不 ! ! !</p>
<p>这不是我 ! ! !</p>
<p>每个孩子, 都有梦想 !</p>
<p>有些孩子, 在一次次挫折中, 磨练自己的意志, 每一次的失败, 都为其最终的成功留下了不可磨灭的印记 ! ! !</p>
<p>有些孩子, 经受不住那折磨, 耐不住寂寞. 就如那八戒一般, 没有守住自己的本性, 没经受住菩萨的诱惑, 险些改变了自己的心境. 如果那不是菩萨, 不是菩萨考验了, 磨砺了八戒的心性, 八戒也就不会那么可爱了.</p>
<p>依稀记得, 人生第一次考试, 是在幼儿园吧. 印象中, 那张试卷上, 没有几道题是做对了的 . </p>
<p>但是, 那时的我, 对小学没有害怕, 反而表现出的是浓浓的兴趣 !</p>
<p>印像之中, 三年级以前, 小学生活是愉快 而又轻松的 .</p>
<p>从我现在的角度看来, 小学时的我, 喜欢在语文课上为大家朗诵诗歌, 是一件多么不可思议的事情 .</p>
<p>似乎三年级以后, 那个爱朗诵的少年不复存在, 那个阳光的, 爱笑的少年不复存在 !</p>
<p>取而代之的, 是没有灵魂的学习, 没有思想的记背, 被语文笼罩在黑暗之下的, 从内心深处滋生出对语文老师的仇恨, 对于语文的厌恶的男孩 .</p>
<blockquote>
<p>三年级时, 班上来了新生, 他们没有校服 . </p>
<p>恰好我的校服也不大合身了, 班主任就让我去带他们买校服 .</p>
<p>又过了很久, 突然有一天, 班主任就在大课间, 我们排队批改数学作业的时候, 班主任涨红了脸, 大叫 : “李孟珂, 给**过来 ! “</p>
<p>唾液横飞, 全班都看见我被班主任撕裂的样子 .</p>
<p>至于她骂的啥, 我是毫无印像, 貌似是因为新生的校服出了点问题, 然后她就把所有的怒火全泼洒在一个孩子身上 .</p>
<p>没有经历过世面的, 幼小的, 无助的心, 彻底的碎了 !</p>
<p>回家以后, 那小手捧着那被撕碎的心, 默默地藏起来, 也不敢告诉妈妈, 因为害怕, 害怕再受到一次如此的重创 .</p>
<p>身上的伤, 好了会结痂, 会脱落, 可能没有人会看出来. 但伤口深了, 会留下长久的印记, 这就是岁月?</p>
</blockquote>
<p>似乎是这段时间, 我开始撒谎, 这也便是根源所在了 .</p>
<blockquote>
<p>小心翼翼地, 没有自我, 活成了别人的样子 .</p>
<p>被别人夸 : “你真听话”, “你真乖”, 当时是多么自豪啊, 听话就能被表扬 !</p>
<p>现在, 莫名的觉得恶心 : “听话”的孩子就是真的好孩子?</p>
<p>莫名的觉得当时的自己很蠢</p>
</blockquote>
<p>而就是这种”虚荣”, 让”李孟珂”不再是”李孟珂”</p>
<p>变了 ?</p>
<blockquote>
<p>现在看来, 如果当时能够看一些书, 哪怕是”童话”, 也能够进行自我救赎 !</p>
<p>可是没有如果 !</p>
<p>不晚! 还有&lt;&lt;悲惨世界&gt;&gt;&lt;&lt;复活&gt;&gt;能指引我”复活”</p>
</blockquote>
<p>变了 .</p>
<p>我开始听信大人的话 : 你很聪明, 你很有天资</p>
<p>其实不然 !</p>
<p>我认为我自己愚蠢到了极致 !</p>
<p>会做两道奥数题, 有什么了不起的 ?</p>
<p>能拯救自我吗 ? 能找回那个李孟珂吗 ? 能改变这个世界吗 ?</p>
<p>没有一个是肯定的 .</p>
<p>只是做的越多, 陷得越深罢了, 因为这只会让你误认为 :”哦, 我好像真的好厉害似的”</p>
<p>其实我什么都不会 .</p>
<p>就算我会的再多, 也是$log_11$, 完全不是你的 .</p>
<p>初中更是如此, 依葫芦画瓢, 数学物理就可以有能看过眼的成绩 .</p>
<p>信了鬼话, 就认为学好数理就能走天下了 .</p>
<blockquote>
<p>狗屁不通 !</p>
<p>人类社会, 是无比复杂的 .</p>
<p>所谓的科技, 不过是从政者用来维护政权的手段罢了 .</p>
<p>真正的科技, 是要分国际的, 是有着绝对的界限的, 不是你能用来与别人交流的 .</p>
<p>中国的历史能够传承, 不是因为科技, 是因为中国的文化 .</p>
<p>人文社会, 是科学发展的基础; 科学, 本与神话的作用相同: 解释世界万物运动的规律 .</p>
<p>但社会是复杂的, 有些东西就不再赘述了</p>
</blockquote>
<p>索性放弃语文的自主学习, 觉得会一点数学, 物理就够了 .</p>
<p>这错误的思想, 指引了我三年, 又三年 .</p>
<p>然而, 我什么都没有 .</p>
<p>到了高中, 我发现我引以为豪的东西, 不见了 .</p>
<p>我发现我一无是处 .</p>
<p>我什么都不是, 就如一粒尘埃 .</p>
<p>那种感觉, 怎讲 ?</p>
<p>有如你坚信多年的信仰, 有一天, 不攻自破, 信仰崩塌 !</p>
<p>整个人, 陷入混沌之中 !</p>
<p>我究竟是谁 ? </p>
<p>我该做什么 ?</p>
<p>我想要作什么 ?</p>
<p>刹那间, 我什么都不知道了 !</p>
<p>高一, 便如此就过去了 !</p>
<p>先在, 我是一名高二的学生了 .</p>
<p>高二了, 人生第一道分水岭 ?</p>
<p>我在怕什么 ? 怕我努力了, 仍不会成功 ? 怕别人嘲笑 : “你真是个菜鸡 ! “ ?</p>
<p>怕啥 ? 你在不开始努力, 怕你后悔都来不及了 !</p>
<p>怕啥 ?  菜鸡又如何, 菜鸡也可以有自己的骄傲, 你不是为别人活着 !</p>
<p>我在躲啥 ? 有什么是真的可以躲过去的吗 ?</p>
<p>如果真的什么都可以逃避, 那你就不会出现在这个世界上 .</p>
<p>因为如果真的可以逃避, 你也可以选择不被诞生; 诞生意味着, 你得接受很多, 很多 .</p>
<p>不要再逃避了, 站出来, 做最优秀的自己, 然后骄傲的活着 !</p>
<p>我承认自己”不优秀”, 我承认”不够聪慧”, 我承认, 我离别人的差距太大 太大!</p>
<p>但是我不甘 !</p>
<p>这是我自己造成的结果, 结果必然由我自己承担 .</p>
<p>加油 ! </p>
<p>不甘, 就拿出你的意志; 不甘, 就拿出你的气魄; 不甘, 那就拿出你的行动 .</p>
<p>你已经对自己够失望了, 难道, 你就要将自己彻底沦陷吗 ? </p>
<p>不 !</p>
<p>你不会如此轻易被打败 !</p>
<p>是的, 你不会 !</p>
<p>对吗 ?</p>
]]></content>
      <tags>
        <tag>秘密</tag>
      </tags>
  </entry>
  <entry>
    <title>[USACO19DEC]Greedy Pie Eaters P</title>
    <url>/2020/09/24/USACO19DEC-Greedy-Pie-Eaters-P/</url>
    <content><![CDATA[<h1 id="USACO19DEC-Greedy-Pie-Eaters-P"><a href="#USACO19DEC-Greedy-Pie-Eaters-P" class="headerlink" title="[USACO19DEC]Greedy Pie Eaters P"></a><a href="https://www.luogu.com.cn/problem/P5851" target="_blank" rel="noopener">[USACO19DEC]Greedy Pie Eaters P</a></h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>有$n$个派可以吃</p>
<p>有$m$头牛来吃</p>
<p>第$m$头牛的重量为$w_i$，这头牛要吃的区间为$[l_i,r_i]$</p>
<p>然后你是要保证每头牛都有的吃</p>
<p>那么你可以安排这些牛吃派的顺序</p>
<p>最后会得到这样一个序列$c_1,c_2\cdots c_n$</p>
<p>求：</p>
<script type="math/tex; mode=display">
ans = max(\sum_{i=1}^nw_{c_i})</script><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>看上去像个贪心啥的</p>
<p>但是贪心不能保证每头牛都有得吃，所以我们考虑$Dp$</p>
<p>参考<a href="http://www.usaco.org/current/data/sol_pieaters_platinum_dec19.html" target="_blank" rel="noopener">官方题解</a></p>
<p><img src="https://s1.ax1x.com/2020/09/24/0pYJ2R.png" alt=""></p>
<p>可以，就是这个意思</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">300</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> __read()</span><br><span class="line">&#123;</span><br><span class="line">    int x(0), t(1);</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">'0'</span> || o &gt; <span class="string">'9'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">'-'</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">'0'</span> &amp;&amp; o &lt;= <span class="string">'9'</span>; o = getchar()) &#123;</span><br><span class="line">        x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[maxn][maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> g[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = __read(), m = __read();</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="keyword">int</span> w = __read(), l = __read(), r = __read();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p = l; p &lt;= r; ++p)</span><br><span class="line">            f[p][l][r] = w;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">1</span>; p &lt;= n; ++p)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = p; l &gt;= <span class="number">1</span>; --l)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> r = p; r &lt;= n; ++r)</span><br><span class="line">                f[p][l - <span class="number">1</span>][r] = max(f[p][l - <span class="number">1</span>][r], f[p][l][r]),</span><br><span class="line">                f[p][l][r + <span class="number">1</span>] = max(f[p][l][r + <span class="number">1</span>], f[p][l][r]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">1</span>; r &lt;= n; ++r)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = r; l; --l)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = l; k &lt;= r; ++k)</span><br><span class="line">                g[l][r] = max(g[l][r], g[l][k - <span class="number">1</span>] + g[k + <span class="number">1</span>][r] + f[k][l][r]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"%d\n"</span>, g[<span class="number">1</span>][n]);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>区间Dp</tag>
      </tags>
  </entry>
  <entry>
    <title>UVA11475</title>
    <url>/2020/09/04/UVA11475/</url>
    <content><![CDATA[<h1 id="UVA11475-Extend-to-Palindrome"><a href="#UVA11475-Extend-to-Palindrome" class="headerlink" title="UVA11475[Extend to Palindrome]"></a><a href="https://www.luogu.com.cn/problem/UVA11475" target="_blank" rel="noopener">UVA11475[Extend to Palindrome]</a></h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>给你一个字符串$S$，让你找一个长度最小的回文串$P$使得$S$是$P$的前缀</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>我们能够构造出的最简单的回文串$P\prime=S+reverse(S)$</p>
<p>显然$P\prime$要尽量的小，那么$S$与$reverse(S)$就要尽可能地重叠</p>
<p>观察发现，尽可能重叠，其实是求得$S$末尾的最大的回文串</p>
<p>所以就有很多大佬用什么$\text{manacher、SA}$然而我都不会</p>
<p>那么我们重新想一想回文的定义，简单地说就是<del>正着读，倒着读是一样的</del></p>
<p>那么我们可以把$S$反转一下得到$S\prime$，做一次$\text{KMP}$看在$S$左后一个字符的最大匹配</p>
<p>那么这个值就是$S$后缀的最长回文串，那么需要补上的字符串不就可以直接输出了？</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> a[maxn], b[maxn];</span><br><span class="line"><span class="keyword">int</span> len, last, kmp[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ac</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    len = <span class="built_in">strlen</span>(a + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memset</span> (kmp, <span class="number">0</span>, <span class="keyword">sizeof</span> kmp);</span><br><span class="line">    <span class="built_in">memset</span> (b, <span class="number">0</span>, <span class="keyword">sizeof</span> b);</span><br><span class="line">    <span class="built_in">memcpy</span>(b + <span class="number">1</span>, a + <span class="number">1</span>, len);</span><br><span class="line">    reverse(b + <span class="number">1</span>, b + len + <span class="number">1</span>);</span><br><span class="line">    last = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= len; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (last &amp;&amp; b[last + <span class="number">1</span>] != b[i]) last = kmp[last];</span><br><span class="line">        <span class="keyword">if</span> (b[last + <span class="number">1</span>] == b[i]) ++last;</span><br><span class="line">        kmp[i] = last;</span><br><span class="line">    &#125;</span><br><span class="line">    last = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (last &amp;&amp; a[i] != b[last + <span class="number">1</span>]) last = kmp[last];</span><br><span class="line">        <span class="keyword">if</span> (a[i] == b[last + <span class="number">1</span>]) ++last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"%s%s\n"</span>, a + <span class="number">1</span>, b + last + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%s"</span>, a + <span class="number">1</span>))ac();</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>UVa11536 Smallest Sub-Array</title>
    <url>/2020/09/17/UVa11536-Smallest-Sub-Array/</url>
    <content><![CDATA[<h1 id="UVa11536-Smallest-Sub-Array"><a href="#UVa11536-Smallest-Sub-Array" class="headerlink" title="UVa11536 Smallest Sub-Array"></a><a href="https://www.luogu.com.cn/problem/UVA11536" target="_blank" rel="noopener">UVa11536 Smallest Sub-Array</a></h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定一个长度为$n$的序列, 然你找一个最小的区间, 是的这个区间内包含了$[1,k]$</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>易证的我们可以贪心的去找这个区间</p>
<p>贪心方案就是尽可能的让没用的数字不在这个区间内</p>
<ul>
<li><p>大于$k$的数可以直接不考虑它作为左右端点</p>
</li>
<li><p>如果当前左端点为$l$, 且$[l+1,r]$范围内存在$a[l]$, 那么$a[l]$也不用考虑作为任何端点</p>
</li>
</ul>
<p>那么我们可以从$1\sim n$扫描一遍,这样枚举右端点, 在贪心得将左端点向右移,如果区间符合条件, 那么更新答案即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> __read()</span><br><span class="line">&#123;</span><br><span class="line">    int q(0), t(1);</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">'0'</span> || o &gt; <span class="string">'9'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">'-'</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">'0'</span> &amp;&amp; o &lt;= <span class="string">'9'</span>; o = getchar()) </span><br><span class="line">        q = (q &lt;&lt; <span class="number">1</span>) + (q &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> q * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> q[maxn] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> t[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen (<span class="string">".out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> T = __read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> test = <span class="number">1</span>; test &lt;= T; ++test) &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="built_in">memset</span> (t, <span class="number">0</span>, <span class="keyword">sizeof</span> t);<span class="comment">//每次都要清空桶</span></span><br><span class="line">        int ans(maxn), cnt(0);</span><br><span class="line">        <span class="keyword">int</span> n = __read(), m = __read(), k = __read();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;= n; ++i) </span><br><span class="line">        	q[i] = (q[i - <span class="number">1</span>] + q[i - <span class="number">2</span>] + q[i - <span class="number">3</span>]) % m + <span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (q[l] &gt; k &amp;&amp; l &lt;= n) ++l;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q[i] &gt; k) <span class="keyword">continue</span>;<span class="comment">//无用状态直接不用考虑</span></span><br><span class="line">            <span class="keyword">if</span> (!t[q[i]])++cnt;</span><br><span class="line">            t[q[i]]++;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; i &amp;&amp; (t[q[l]] &gt; <span class="number">1</span> || q[l] &gt; k)) </span><br><span class="line">            	t[q[l]]--, ++l;</span><br><span class="line">            <span class="keyword">if</span> (cnt == k) ans = min(ans, i - l + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"Case %d: "</span>, test);</span><br><span class="line">        <span class="keyword">if</span> (ans &lt; maxn) <span class="built_in">printf</span> (<span class="string">"%d\n"</span>, ans);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"sequence nai"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title>Working Out</title>
    <url>/2020/09/15/Working-Out/</url>
    <content><![CDATA[<h1 id="Working-Out"><a href="#Working-Out" class="headerlink" title="Working Out"></a><a href="https://ac.nowcoder.com/acm/problem/110489" target="_blank" rel="noopener">Working Out</a></h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意:"></a>题目大意:</h2><p>给定一个矩阵，每个点都有一个点权，让你求从矩阵中某一点到矩阵四个顶点的权值之和减去自己的四倍的值最大(就是这个点没有贡献)</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>我们画两张图，看看他们的路径，就会发现其实只有两种情况<br><strong>一</strong>:<br><img src="https://uploadfiles.nowcoder.com/files/20200908/675676897_1599549981026_wQibfx.md.png" alt=""><br><strong>二</strong>：<br><img src="https://uploadfiles.nowcoder.com/files/20200908/675676897_1599550140637_wQFl90.png" alt=""></p>
<p>就是说其实只有两种转移的方式</p>
<p>那么我们用4个数组分别记录到四个顶点的最大距离<br>然后再枚举每个点作为交点时的答案，不断更新</p>
<script type="math/tex; mode=display">
ans=\max_{1<i<n,1<j<m}(dp[1][i - 1][j] + dp[3][i + 1][j] + dp[2][i][j + 1] + dp[4][i][j - 1],dp[1][i][j - 1] + dp[3][i][j + 1] + dp[2][i - 1][j] + dp[4][i + 1][j])</script><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">5</span>][maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> n, m, ans, a[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">max_</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Read</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	int x(0), f = 1;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar();</span><br><span class="line">	<span class="keyword">while</span> (ch &lt; <span class="string">'0'</span> || ch &gt; <span class="string">'9'</span>) &#123; </span><br><span class="line">        <span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="number">48</span>), ch = getchar();</span><br><span class="line">	<span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = Read(), m = Read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) a[i][j] = Read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) </span><br><span class="line">            dp[<span class="number">1</span>][i][j] = max_(dp[<span class="number">1</span>][i - <span class="number">1</span>][j], dp[<span class="number">1</span>][i][j - <span class="number">1</span>]) + a[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = m; j &gt;= <span class="number">1</span>; --j) </span><br><span class="line">            dp[<span class="number">2</span>][i][j] = max_(dp[<span class="number">2</span>][i - <span class="number">1</span>][j], dp[<span class="number">2</span>][i][j + <span class="number">1</span>]) + a[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = m; j &gt;= <span class="number">1</span>; --j) </span><br><span class="line">            dp[<span class="number">3</span>][i][j] = max_(dp[<span class="number">3</span>][i + <span class="number">1</span>][j], dp[<span class="number">3</span>][i][j + <span class="number">1</span>]) + a[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) </span><br><span class="line">            dp[<span class="number">4</span>][i][j] = max_(dp[<span class="number">4</span>][i + <span class="number">1</span>][j], dp[<span class="number">4</span>][i][j - <span class="number">1</span>]) + a[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; m; ++j)</span><br><span class="line">            ans = max_ (ans, dp[<span class="number">1</span>][i - <span class="number">1</span>][j] + dp[<span class="number">3</span>][i + <span class="number">1</span>][j] + dp[<span class="number">2</span>][i][j + <span class="number">1</span>] + dp[<span class="number">4</span>][i][j - <span class="number">1</span>]), </span><br><span class="line">            ans = max_ (ans, dp[<span class="number">1</span>][i][j - <span class="number">1</span>] + dp[<span class="number">3</span>][i][j + <span class="number">1</span>] + dp[<span class="number">2</span>][i - <span class="number">1</span>][j] + dp[<span class="number">4</span>][i + <span class="number">1</span>][j]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Dp优化</tag>
      </tags>
  </entry>
  <entry>
    <title>JSOI平衡点</title>
    <url>/2020/07/24/%5BJSOI%5D%E5%B9%B3%E8%A1%A1%E7%82%B9/</url>
    <content><![CDATA[<h1 id="JSOI2004-平衡点-吊打XXX"><a href="#JSOI2004-平衡点-吊打XXX" class="headerlink" title="[JSOI2004]平衡点 / 吊打XXX"></a><a href="https://www.luogu.com.cn/problem/P1337" target="_blank" rel="noopener">[JSOI2004]平衡点 / 吊打XXX</a></h1><p>被吊打了啊 !</p>
<p><del>这道题, 看上去真的挺难的 .</del></p>
<p>简言之, 就是求平衡状态时, 中心点的位置 .</p>
<p>做出受力分析图, 我们可以看得出来, 这个点的位置, 其实与绳子是无关的, 每根绳的拉力, 也一定是等于重物的</p>
<p>所以, 我们可以先随机一个点, 求出这$n$根线对着个点的作用力的合力. 因为力的方向不好表示, 所以我们可以正交分解, 将力分解到$x$轴和$y$轴上去.</p>
<p>这个点必定会沿合力方向移动一定的距离, 直到合力为零. </p>
<p>但是, 我们在不用其他数学工具的情况下, 我们可以随机一个较大步长, 然后不断地缩小这个步长, 就可以越来越接近这个目标点了. </p>
<p>当某一次的移动前后的变化小于精度范围时, 那么我们就找到答案了.</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">1005</span>;</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">double</span> X, Y;</span><br><span class="line">bool Xf(1), Yf(1);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> X, Y, G;</span><br><span class="line">&#125;Points[Maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Solve</span><span class="params">(<span class="keyword">double</span> M)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    double x(0), y(0), Temp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        Temp = <span class="built_in">sqrt</span>((X - Points[i].X) * (X - Points[i].X) + (Y - Points[i].Y) * (Y - Points[i].Y));</span><br><span class="line">        <span class="keyword">if</span> (!Temp) <span class="keyword">continue</span>;</span><br><span class="line">        x += Points[i].G / Temp * (Points[i].X - X);</span><br><span class="line">        y += Points[i].G / Temp * (Points[i].Y - Y);</span><br><span class="line">    &#125;</span><br><span class="line">    Temp = <span class="built_in">sqrt</span>(x * x + y * y);</span><br><span class="line">    Y += M / Temp * y;</span><br><span class="line">    X += M / Temp * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">"%d %d %d"</span>, &amp;Points[i].X, &amp;Points[i].Y, &amp;Points[i].G);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> M = <span class="number">10000</span>, tx, ty;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tx = X, ty = Y;</span><br><span class="line">        Solve(M);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(tx - X) &lt; <span class="number">0.00001</span> &amp;&amp; <span class="built_in">abs</span>(ty - Y) &lt; <span class="number">0.00001</span>) <span class="keyword">break</span>;</span><br><span class="line">        M *= <span class="number">0.9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"%.3lf %.3lf\n"</span>, X, Y);</span><br><span class="line">    system (<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>几何</tag>
      </tags>
  </entry>
  <entry>
    <title>kmp</title>
    <url>/2020/06/24/kmp/</url>
    <content><![CDATA[<h1 id="模板KMP"><a href="#模板KMP" class="headerlink" title="模板KMP"></a><a href="https://www.luogu.com.cn/problem/P3375" target="_blank" rel="noopener"><strong>模板KMP</strong></a></h1><p>$KMP$简单的来是用一个串在另一个串中匹配</p>
<p>那么对于这样一个模板我们可以怎么处理呢?</p>
<p>假象现在我们在进行暴力匹配，此时情况如下:</p>
<script type="math/tex; mode=display">
s1="abcabc...."\\
s2="abcabb"....</script><p>可以看见现在的$s2$的最后一个$b$对齐的是$s1$的$c$</p>
<p>简单地说现在的$b$就是一个失配点</p>
<p>也就是说现在我们需要重新匹配</p>
<p>如果再从头开始的匹配的话显然有些浪费时间了</p>
<p>于是我们似乎可以就寻找上一个失配点的位置即$……b$的位置</p>
<p>于是我们找到了$ab$，也就是$s2$的开头的两个字符，然后继续这样匹配下去就可以了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">char</span> A[Maxn], B[Maxn];</span><br><span class="line"><span class="keyword">int</span> Last, LOA, LOB, KMP[Maxn];<span class="comment">//这个KMP数组就是记录上一个失配点的位置</span></span><br><span class="line"><span class="comment">//后面的代码就非常的浅显易懂了</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s %s"</span>, A + <span class="number">1</span>, B + <span class="number">1</span>);</span><br><span class="line">    LOA = <span class="built_in">strlen</span>(A + <span class="number">1</span>), LOB = <span class="built_in">strlen</span>(B + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= LOB; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (Last &amp;&amp; B[i] != B[Last + <span class="number">1</span>]) Last = KMP[Last];</span><br><span class="line">        <span class="keyword">if</span> (B[Last + <span class="number">1</span>] == B[i]) ++Last;</span><br><span class="line">        KMP[i] = Last;</span><br><span class="line">    &#125;</span><br><span class="line">    Last = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= LOA; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (Last &amp;&amp; A[i] != B[Last + <span class="number">1</span>]) Last = KMP[Last];</span><br><span class="line">        <span class="keyword">if</span> (B[Last + <span class="number">1</span>] == A[i]) ++Last;</span><br><span class="line">        <span class="keyword">if</span> (Last == LOB)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i - LOB + <span class="number">1</span>);</span><br><span class="line">            Last = KMP[Last];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= LOB; ++i) <span class="built_in">printf</span>(<span class="string">"%d "</span>, KMP[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>$\LaTeX$[置顶]</title>
    <url>/2223/10/22/latex/</url>
    <content><![CDATA[<h1 id="声调-变音符号"><a href="#声调-变音符号" class="headerlink" title="声调/变音符号"></a>声调/变音符号</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\dot&#123;a&#125; \ddot&#123;a&#125; \acute&#123;a&#125; \grave&#123;a&#125;$</span><br></pre></td></tr></table></figure>
<p> $\dot{a}\quad \ddot{a}\quad \acute{a}\quad \grave{a}$</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\check&#123;a&#125; \breve&#123;a&#125; \tilde&#123;a&#125; \bar&#123;a&#125;$</span><br></pre></td></tr></table></figure>
<p>$\check{a}\quad \breve{a}\quad \tilde{a}\quad \bar{a}\quad$ </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\hat&#123;a&#125; \widehat&#123;a&#125; \vec&#123;a&#125;$</span><br></pre></td></tr></table></figure>
<p> $\hat{a}\quad \widehat{a}\quad \vec{a}$</p>
<h1 id="类字母符号即常数"><a href="#类字母符号即常数" class="headerlink" title="类字母符号即常数"></a>类字母符号即常数</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\infty \aleph \complement \backepsilon \eth \Finv \hbar$</span><br></pre></td></tr></table></figure>
<p> $\infty\quad \aleph\quad \complement\quad \backepsilon\quad \eth\quad \Finv\quad \hbar$</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\Im \imath \jmath \Bbbk \ell \mho \wp \Re \circledS$</span><br></pre></td></tr></table></figure>
<p> $\Im\quad \imath\quad \jmath\quad \Bbbk\quad \ell\quad \mho\quad \wp\quad \Re\quad \circledS$</p>
<h1 id="数论用"><a href="#数论用" class="headerlink" title="数论用"></a>数论用</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$a\equiv1\pmod&#123;m&#125;$</span><br></pre></td></tr></table></figure>
<p>$a\equiv1\pmod{m}$</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$a\bmod b$</span><br></pre></td></tr></table></figure>
<p> $a\bmod b$</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\gcd(m,n) \operatorname&#123;lcm&#125;(m,n)$</span><br></pre></td></tr></table></figure>
<p>$\gcd(m,n)\quad \operatorname{lcm}(m,n)$</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\mid \nmid \shortmid \nshortmid$</span><br><span class="line">ps：\mid可以用|代替。</span><br></pre></td></tr></table></figure>
<p> $\mid\quad \nmid\quad \shortmid\quad \nshortmid$ </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$a\%b$</span><br></pre></td></tr></table></figure>
<p>$a\%b$</p>
<h1 id="根号"><a href="#根号" class="headerlink" title="根号"></a>根号</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\surd \sqrt&#123;2&#125; \sqrt[n]&#123;&#125; \sqrt[n]&#123;x&#125;$</span><br></pre></td></tr></table></figure>
<p> $\surd\quad \sqrt{2}\quad \sqrt[n]{}\quad \sqrt[n]{x}$</p>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$+ - \pm \mp \dotplus$</span><br></pre></td></tr></table></figure>
<p>$+\quad -\quad \pm\quad \mp\quad \dotplus$</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\times \div \divideontimes &#x2F; \backslash$</span><br></pre></td></tr></table></figure>
<p> $\times\quad \div\quad \divideontimes\quad /\quad \backslash$</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\cdot * \star \circ \bullet$</span><br><span class="line">ps:*可以用\ast代替。</span><br></pre></td></tr></table></figure>
<p> $\cdot\quad *\quad \star\quad \circ\quad \bullet$ </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\oplus \ominus \otimes \oslash \odot$</span><br></pre></td></tr></table></figure>
<p> $\oplus\quad \ominus\quad \otimes\quad \oslash\quad \odot$</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\circleddash \circledcirc \circledast$</span><br></pre></td></tr></table></figure>
<p> $\circleddash\quad \circledcirc\quad \circledast$</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\bigoplus \bigotimes \bigodot$</span><br></pre></td></tr></table></figure>
<p> $\bigoplus\quad \bigotimes\quad \bigodot$</p>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\&#123; \&#125; \emptyset \varnothing$</span><br></pre></td></tr></table></figure>
<p> ${\quad }\quad \emptyset\quad \varnothing$</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\in \notin \not\in \ni \not\ni$</span><br></pre></td></tr></table></figure>
<p> $\in\quad \notin\quad \not\in\quad \ni\quad \not\ni$</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\cap \Cap \sqcap \bigcap$</span><br></pre></td></tr></table></figure>
<p> $\cap\quad \Cap\quad \sqcap\quad \bigcap$</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\cup \Cup \sqcup \bigcup \bigsqcup \uplus \biguplus$</span><br></pre></td></tr></table></figure>
<p> $\cup\quad \Cup\quad \sqcup\quad \bigcup\quad \bigsqcup\quad \uplus\quad \biguplus$</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\setminus \smallsetminus \times$</span><br></pre></td></tr></table></figure>
<p> $\setminus\quad \smallsetminus\quad \times$</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\subset \Subset \sqsubset$</span><br></pre></td></tr></table></figure>
<p> $\subset\quad \Subset\quad \sqsubset$</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\supset \Supset \sqsupset$</span><br></pre></td></tr></table></figure>
<p> $\supset\quad \Supset\quad \sqsupset$</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\subseteq \nsubseteq \subsetneq \varsubsetneq \sqsubseteq$</span><br></pre></td></tr></table></figure>
<p>$\subseteq\quad \nsubseteq\quad \subsetneq\quad \varsubsetneq\quad \sqsubseteq$</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\supseteq \nsupseteq \supsetneq \varsupsetneq \sqsupseteq$</span><br></pre></td></tr></table></figure>
<p> $\supseteq\quad \nsupseteq\quad \supsetneq\quad \varsupsetneq\quad \sqsupseteq$</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\subseteqq \nsubseteqq \subsetneqq \varsubsetneqq$</span><br></pre></td></tr></table></figure>
<p> $\subseteqq\quad \nsubseteqq\quad \subsetneqq\quad \varsubsetneqq$</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\supseteqq \nsupseteqq \supsetneqq \varsupsetneqq$</span><br></pre></td></tr></table></figure>
<p> $\supseteqq\quad \nsupseteqq\quad \supsetneqq\quad \varsupsetneqq$</p>
<h1 id="关系符号"><a href="#关系符号" class="headerlink" title="关系符号"></a>关系符号</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$&#x3D; \ne \neq \equiv \not\equiv$</span><br></pre></td></tr></table></figure>
<p> $=\quad \ne\quad \neq\quad \equiv\quad \not\equiv$</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\doteq \doteqdot \overset&#123;\underset&#123;def&#125;&#123;&#125;&#125;&#123;&#x3D;&#125; :&#x3D;$</span><br></pre></td></tr></table></figure>
<p> $\doteq\quad \doteqdot\quad \overset{\underset{def}{}}{=}\quad :=$</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\sim \nsim \backsim \thicksim \simeq \backsimeq \eqsim \cong \ncong$</span><br></pre></td></tr></table></figure>
<p> $\sim \quad\nsim\quad \backsim\quad \thicksim\quad \simeq \quad \backsimeq\quad \eqsim\quad \cong\quad \ncong$</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\approx \thickapprox \approxeq \asymp \propto \varpropto$</span><br></pre></td></tr></table></figure>
<p> $\approx\quad\thickapprox\quad \approxeq\quad \asymp\quad \propto\quad \varpropto$</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$&lt; \nless \ll \not\ll \lll \not\lll \lessdot$</span><br></pre></td></tr></table></figure>
<p> $&lt;\quad \nless\quad \ll\quad \not\quad\ll \quad\lll \quad\not\lll\quad \lessdot$</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$&gt; \ngtr \gg \not\gg \ggg \not\ggg \gtrdot$</span><br></pre></td></tr></table></figure>
<p> $&gt; \quad\ngtr\quad \gg\quad \not\gg\quad \ggg\quad \not\ggg \quad\gtrdot$</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\le \leq \lneq \leqq \nleq \nleqq \lneqq \lvertneqq$</span><br></pre></td></tr></table></figure>
<p> $\le\quad \leq\quad \lneq\quad \leqq\quad \nleq\quad \nleqq\quad \lneqq\quad \lvertneqq$</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\ge \geq \gneq \geqq \ngeq \ngeqq \gneqq \gvertneqq$</span><br></pre></td></tr></table></figure>
<p> $\ge\quad \geq\quad \gneq\quad \geqq\quad \ngeq\quad \ngeqq\quad \gneqq\quad \gvertneqq$</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\lessgtr \lesseqgtr \lesseqqgtr \gtrless \gtreqless \gtreqqless$</span><br></pre></td></tr></table></figure>
<p>$\lessgtr\quad \lesseqgtr\quad \lesseqqgtr\quad \gtrless\quad \gtreqless\quad \gtreqqless$</p>
<p>还有很多，大概率是用不上的，就不写了</p>
<h1 id="集合符号"><a href="#集合符号" class="headerlink" title="集合符号"></a>集合符号</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\parallel \nparallel \shortparallel \nshortparallel$</span><br></pre></td></tr></table></figure>
<p>$\parallel\quad \nparallel\quad \shortparallel\quad \nshortparallel$</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\perp \angle \sphericalangle \measuredangle 45^\circ$</span><br></pre></td></tr></table></figure>
<p> $\perp\quad \angle\quad \sphericalangle\quad \measuredangle 45^\circ$</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\Box \blacksquare \diamond \Diamond \lozenge \blacklozenge \bigstar$</span><br></pre></td></tr></table></figure>
<p>$\Box\quad \blacksquare\quad \diamond\quad \Diamond\quad\lozenge\quad \blacklozenge\quad \bigstar$</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\bigcirc \triangle \bigtriangleup \bigtriangledown$</span><br></pre></td></tr></table></figure>
<p> $\bigcirc\quad \triangle\quad \bigtriangleup\quad \bigtriangledown$</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\vartriangle \triangledown \triangleleft \triangleright$</span><br></pre></td></tr></table></figure>
<p> $\vartriangle\quad\triangledown \quad\triangleleft \quad\triangleright$</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\blacktriangle \blacktriangledown \blacktriangleleft \blacktriangleright$</span><br></pre></td></tr></table></figure>
<p> $\blacktriangle\quad \blacktriangledown \quad\blacktriangleleft\quad \blacktriangleright$</p>
<h1 id="逻辑符号"><a href="#逻辑符号" class="headerlink" title="逻辑符号"></a>逻辑符号</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\forall \exists \nexists$</span><br></pre></td></tr></table></figure>
<p> $\forall\quad \exists\quad \nexists$</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\therefore \because \And$</span><br></pre></td></tr></table></figure>
<p> $\therefore\quad \because\quad \And$</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\lor \vee \curlyvee \bigvee$</span><br></pre></td></tr></table></figure>
<p> $\lor\quad \vee\quad \curlyvee\quad \bigvee$</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\land \wedge \curlywedge \bigwedge$</span><br></pre></td></tr></table></figure>
<p> $\land\quad \wedge\quad \curlywedge\quad \bigwedge$</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\bar&#123;q&#125; \bar&#123;abc&#125; \overline&#123;q&#125; \overline&#123;abc&#125;$</span><br></pre></td></tr></table></figure>
<p>$\bar{q}\quad \bar{abc}\quad \overline{q}\quad \overline{abc}$</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\lnot \neg \bot \top$</span><br></pre></td></tr></table></figure>
<p> $\lnot\quad \neg\quad \bot\quad \top$</p>
<h1 id="箭头"><a href="#箭头" class="headerlink" title="箭头"></a>箭头</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\Rrightarrow \Lleftarrow$</span><br></pre></td></tr></table></figure>
<p> $\Rrightarrow\quad \Lleftarrow$</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\Rightarrow \nRightarrow \Longrightarrow \implies$</span><br></pre></td></tr></table></figure>
<p> $\Rightarrow\quad \nRightarrow\quad \Longrightarrow\quad \implies$</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\Leftarrow \nLeftarrow \Longleftarrow$</span><br></pre></td></tr></table></figure>
<p> $\Leftarrow\quad \nLeftarrow\quad \Longleftarrow$</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\Leftrightarrow \nLeftrightarrow \Longleftrightarrow \iff$</span><br></pre></td></tr></table></figure>
<p> $\Leftrightarrow\quad \nLeftrightarrow\quad \Longleftrightarrow\quad \iff$</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\Uparrow \Downarrow \Updownarrow$</span><br></pre></td></tr></table></figure>
<p> $\Uparrow \quad\Downarrow\quad \Updownarrow$</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\leftarrow \rightarrow \nleftarrow \nrightarrow \leftrightarrow \nleftrightarrow \longleftarrow \longrightarrow \longleftrightarrow$</span><br></pre></td></tr></table></figure>
<p>$\leftarrow\quad \rightarrow\quad \nleftarrow\quad \nrightarrow \quad\leftrightarrow\quad \nleftrightarrow\quad \longleftarrow\quad \longrightarrow \quad\longleftrightarrow$</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\uparrow \downarrow \updownarrow \nearrow \searrow \nwarrow \swarrow$</span><br></pre></td></tr></table></figure>
<p> $\uparrow\quad \downarrow\quad \updownarrow\quad \nearrow \quad\searrow \quad\nwarrow \quad\swarrow$</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\mapsto \longmapsto$</span><br></pre></td></tr></table></figure>
<p> $\mapsto\quad \longmapsto$</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\rightharpoonup \rightharpoondown \leftharpoonup \leftharpoondown \upharpoonleft \upharpoonright \downharpoonleft \downharpoonright \leftrightharpoons \rightleftharpoons$</span><br></pre></td></tr></table></figure>
<p> $\rightharpoonup \quad\rightharpoondown\quad \leftharpoonup \quad\leftharpoondown \quad\upharpoonleft\quad \upharpoonright \quad\downharpoonleft \quad\downharpoonright\quad \leftrightharpoons\quad \rightleftharpoons$</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\curvearrowleft \circlearrowleft \Lsh \upuparrows \rightrightarrows \rightleftarrows \rightarrowtail \looparrowright$</span><br></pre></td></tr></table></figure>
<p>$\curvearrowleft\quad \circlearrowleft\quad \Lsh \quad\upuparrows\quad \rightrightarrows\quad \rightleftarrows \quad\rightarrowtail \quad\looparrowright$</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\curvearrowright \circlearrowright \Rsh \downdownarrows \leftleftarrows \leftrightarrows \leftarrowtail \looparrowleft$</span><br></pre></td></tr></table></figure>
<p>$\curvearrowright\quad \circlearrowright\quad \Rsh \quad\downdownarrows \quad\leftleftarrows\quad \leftrightarrows \quad\leftarrowtail \quad\looparrowleft$</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\hookrightarrow \hookleftarrow \multimap \leftrightsquigarrow \rightsquigarrow \twoheadrightarrow \twoheadleftarrow$</span><br></pre></td></tr></table></figure>
<p>$\hookrightarrow\quad \hookleftarrow \quad\multimap \quad\leftrightsquigarrow\quad \rightsquigarrow\quad \twoheadrightarrow \quad\twoheadleftarrow$</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\xleftarrow&#123;left&#125; \xrightarrow&#123;right&#125; \xLeftarrow&#123;Left&#125; \xRightarrow&#123;Right&#125; \xleftrightarrow&#123;left\&amp; right&#125; \xLeftrightarrow&#123;Left\&amp; Right&#125;$</span><br></pre></td></tr></table></figure>
<p>$\xleftarrow{left}\quad \xrightarrow{right}\quad $后面四个貌似有点问题？</p>
<h1 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\amalg \% \dagger \ddagger \ldots \cdots$</span><br></pre></td></tr></table></figure>
<p> $\amalg\quad \% \quad\dagger\quad \ddagger\quad \ldots\quad \cdots$</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\smile \frown \wr$</span><br></pre></td></tr></table></figure>
<p> $\smile\quad \frown\quad \wr$</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\diamondsuit \heartsuit \clubsuit \spadesuit \Game \flat \natural \sharp$</span><br></pre></td></tr></table></figure>
<p>$\diamondsuit \quad\heartsuit\quad \clubsuit\quad \spadesuit \quad\Game\quad \flat\quad \natural\quad \sharp$</p>
<h1 id="上下标"><a href="#上下标" class="headerlink" title="上下标"></a>上下标</h1><p>简单的应用省略</p>
<p><strong>前置上下标</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$&#123;&#125;^2_1\!X^3_4$</span><br></pre></td></tr></table></figure>
<p>${}^2_1!X^3_4$</p>
<h1 id="导数"><a href="#导数" class="headerlink" title="导数"></a>导数</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(PNG)x^\prime$</span><br></pre></td></tr></table></figure>
<p>$x^\prime$</p>
<h2 id="导数点"><a href="#导数点" class="headerlink" title="导数点"></a>导数点</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\dot&#123;x&#125; \ddot&#123;x&#125;$</span><br></pre></td></tr></table></figure>
<p>$\dot{x}\quad\ddot{x}$</p>
<h1 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\vec&#123;x&#125; \overleftarrow&#123;AB&#125; \overrightarrow&#123;AB&#125; \widehat&#123;AB&#125;$</span><br></pre></td></tr></table></figure>
<p> $\vec{x}\quad\overleftarrow{AB}\quad\overrightarrow{AB} \quad\widehat{AB}$</p>
<h1 id="上弧"><a href="#上弧" class="headerlink" title="上弧"></a>上弧</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\overarc&#123;\frown&#125;&#123;AB&#125;$</span><br><span class="line">ps:正确的语法应该是\overarc，但因为没有引入amsmath宏包，所以无法使用，只能用这个替代下。</span><br></pre></td></tr></table></figure>
<p> $\overset{\frown}{AB}$</p>
<h1 id="上划线"><a href="#上划线" class="headerlink" title="上划线"></a>上划线</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\overline&#123;ABC&#125;$</span><br></pre></td></tr></table></figure>
<p> $\overline{ABC}$</p>
<h1 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\underline&#123;ABC&#125;$</span><br></pre></td></tr></table></figure>
<p>$\underline{ABC}$</p>
<h1 id="上括号"><a href="#上括号" class="headerlink" title="上括号"></a>上括号</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\overbrace&#123;1+2+\cdots+100&#125;$  </span><br><span class="line"></span><br><span class="line">$\begin&#123;matrix&#125;</span><br><span class="line">5050\\</span><br><span class="line">\overbrace&#123;1+2+\cdots+100&#125;</span><br><span class="line">\end&#123;matrix&#125;$</span><br></pre></td></tr></table></figure>
<p> $\overbrace{1+2+\cdots+100}$ </p>
<script type="math/tex; mode=display">
\begin{matrix}5050 \\ \overbrace{1+2+\cdots+100}\end{matrix}</script><h1 id="下括号"><a href="#下括号" class="headerlink" title="下括号"></a>下括号</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\underbrace&#123;1+2+\cdots+100&#125;$  </span><br><span class="line"></span><br><span class="line">$\begin&#123;matrix&#125;</span><br><span class="line">\underbrace&#123;1+2+\cdots+100&#125;\\</span><br><span class="line">5050</span><br><span class="line">\end&#123;matrix&#125;$</span><br></pre></td></tr></table></figure>
<p>$\underbrace{1+2+\cdots+100}$ </p>
<script type="math/tex; mode=display">
\begin{matrix} \underbrace{1+2+\cdots+100} \\ 5050\end{matrix}</script><h1 id="极限"><a href="#极限" class="headerlink" title="极限"></a>极限</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\lim_&#123;n\to\infty&#125;x_n \lim\limits_&#123;n\to\infty&#125;x_n$</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">
\lim_{n\to\infty}x_n\quad \lim\limits_{n\to\infty}x_n</script><h1 id="积分"><a href="#积分" class="headerlink" title="积分"></a>积分</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\int_&#123;-N&#125;^&#123;N&#125;e^x\,dx$</span><br></pre></td></tr></table></figure>
<p> $\int_{-N}^{N}e^x\,dx$</p>
<h1 id="双重积分"><a href="#双重积分" class="headerlink" title="双重积分"></a>双重积分</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\iint_M^Ndx\,dy$</span><br></pre></td></tr></table></figure>
<p> $\iint_M^Ndx\,dy$</p>
<h1 id="三重积分"><a href="#三重积分" class="headerlink" title="三重积分"></a>三重积分</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\iiint_M^Ndx\,dy\,dz$</span><br></pre></td></tr></table></figure>
<p>$\iiint_M^Ndx\,dy\,dz$</p>
<h1 id="交集"><a href="#交集" class="headerlink" title="交集"></a>交集</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\bigcap_1^np \bigcap\limits_1^np$</span><br></pre></td></tr></table></figure>
<p> $\bigcap_1^np\quad \bigcap\limits_1^np$</p>
<h1 id="并集"><a href="#并集" class="headerlink" title="并集"></a>并集</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\bigcup_1^np \bigcup\limits_1^np$</span><br></pre></td></tr></table></figure>
<p> $\bigcup_1^np\quad \bigcup\limits_1^np$</p>
<h1 id="分数矩阵"><a href="#分数矩阵" class="headerlink" title="分数矩阵"></a>分数矩阵</h1><h2 id="分数"><a href="#分数" class="headerlink" title="分数"></a>分数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\frac&#123;1&#125;&#123;2&#125;&#x3D;0.5$</span><br></pre></td></tr></table></figure>
<p> $\frac{1}{2}=0.5$</p>
<h2 id="小型分数"><a href="#小型分数" class="headerlink" title="小型分数"></a>小型分数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\tfrac&#123;1&#125;&#123;2&#125;&#x3D;0.5$</span><br></pre></td></tr></table></figure>
<p>$\tfrac{1}{2}=0.5$</p>
<h2 id="大型分数"><a href="#大型分数" class="headerlink" title="大型分数"></a>大型分数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\dfrac&#123;1&#125;&#123;2&#125;&#x3D;0.5 \dfrac&#123;1&#125;&#123;x+\dfrac&#123;3&#125;&#123;y+\dfrac&#123;1&#125;&#123;5&#125;&#125;&#125;$</span><br></pre></td></tr></table></figure>
<p> $\dfrac{1}{2}=0.5\quad \dfrac{1}{x+\dfrac{3}{y+\dfrac{1}{5}}}$</p>
<h2 id="二项式系数"><a href="#二项式系数" class="headerlink" title="二项式系数"></a>二项式系数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\dbinom&#123;n&#125;&#123;m&#125;&#x3D;\dbinom&#123;n&#125;&#123;n-m&#125;&#x3D;C_n^m&#x3D;C_n^&#123;n-m&#125;$</span><br></pre></td></tr></table></figure>
<p>$\dbinom{n}{m}=\dbinom{n}{n-m}=C_n^m=C_n^{n-m}$</p>
<h2 id="小型二项式系数"><a href="#小型二项式系数" class="headerlink" title="小型二项式系数"></a>小型二项式系数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\tbinom&#123;n&#125;&#123;m&#125;&#x3D;\tbinom&#123;n&#125;&#123;n-m&#125;&#x3D;C_n^m&#x3D;C_n^&#123;n-m&#125;$</span><br></pre></td></tr></table></figure>
<p>$\tbinom{n}{m}=\tbinom{n}{n-m}=C_n^m=C_n^{n-m}$</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\binom&#123;n&#125;&#123;m&#125;&#x3D;\binom&#123;n&#125;&#123;n-m&#125;&#x3D;C_n^m&#x3D;C_n^&#123;n-m&#125;$</span><br></pre></td></tr></table></figure>
<p> $\binom{n}{m}=\binom{n}{n-m}=C_n^m=C_n^{n-m}$</p>
<h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\begin&#123;matrix&#125;a&amp;b\\ c&amp;d\end&#123;matrix&#125;$</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">
\begin{matrix}a&b\\ c&d\end{matrix}</script><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\begin&#123;vmatrix&#125;a&amp;b\\ c&amp;d\end&#123;vmatrix&#125;$</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">
\begin{vmatrix}a&b\\ c&d\end{vmatrix}</script><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\begin&#123;Vmatrix&#125;a&amp;b\\ c&amp;d\end&#123;Vmatrix&#125;$</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">
\begin{Vmatrix}a&b\\ c&d\end{Vmatrix}</script><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\begin&#123;bmatrix&#125;a&amp;\cdots&amp;b\\\vdots&amp;\ddots&amp;\vdots\\ c&amp;\cdots&amp;d\end&#123;bmatrix&#125;$</span><br><span class="line">ps:\vdots是竖着3个点，\ddots是斜着3个点。</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">
\begin{bmatrix}a&\cdots&b\\\vdots&\ddots&\vdots\\ c&\cdots&d\end{bmatrix}</script><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\begin&#123;Bmatrix&#125;a&amp;c\\ b&amp;d\end&#123;Bmatrix&#125;$</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">
\begin{Bmatrix}a&c\\ b&d\end{Bmatrix}</script><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\begin&#123;pmatrix&#125;a&amp;c\\ b&amp;d\end&#123;pmatrix&#125;$</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">
 \begin{pmatrix}a&c\\ b&d\end{pmatrix}</script><h2 id="矩阵嵌套"><a href="#矩阵嵌套" class="headerlink" title="矩阵嵌套"></a>矩阵嵌套</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\begin&#123;vmatrix&#125; \begin&#123;Bmatrix&#125;A &amp; \\ c &amp; d \end&#123;Bmatrix&#125; &amp; x\\ \dfrac&#123;1&#125;&#123;2&#125; &amp; \begin&#123;matrix&#125; 1 &amp; 2 \\ 3 &amp; 4 \end&#123;matrix&#125; \end&#123;vmatrix&#125;$</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">
\begin{vmatrix} \begin{Bmatrix}A & \\ c & d \end{Bmatrix} & x\\ \dfrac{1}{2} & \begin{matrix} 1 & 2 \\ 3 & 4 \end{matrix} \end{vmatrix}</script><h2 id="条件定义-如分段函数"><a href="#条件定义-如分段函数" class="headerlink" title="条件定义(如分段函数)"></a>条件定义(如分段函数)</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$f(x)&#x3D;\begin&#123;cases&#125;x-1&amp;x\leqslant3\\ x^2+3x-1&amp;x&gt;3\end&#123;cases&#125;$</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">
f(x)=\begin{cases}x-1&x\leqslant3\\ x^2+3x-1&x>3\end{cases}</script><h2 id="方程组"><a href="#方程组" class="headerlink" title="方程组"></a>方程组</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\begin&#123;cases&#125;2x+9y-5z&#x3D;10\\ 4x+20y+z&#x3D;24\\ x-\dfrac&#123;1&#125;&#123;2&#125;y+3z&#x3D;8\end&#123;cases&#125;$</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">
\begin{cases}2x+9y-5z=10\\ 4x+20y+z=24\\ x-\dfrac{1}{2}y+3z=8\end{cases}</script><h2 id="多行等式"><a href="#多行等式" class="headerlink" title="多行等式"></a>多行等式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\begin&#123;aligned&#125;f(x) &amp; &#x3D; (x + 1)^2 \\ &amp; &#x3D; x^2 + 2x + 1\end&#123;aligned&#125;$</span><br><span class="line"></span><br><span class="line">$\begin&#123;aligned&#125;a_1 &amp; &#x3D; 1 \\ a_2 &amp; &#x3D; 2 \\ &amp; \dots \\ a_n &amp; &#x3D; n\end&#123;aligned&#125;$ </span><br><span class="line"></span><br><span class="line">ps:原语法为align，现在是aligned。感觉align没啥不好的</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">
\begin{aligned}f(x) & = (x + 1)^2 \\ & = x^2 + 2x + 1\end{aligned}</script><script type="math/tex; mode=display">
\begin{aligned}a_1 & = 1 \\ a_2 & = 2 \\ & \dots \\ a_n & = n\end{aligned}</script><h2 id="数组-表格"><a href="#数组-表格" class="headerlink" title="数组/表格"></a>数组/表格</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\begin&#123;array&#125;&#123;|c|c||c|&#125;x&amp;y&amp;z\\8&amp;2&amp;4\\2&amp;3&amp;9\\10&amp;\dfrac&#123;3&#125;&#123;4&#125;&amp;\sqrt&#123;3&#125;\\a&amp;b&amp;c\end&#123;array&#125;$</span><br><span class="line"> ps:\begin&#123;array&#125;&#123;&#125;←这个大括号里是形如&#39;|c|c||c|&#39;这样的格式，&#39;|&#39;是两列的分割线，&#39;c&#39;是表示这里有一列，而内容中使用&#39;&amp;&#39;来分开每一列的内容。这里可能讲的不是很清楚，所以最好还是自己尝试一下。</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">
\begin{array}{|c|c||c|}x&y&z\\ 8&2&4\\ 2&3&9\\ 10&\dfrac{3}{4}&\sqrt{3}\\ a&b&c\end{array}</script><h1 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h1><h2 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\Alpha \Beta \Gamma\Delta \Epsilon \Zeta \Eta \Theta$</span><br></pre></td></tr></table></figure>
<p> $\Alpha \Beta \Gamma\Delta \Epsilon \Zeta \Eta \Theta$</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\Iota \Kappa \Lambda \Mu \Nu \Xi \Omicron \Pi$</span><br></pre></td></tr></table></figure>
<p> $\Iota \Kappa \Lambda \Mu \Nu \Xi \Omicron \Pi$</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\Rho \Sigma \Tau \Upsilon \Phi \Chi \Psi \Omega$</span><br></pre></td></tr></table></figure>
<p>$\Rho\Sigma \Tau \Upsilon \Phi \Chi \Psi \Omega$</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\alpha\beta\gamma\delta\epsilon\zeta\eta\theta$</span><br></pre></td></tr></table></figure>
<p> $\alpha\beta\gamma\delta\epsilon\zeta\eta\theta$</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\iota\kappa\lambda\mu\nu\xi\omicron\pi$</span><br></pre></td></tr></table></figure>
<p> $\iota\kappa\lambda\mu\nu\xi\omicron\pi$</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\rho\sigma\tau\upsilon\phi\chi\psi\omega$</span><br></pre></td></tr></table></figure>
<p> $\rho\sigma\tau\upsilon\phi\chi\psi\omega$</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\varepsilon\digamma\varkappa\varpi$</span><br></pre></td></tr></table></figure>
<p> $\varepsilon\digamma\varkappa\varpi$</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$\varrho\varsigma\vartheta\varphi$</span><br></pre></td></tr></table></figure>
<p> $\varrho\varsigma\vartheta\varphi$</p>
<p>下次继续</p>
]]></content>
      <tags>
        <tag>其他板子</tag>
      </tags>
  </entry>
  <entry>
    <title>位运算好题</title>
    <url>/2020/09/28/%E4%BD%8D%E8%BF%90%E7%AE%97%E5%A5%BD%E9%A2%98/</url>
    <content><![CDATA[<p>位运算是一个十分有助的工具</p>
<p>还是要好好学的</p>
<h1 id="P6034-Ryoku-与最初之人笔记"><a href="#P6034-Ryoku-与最初之人笔记" class="headerlink" title="P6034 Ryoku 与最初之人笔记"></a><a href="https://www.luogu.com.cn/problem/P6034" target="_blank" rel="noopener">P6034 Ryoku 与最初之人笔记</a></h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>求：</p>
<script type="math/tex; mode=display">
\sum_{a=0}^n\sum_{b=a+1}^n[a\equiv b\pmod{a\otimes b}]</script><p><del>当然，最开始的开始，是通过暴力运算直接拿的$20pt$的好成绩</del></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>遇到位运算，换元是不错的处理方法</p>
<p>令：$y=a \text{&amp;} b,\;a=x+y,\;b=y+z$，那么有：$a|b=x+y+z,a\text^b=x+z$</p>
<p>那么通过这个换元，可以得到一些好东西：</p>
<script type="math/tex; mode=display">
(a\otimes b)|(b-a)=(x+z)|(z-x)</script><p>那么就发现了，当且仅当$x=0$时，这个才能成立</p>
<p>所以说原式可以写为：</p>
<script type="math/tex; mode=display">
\sum_{a=0}^n\sum_{b=a+1}^n[a\equiv b\pmod{a\otimes b}]=\sum_{a=1}^n\sum_{b=a+1}^n[a\text{&}b==a]</script><p>那么定义</p>
<script type="math/tex; mode=display">
f(x)=\sum_{i=1}^{x-1}[i\text{&}x==i]</script><p>显然这个可以写成是：</p>
<script type="math/tex; mode=display">
f(x)=2^{cnt_x}-1</script><p>其中$cnt_x$表示$x$再二进制下$1$的个数</p>
<p>所以原式交换求和顺序后可以变成下面的样子：</p>
<script type="math/tex; mode=display">
ans=\sum_{i=1}^n2^{f(i)}-n\\
令：s(n)=\sum_{i=1}^ns^{f(i)}</script><p>然后，还有这样一个性质：</p>
<script type="math/tex; mode=display">
f(i<<1)=f(i)\\
f(i<<1|1)=f(i)+1</script><p>所以求和的时候，可以分奇偶求：</p>
<script type="math/tex; mode=display">
\begin{align*}
s(2n)&=\sum_{i=1}^{2n}s^{f(i)}\\
&=\sum_{i=1}^n2^{f(2i-1)}+\sum_{i=1}^n2^{f(2i)}\\
&=\sum_{i=1}^n2^{f(i-1)+1}+\sum_{i=1}^n2^{f(i)}\\
&=2(1+\sum_{i=1}^{n-1}2^{f(i)})+\sum_{i=1}^{n-1}2^{f(i)}+2^{f(n)}\\
&=3\sum_{i=1}^{n-1}2^{f(i)}+2^{f(n)}+2\\
&=3s(n-1)+2^{f(n)}+2
\end{align*}</script><p>然后乱搞就完了</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> ll __read()</span><br><span class="line">&#123;</span><br><span class="line">    ll x(0), t(1);</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">'0'</span> || o &gt; <span class="string">'9'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">'-'</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">'0'</span> &amp;&amp; o &lt;= <span class="string">'9'</span>; o = getchar()) &#123;</span><br><span class="line">        x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(ll x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ans</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (y) &#123;</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">1</span>) ans = ans * x % mod;</span><br><span class="line">        x = x * x % mod;</span><br><span class="line">        y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cnt</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (x) &#123;</span><br><span class="line">        x -= lowbit(x);</span><br><span class="line">        ++cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Pow(<span class="number">2</span>, cnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Sum</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &amp; <span class="number">1</span>) <span class="keyword">return</span> (Sum(x ^ <span class="number">1</span>) + count(x)) % mod;</span><br><span class="line">    ll temp = Sum((x &gt;&gt; <span class="number">1</span>) - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> (temp * <span class="number">3</span> + count(x &gt;&gt; <span class="number">1</span>) + <span class="number">2</span>) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n = __read();</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"%lld\n"</span>, ((Sum(n) - n) % mod + mod) % mod);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>动态DP</title>
    <url>/2020/09/18/%E5%8A%A8%E6%80%81DP/</url>
    <content><![CDATA[<h1 id="DDp"><a href="#DDp" class="headerlink" title="DDp"></a><a href="https://www.luogu.com.cn/problem/P4719" target="_blank" rel="noopener">DDp</a></h1><h2 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h2><p>大概就是说, 有一棵树, 点权是会发生改变的, 让你动态求最大权独立集</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>考虑到我们每次修改一个点, 能够受到影响的点就只有链上的点, 可以直接暴力更新</p>
<p>貌似这道题数据随机, 没有出到链的情况, 所以暴力更新是可以随便过的</p>
<p>先来一份暴力的</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> __read()</span><br><span class="line">&#123;</span><br><span class="line">    int x(0), t(1);</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">'0'</span> || o &gt; <span class="string">'9'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">'-'</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">'0'</span> &amp;&amp; o &lt;= <span class="string">'9'</span>; o = getchar()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, p[maxn], f[maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn][<span class="number">2</span>], cur;</span><br><span class="line"><span class="keyword">int</span> head[maxn], edge[maxn &lt;&lt; <span class="number">1</span>], __next[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __next[++cur] = head[u];</span><br><span class="line">    head[u] = cur;</span><br><span class="line">    edge[cur] = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dp[u][<span class="number">1</span>] = p[u], dp[u][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    f[u] = fa;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i(head[u]); i; i = __next[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (edge[i] == fa) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(edge[i], u);</span><br><span class="line">        dp[u][<span class="number">0</span>] += max(dp[edge[i]][<span class="number">0</span>], dp[edge[i]][<span class="number">1</span>]);</span><br><span class="line">        dp[u][<span class="number">1</span>] += dp[edge[i]][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = __read(), m = __read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) p[i] = __read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = __read(), b = __read();</span><br><span class="line">        AddEdge(a, b), AddEdge(b, a);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = __read(), val = __read();</span><br><span class="line">        <span class="keyword">int</span> update = val - p[x];</span><br><span class="line">        p[x] += update;</span><br><span class="line">        <span class="keyword">int</span> lst = x;</span><br><span class="line">        <span class="keyword">int</span> l0 = dp[x][<span class="number">0</span>], l1 = dp[x][<span class="number">1</span>];</span><br><span class="line">        dp[x][<span class="number">1</span>] += update;</span><br><span class="line">        x = f[x];</span><br><span class="line">        <span class="keyword">while</span> (x) &#123;</span><br><span class="line">            <span class="keyword">int</span> t0 = dp[x][<span class="number">0</span>], t1 = dp[x][<span class="number">1</span>];</span><br><span class="line">            dp[x][<span class="number">0</span>] -= max(l0, l1);</span><br><span class="line">            dp[x][<span class="number">0</span>] += max(dp[lst][<span class="number">0</span>], dp[lst][<span class="number">1</span>]);</span><br><span class="line">            dp[x][<span class="number">1</span>] += dp[lst][<span class="number">0</span>] - l0;</span><br><span class="line">            l0 = t0, l1 = t1;</span><br><span class="line">            lst = x;</span><br><span class="line">            x = f[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = max(dp[<span class="number">1</span>][<span class="number">1</span>], dp[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;<span class="comment">//真挺暴力的</span></span><br></pre></td></tr></table></figure>
<p>那么显然不能就这样说过去了的, 至少还是要<del>看看别人这是怎么写的吧</del></p>
<h2 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h2><p>动态$dp$的套路是把$dp$方程写成矩阵乘法, 然后用什么$LCT$, 树剖, 线段树, 倍增啥啥啥的维护一下</p>
<p>这道题的矩阵乘法大概是这个样子:</p>
<script type="math/tex; mode=display">
C_{i,j}=\max_{k=1}^n(A_{i,k}+B_{k,j})</script><p>易证可以满足结合律, 可以像矩阵乘法一样乱写</p>
<p>然后就是构造矩阵, 找转移方程</p>
<p>老套路: $f(i,0)$表示这个点不作为独立集中的点, $f(i,1)$表示作为独立及中的点</p>
<p>那么显然有:</p>
<script type="math/tex; mode=display">
\begin{align*}
f_{u,0}&=\sum _{v\in son_u}max(f_{v,0}, f_{v,1})\\
f_{u,1}&=val_u+\sum_{v\in sonu} f_{v,0}
\end{align*}</script><p>啊，全局平衡二叉树还没会，先搁着</p>
<p>看看这？<a href="https://www.mina.moe/archives/11789" target="_blank" rel="noopener">优质题解</a></p>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>Dp优化</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>从1开始的数论</title>
    <url>/2020/07/28/%E4%BB%8E1%E5%BC%80%E5%A7%8B%E7%9A%84%E6%95%B0%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><ul>
<li>整除</li>
<li>互质</li>
<li>素数</li>
<li>取整函数</li>
<li>最大公约数(最小公倍数)</li>
</ul>
<h2 id="整数分块"><a href="#整数分块" class="headerlink" title="整数分块"></a>整数分块</h2><p>易证已知$d,n\in\mathbb{Z}\;且\;d\le n$ , 那么$[\frac nd]$的取值不会超过$\sqrt n$个</p>
<h2 id="调和数"><a href="#调和数" class="headerlink" title="调和数"></a>调和数</h2><p>调和数的定义为</p>
<script type="math/tex; mode=display">
H_n=\sum\limits_{k=1}^n\frac1k</script><p>关于调和数有如下结论:</p>
<script type="math/tex; mode=display">
H_n=\ln n+\lambda+O(1)</script><p>可以推出一个常见的事见复杂度:</p>
<script type="math/tex; mode=display">
\sum\limits_{d=1}^n\left[\frac nd\right]=\Theta(n\log n)</script><h2 id="素数计数函数"><a href="#素数计数函数" class="headerlink" title="素数计数函数"></a>素数计数函数</h2><p>令素数计数函数$\pi(n)$表示不超过$n$的素数个数. 我们有如下的素数定理 :</p>
<script type="math/tex; mode=display">
\pi(n)\sim\frac n{\ln n}</script><p>推论:</p>
<ul>
<li>$n$附近的素数密度近似为$\frac 1{\ln n}$</li>
<li>第$n$个素数$p_n\sim n\ln n$</li>
</ul>
<h2 id="素数计数"><a href="#素数计数" class="headerlink" title="素数计数"></a>素数计数</h2><p>显然可以利用 $Euler$ 筛算出 $n$ 以内的所有素数，进而得到 $\pi(n)$。 存在更快的做法。<del>可惜一页课件太少，写不下</del>。 </p>
<p>用一种类似积性函数求和的筛法可以达到 $O(\frac{n^{\frac34}}{\log n})$ 的复杂度。 先进的做法似乎可以达到 $O(\frac{n^\frac 23}{\log n})$ 。</p>
<h2 id="算数基本定理"><a href="#算数基本定理" class="headerlink" title="算数基本定理"></a>算数基本定理</h2><p>任意一个正整数 $n$ 都可以表示成素数的乘积的形式：</p>
<script type="math/tex; mode=display">
n = p_1^{a_1}p_2^{a_2}\cdots p_s^{a_3}</script><p>式中 $p_1,\cdots, p_s$ 是不同素数。且不计次序的情况下，这一表达是唯一的。</p>
<h1 id="数论函数"><a href="#数论函数" class="headerlink" title="数论函数"></a>数论函数</h1><ul>
<li>欧拉函数</li>
<li>狄利克雷卷积</li>
<li><a href="https://alansblog.ink/2020/06/14/莫比乌斯反演/" target="_blank" rel="noopener">莫比乌斯反演</a></li>
</ul>
<h2 id="积性函数"><a href="#积性函数" class="headerlink" title="积性函数"></a>积性函数</h2><p>设 $f$ 是数论函数，若对任意互质的正整数 $a,\;b$，都有 $f(ab) = f(a)f(b)$，则称 $f$ 是积性函数。 </p>
<p>若对任意的正整数 $a, b$，都有 $f(ab) = f(a)f(b)$，则称 $f$ 是完全积性的。</p>
<p>若 $f$ 是积性函数，且 $n = p_1^{\alpha_1}p_2^{\alpha_2}\dots p_s^{\alpha_s}$ 是 $n$ 的标准分解，则 有 $f(n) = f(p_1^{\alpha_1} )f(p_2^ {\alpha_2} )\cdots(p_s^{\alpha_s} )$ 因此研究积性函数 $f$ 可以转化为研究 $f(p^α)$，即 f 在素数和素数的幂上的取值。</p>
<p>设 $f$ 是积性函数，为求 $f(n)$，可以对 $n$ 分解素因子，然后计算所有的 $f(p^α)$ 乘起来。 如果要对 $1$ 到 $n$ 之间的所有数求出 $f$，注意到 $Euler$ 筛法的过程中可以求出每个数的最小素因子和最小素因子的幂次，利用此就能在线性时间内计算出所需的 $f$ 的值。</p>
<h2 id="除数函数"><a href="#除数函数" class="headerlink" title="除数函数"></a>除数函数</h2><p>除数函数$\delta_k(n)$用来表示$n$的因子的$k$次方之和:</p>
<script type="math/tex; mode=display">
\sigma_k(n)=\sum\limits_{d|n}{}d^k</script><p>约数个数$\delta_0(n)$常记为$d(n)$, 约束和$\delta_1(n)$常记为$\delta(n)$</p>
<h2 id="Dirichlet-卷积"><a href="#Dirichlet-卷积" class="headerlink" title="$Dirichlet$卷积"></a>$Dirichlet$卷积</h2><p>设 $f, g$ 是数论函数，考虑数论函数 $h$ 满足:</p>
<script type="math/tex; mode=display">
h(n)=\sum\limits_{d|n}f(d)g(\frac nd)</script><p>则称$h$为$f$与$g$的$Dirichlet$卷积, 记作$h=f*g$</p>
<p>单位函数 $\epsilon$ 是 $Dirichlet$ 卷积的单位元，即对于任意函数 $f$，有 $\epsilon ∗ f = f ∗ \epsilon = f$。 </p>
<p>$Dirichlet$ 卷积满足交换律和结合律</p>
<p>如果 $f,g$ 都是积性函数，那么 $h = f ∗ g$ 也是积性函数。</p>
<p>除数函数的定义可以写为： $\delta k = 1 ∗ Id_k$ </p>
<p>$Euler$ 函数的性质可以写为： $Id = \varphi ∗ 1$</p>
<p>设 $f, g$ 是数论函数，计算 $f$ 和 $g$ 的 $Dirichlet$ 卷积在 $n$ 处的值 需要枚举 $n$ 的所有约数</p>
<p>如果要计算 $f$ 和 $g$ 的 $Dirichlet$ 卷积的前 $n$ 项，可以枚举 $1$ 到 $n$ 中每个数的倍数，根据调和数的相关结论，这样做的复杂度是 $O(n\log n)$</p>
<h2 id="无平方因子数"><a href="#无平方因子数" class="headerlink" title="无平方因子数"></a>无平方因子数</h2><p>求 $n$ 以内的无平方因子数的个数。亦即，求 </p>
<script type="math/tex; mode=display">
\sum\limits_{k=1}^n\mu^2(k)</script><p>我们考虑一个素数 $p$，那么 $p^2$ 的倍数都有平方因子，个数是 $\left\lfloor \frac n {p^2} \right\rfloor$ ，应该从答案中去掉</p>
<p>但是这样多去掉了一些数。比如对于不同的素数 $p_1, p_2，p_1^2p_2^2$ 的倍数就被去掉了两次，个数是 $\left\lfloor\frac n {p_1^2p_2^2}\right\rfloor$ ，应该加回来 </p>
<p>显然这是容斥原理</p>
<p>如果 $d$ 是 $s$ 个不同素数的乘积，那么其对答案的贡献是 $(−1)^s \left\lfloor \frac n {d^2} \right\rfloor$ 。 如果 $d$ 不是不同素数的乘积，即 $d$ 有平方因子，那么 $d$ 对答案没有贡献。 容斥的系数恰好是 $Mobius$ 函数</p>
<p>因此, 答案为:</p>
<script type="math/tex; mode=display">
\sum\limits_{k=1}^n=\sum\limits_{d=1}^{\sqrt n}\mu(d)\left\lfloor \frac n{d^2}\right\rfloor</script><p>事实上，$Mobius$ 反演本身就可以看成是对整除关系的容斥</p>
<h2 id="杜教筛"><a href="#杜教筛" class="headerlink" title="杜教筛"></a>杜教筛</h2><p>有一种利用 $Dirichlet$ 卷积来构造递推式，从而对一些数论函数 进行快速求和的方法</p>
<p>民间称呼杜教筛</p>
<p>我们用两个例子来了解一下这个方法</p>
<h3 id="例一"><a href="#例一" class="headerlink" title="例一:"></a>例一:</h3><p>令:</p>
<script type="math/tex; mode=display">
\phi(n)=\sum\limits_{k=1}^n\varphi(k)</script><p>找出高效求出$\phi(n)$值的方法</p>
<p>考虑$ID=\varphi*1$, 可以的到:</p>
<script type="math/tex; mode=display">
\begin{align*}
\frac 12n(n+1)&=\sum_{k=1}^nk=\sum_{k=1}^n\sum_{d|k}\varphi(\frac kd)\\
&=\sum_{d=1}^n\;\sum_{1\le k\le n\\~~ d|k}\varphi(\frac kd)\\
&=\sum_{d=1}^n\sum_{k=1}^{\left\lfloor\frac nd\right\rfloor}\varphi(k)\\
&=\sum_{d=1}^n\phi(\left\lfloor\frac nd\right\rfloor)
\end{align*}</script><p>即, 我们得到了:</p>
<script type="math/tex; mode=display">
\frac12n(n+1)=\sum_{d=1}^n\phi(\left\lfloor\frac nd\right\rfloor)=\phi(n)-\sum_{d=2}^n\phi(\left\lfloor\frac nd\right\rfloor)\\
\therefore \phi(n)=\frac12n(n+1)-\sum_{d=2}^n\phi(\left\lfloor\frac nd\right\rfloor)</script><p>因此，如果对于 $2 \le d \le n$ 已经计算出了 $\phi(\left\lfloor\frac nd\right\rfloor)$，即特殊点处 的函数值，由于特殊点只有不超过 $2\sqrt n$ 个，利用之前见过的分段的方法，我们可以在 $O(\sqrt n)$ 的时间内计算 $\phi(n)$</p>
<p>而计算 $\phi(\left\lfloor \frac nd \right\rfloor)$ 是子问题，可以递归解决</p>
<p>递归过程中会不会需要计算更多的函数值？</p>
<p>由特殊点的性质，可以发现所有要计算的就是所有的特殊点处的 函数值</p>
<p>使用记忆化搜索，这样每个函数值只会被计算一遍</p>
<h3 id="例二"><a href="#例二" class="headerlink" title="例二:"></a>例二:</h3><p>令</p>
<script type="math/tex; mode=display">
M(n)=\sum_{k=1}^n\mu(k)</script><p>计算原理类似</p>
<script type="math/tex; mode=display">
\begin{align*}
1&=\sum_{k=1}^n\epsilon(k)=\sum_{k=1}^n\sum_{d|k}\mu(\frac kd)\\
&=\sum_{d=1}^n\sum_{1\le k\le n\\~~d|k}\mu(\frac kd)\\
&=\sum_{d=1}^n\sum_{k=1}^\frac nd\mu(k)\\
&=\sum_{d=1}^nM(\left\lfloor\frac nd\right\rfloor)
\end{align*}</script><p>即, 我们得到了:</p>
<script type="math/tex; mode=display">
M(n)=1-\sum_{d=2}^nM(\left\lfloor\frac nd\right\rfloor)</script><p>同理可以求得</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="built_in">unordered_map</span> &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; Mu;</span><br><span class="line"><span class="built_in">unordered_map</span> &lt;<span class="keyword">int</span>, ll&gt; Phi;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">5e6</span>;</span><br><span class="line"><span class="keyword">int</span> T, A, B;</span><br><span class="line"><span class="keyword">int</span> P[Maxn + <span class="number">10</span>], Cnt;</span><br><span class="line"><span class="keyword">int</span> mu[Maxn + <span class="number">10</span>];</span><br><span class="line">ll phi[Maxn + <span class="number">10</span>];</span><br><span class="line"><span class="keyword">bool</span> Vis[Maxn + <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= Maxn; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!Vis[i]) P[++Cnt] = i, mu[i] = <span class="number">-1</span>, phi[i] = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= Cnt &amp;&amp; i * P[j] &lt;= Maxn; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            Vis[i * P[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % P[j]) mu[i * P[j]] = -mu[i], phi[i * P[j]] = phi[i] * phi[P[j]];</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                phi[i * P[j]] = phi[i] * P[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Maxn; ++i) mu[i] += mu[i - <span class="number">1</span>], phi[i] += phi[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">PPhi</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= Maxn) <span class="keyword">return</span> phi[x];</span><br><span class="line">    <span class="keyword">if</span> (Phi[x]) <span class="keyword">return</span> Phi[x];</span><br><span class="line">    ll Ans = <span class="number">1l</span>l * x * (x + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll l(<span class="number">2</span>), r; l &lt;= x; l = r + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        r = x / (x / l);</span><br><span class="line">        Ans -= (r - l + <span class="number">1</span>) * PPhi(x / l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Phi[x] = Ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">MMu</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= Maxn) <span class="keyword">return</span> mu[x];</span><br><span class="line">    <span class="keyword">if</span> (Mu[x]) <span class="keyword">return</span> Mu[x];</span><br><span class="line">    <span class="function">ll <span class="title">Ans</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (ll l(<span class="number">2</span>), r; l &lt;= x; l = r + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        r = x / (x / l);</span><br><span class="line">        Ans -= (r - l + <span class="number">1</span>) * MMu(x / l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Mu[x] = Ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Init();</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">"%d"</span>, &amp;A);</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"%lld %d\n"</span>, PPhi(A), MMu(A));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2><p>算法的总时间复杂度就是计算所有特殊点处的函数值的时间复杂度</p>
<p>回忆特殊点的结构，时间复杂度 $T(n)$ 可以估计为</p>
<script type="math/tex; mode=display">
T(N)=\sum_{i=1}^{\sqrt n}O(\sqrt i)+\sum_{i=1}^{\sqrt n}O(\sqrt{\left\lfloor\frac ni\right\rfloor})</script><p><del>显然式中第一项渐进意义上小于第二项</del>, $DaWuMiMan$</p>
<p>而对于式中第二项我们可以利用积分估计:</p>
<script type="math/tex; mode=display">
\sum_{i=1}^{\sqrt n}O(\sqrt{\left\lfloor\frac ni\right\rfloor})=O(\int_1^{\sqrt n}\sqrt\frac nx{\rm d}x)=O(n^{\frac12}\cdot n^{\frac14})=O(n^{\frac34})</script><p>于是算法的时间复杂度为 $O(n^{\frac34})$ 。</p>
<p>注意到我们还可以使用 $Euler$ 筛求出 $\varphi$ 的值，进而求出前缀和</p>
<p>假设我们使用 $Euler$ 筛预先求出了 $\varphi$ 的前 $S$ 项，那么递归部分的时间复杂度变为：</p>
<script type="math/tex; mode=display">
\sum_{i=1}^{\frac ns}O(\sqrt{\left\lfloor\frac ni\right\rfloor})=O(\int_1^\frac nS\sqrt\frac nx{\rm d}x)=O(n^\frac12\cdot\sqrt\frac nS)=O(\frac n{S^\frac12})</script><p>结合 $Euler$ 筛的时间复杂度 $O(S)$，总的时间复杂度为$O(S+\frac n{S^\frac12})$</p>
<p>如果取 $S = n^\frac23$，那么总的时间复杂度为 $O(n^\frac23)$</p>
<h3 id="一般化"><a href="#一般化" class="headerlink" title="一般化"></a>一般化</h3><p>在求 $\varphi$ 和 $\mu$ 的前缀和的过程中，我们都利用了一个 $Dirichlet$ 卷积。 </p>
<p>这就让我们考虑数论函数 $f, g$ 的前缀和与他们的 $Dirichlet$ 卷积 $f ∗ g$ 的前缀和之间的关系。</p>
<p>用 $F$ 表示 $f$ 的前缀和, $h=f*g$，我们有</p>
<script type="math/tex; mode=display">
\begin{align*}
\sum_{k=1}^nh(k)&=\sum_{k=1}^n\sum_{d|k}f(\frac kd)g(d)\\
&=\sum_{d=1}^n\sum_{1\le k\le n\\~~d|k}g(d)f(\frac kd)\\
&=\sum_{d=1}g(d)\sum_{k=1}^{\left\lfloor\frac nd\right\rfloor}f(k)\\
&=\sum_{d=1}^ng(d)F(\left\lfloor\frac nd\right\rfloor)
\end{align*}</script><p>在上两例中，$f ∗ g$ 和 $g$ 的前缀和都可以 $O(1)$ 得出，因此 $f$ 可 以用杜教筛计算</p>
<p>其实并不需要如此强的性质</p>
<p>可以看到，在杜教筛的过程中，我们实际上求出了所有特殊点处的前缀和。 </p>
<p>注意到 $g$ 的前缀和是对使得 $\left\lfloor\frac nd\right\rfloor$ 相同 $d$ 分段的时候用到的，因此只需要用到 $g$ 在段落端点处的前缀和。 </p>
<p>可以发现，段落的端点恰好是所有的特殊点。 </p>
<p>因此，$f, g$ 以及 $f ∗ g$ 这三个函数中，只要有两个可以用不弱于杜教筛的方法求值，就可以杜教筛第三个。</p>
<h1 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h1><h2 id="Euler-定理"><a href="#Euler-定理" class="headerlink" title="$Euler$定理"></a>$Euler$定理</h2><p>$Euler$ 定理指出，对于正整数 $n$ 以及与 $n$ 互质的正整数 $a$，有</p>
<script type="math/tex; mode=display">
a^{\varphi(n)}\equiv1\pmod n</script><h3 id="一个常用结论"><a href="#一个常用结论" class="headerlink" title="一个常用结论"></a>一个常用结论</h3><p>对于正整数 $n$ 与正整数 $a$，$Euler$ 定理说明如果 $a\perp n$，那么对 于任意的 $m$，有</p>
<script type="math/tex; mode=display">
a^m\equiv a^{m\mod \varphi(n)}\pmod n</script><p>如果 $a$ 与 $n$ 不一定互质，若 $m \ge \varphi(n)$，我们也有以下结论</p>
<script type="math/tex; mode=display">
a^m\equiv a^{m \mod \varphi(n)\;+\;\varphi(n)}\pmod n</script><h2 id="阶"><a href="#阶" class="headerlink" title="阶"></a>阶</h2><p>给定正整数 $n$，对于 $a$ 满足 $a\perp n$，定义 $a$ 模 $n$ 的阶为最小的正整数 $d$ 使得下式成立：</p>
<script type="math/tex; mode=display">
a^d\equiv1\pmod n</script><p>$a$模$n$的阶记作$\delta_n(a)$</p>
<p>由 $Euler$ 定理可以得到 $\delta_n(a) | \varphi(n)$</p>
<h2 id="原根"><a href="#原根" class="headerlink" title="原根"></a>原根</h2><p>若 $\delta_n(a) = \varphi(n)$，则称 $a$ 是模 $n$ 的原根。 可以看出，$a$ 是模 $n$ 的原根当且仅当 $a^0,a^1,\cdots,a^{\varphi(n)−1}$ 在 $\mod n$ 意义下两两不同</p>
<p>这也是原根重要的性质和等价定义 </p>
<p>模 $n$ 存在原根当且仅当 $n = 1, 2, 4, p^k , 2p^k$，其中 $p$ 为素数，$k$ 为正整数。</p>
<h2 id="离散对数"><a href="#离散对数" class="headerlink" title="离散对数"></a>离散对数</h2><p>设 $g$ 是模 $n$ 的原根。那么对于任意 $a$ 满足 $a\perp n$，均存在 $k$ 使 得</p>
<script type="math/tex; mode=display">
g^k\equiv a\pmod n</script><p>这样的关系有助于把 $\mod n$ 的乘法转化为 $\mod \varphi(n)$ 的加法，与对数的作用有相似之处</p>
<h2 id="Lucas-定理"><a href="#Lucas-定理" class="headerlink" title="$Lucas$ 定理"></a>$Lucas$ 定理</h2><p>用 $\dbinom{n}{k}$ 表示二项式系数</p>
<p>若 $p$ 是素数，则有：</p>
<script type="math/tex; mode=display">
\dbinom nm\equiv\dbinom{n\mod p}{m\mod p}\dbinom{\left\lfloor\frac np\right\rfloor}{\left\lfloor\frac mp\right\rfloor} \pmod p</script><h3 id="推论"><a href="#推论" class="headerlink" title="推论"></a>推论</h3><p>若将 $n, m$ 都表示为 $k$ 位的 $p$ 进制数，即</p>
<script type="math/tex; mode=display">
n=\sum_{i=0}^{k-1}n_i\cdot p^i\\
m=\sum_{i=0}^{k-1}m_i\cdot p^i</script><p>那么有</p>
<script type="math/tex; mode=display">
\dbinom nm\equiv\prod_{i=1}^{k-1}\dbinom{n_i}{m_i} \pmod p</script><h2 id="组合数取模"><a href="#组合数取模" class="headerlink" title="组合数取模"></a>组合数取模</h2><p>如何求 $\dbinom{n}{m} \mod p\;$</p>
<p>如果 $n, m &lt; p$，我们可以预处理 $0$ 到 $n − 1$ 的阶乘及他们模 $p$ 的逆元，就可以 $O(1)$ 计算一个组合数 </p>
<p>否则利用 $Lucas$ 定理递归的计算</p>
<center> <a href="./download.zip">附件下载 </center>

]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>复数入门</title>
    <url>/2020/07/19/%E5%A4%8D%E6%95%B0%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="一-复数"><a href="#一-复数" class="headerlink" title="(一) 复数"></a>(一) 复数</h1><h2 id="一-定义"><a href="#一-定义" class="headerlink" title="一.定义"></a>一.定义</h2><p>若$i$符合方程$X^2+1=0$, 则$i$被称为虚数单位</p>
<p>复数$z=a+bi \left(a,b\in \mathbb{R}\right)$</p>
<p>$a$为实部, $b$为虚部, 记$:a=Re(z),b=Im(z)$</p>
<h2 id="二-分类"><a href="#二-分类" class="headerlink" title="二.分类"></a>二.分类</h2><p>当$b=0$时, 复数$z$为实数</p>
<p>当$b\ne0$时, 复数$z$为虚数</p>
<p>当$b\ne0$且$a=0$时, 复数$z$为纯虚数</p>
<script type="math/tex; mode=display">
\mathbb{R}实数集\qquad\mathbb{P}虚数集\qquad\mathbb{C}复数集\qquad\mathbb{Q}纯虚数集
\\
\mathbb{R}\cap\mathbb{P}=\varnothing \qquad\mathbb{R}\cup\mathbb{P}=\varnothing\qquad \mathbb{Q}\subsetneqq\mathbb{P}\subsetneqq\mathbb{C}</script><h2 id="三-法则"><a href="#三-法则" class="headerlink" title="三.法则"></a>三.法则</h2><p>若有复数$z_1=a+bi\;,z_2=c+di\left(a,b,c,d\in\mathbb{R}\right)$</p>
<p>加法$:z_1+z_2=(a+c)+(b+d)i$</p>
<p>减法$:z_1-z_2=(a-c)+(b-d)i$</p>
<p>乘法$:z_1\cdot z_2 = (ac-bd)+(bc+ad)i$</p>
<p>除法$:\frac{z_1}{z_2}=\frac{a+bi}{c+di}=\frac{(a+bi)(c-di)}{(c+di)(c-di)}=\frac{ac+bd}{c^2+d^2}+\frac{(bc-ad)i}{c^2+d^2}$</p>
<h2 id="四-定律"><a href="#四-定律" class="headerlink" title="四.定律"></a>四.定律</h2><p>复数运算满足加法交换律,加法结合律,乘法交换律,乘法结合律,乘法分配律</p>
<h2 id="五-共轭"><a href="#五-共轭" class="headerlink" title="五.共轭"></a>五.共轭</h2><p>当两个复数的实部相等, 虚部互为相反数时, 称这两个复数为共轭复数</p>
<p><strong>特别的</strong>, 若虚部不为零时, 也称作互为共轭虚数</p>
<p>对于复数$z=a+bi(a,b\in\mathbb{R})$, 共轭复数用$\overline{z}=a-bi(a,b\in\mathbb{R})$表示</p>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质:"></a>性质:</h3><script type="math/tex; mode=display">
\begin{align*}
&(1)\overline{z_1\pm z_2}=\overline{z_1}\pm\overline{z_2}\\
&(2)\overline{z_1z_2}=\overline{z_1}\overline{z_2}\\
&(3)\overline{\frac{z_1}{z_2}}=\frac{\overline{z_1}}{\overline{z_2}}\\
&(4)\overline{z^n}=\overline{z}^n\\
&(5)z+\overline{z}=2Re(z),\;z-\overline{z}=2iIm(z)\\
&(6)\overline{\overline{z}} = z\\
&(7)z=\overline{z}\Leftrightarrow z\in\mathbb{R}\quad -z=\overline{z}且z\ne0\Leftrightarrow z\in\mathbb{Q}
\end{align*}</script><h2 id="六-几何"><a href="#六-几何" class="headerlink" title="六.几何"></a>六.几何</h2><p>$z=a+bi(a,b\in\mathbb{R})$与复平面上的点$Z(a,b)$是一一对应的。点$Z(a,b)$与向量$\vec{OZ}$也成一一对应关系，点 $Z$与$\vec{OZ}$均为复数$z=a+bi(a,b\in\mathbb{R})$的几何形式</p>
<p>向量$\vec{OZ}$的模称为复数$Z$的模$\left\vert z \right\vert$，即</p>
<script type="math/tex; mode=display">
r=\left\vert z\right\vert=\sqrt{a^2+b^2}</script><h3 id="性质："><a href="#性质：" class="headerlink" title="性质："></a>性质：</h3><script type="math/tex; mode=display">
\begin{align*}
&(1)z\overline{z}=\left\vert z\right\vert^2=\left\vert \overline{z}\right\vert^2\\
&(2)\left\vert\left\vert z_1\right\vert-\left\vert z_2\right\vert\right\vert\leqslant\left\vert z_1\pm z_2\right\vert\leqslant\left\vert z_1\right\vert+\left\vert z_2\right\vert\\
&(3)\left\vert z\right\vert\geqslant\max(\left\vert Re(z)\right\vert,\left\vert Im(z)\right\vert)
\end{align*}</script><h1 id="二-复数的模与辐角"><a href="#二-复数的模与辐角" class="headerlink" title="(二) 复数的模与辐角"></a>(二) 复数的模与辐角</h1><p>设复数$z=a+bi(a,b\in\mathbb{R})$ 所对应的向量为$\vec{OZ}$，我们称始边是$x$轴正半轴，终边是$\vec{OZ}$的角称为复数$z$的辐角，记作：$Arg\;z$</p>
<p>在 $[0,2\pi)$的辐角叫做复数$z$的辐角主值，记作：$\arg{z}$</p>
<p>且有：</p>
<script type="math/tex; mode=display">
Arg\;z=\arg{z}+2k\pi(k\in\mathbb{Z})</script><p>当$z\in\mathbb{R}^*$时，有：</p>
<script type="math/tex; mode=display">
\arg{a}=0,\arg(-a)=\pi\\
\arg(ai)=\frac{\pi}{2},\arg(-ai)=\frac{3\pi}{2}\\
注意：\text{0的辐角时任意的}</script><p>结论：</p>
<script type="math/tex; mode=display">
\begin{align*}
&(1)Arg\;(z_1z_2)=Arg(z_1)+Arg(z_2)\\
&(2)Arh(\frac{z_1}{z_2})=Arg(z_1)-Arg(z_2)\\
&(3)Arg(z^n)=nArg(z)
\end{align*}</script><p>若复数$z=a+bi(a,b\in\mathbb{R}且ab\ne0)$，则有：</p>
<script type="math/tex; mode=display">
\arg{z}=\begin{cases}
            \arctan(\frac{b}{a}) \text{，点$(a,b)$在第一象限}\\
            \pi+\arctan(\frac{b}{a}) \text{，点$(a,b)$在第二、三象限}\\
            2\pi+\arctan(\frac{b}{a}) \text{，点$(a,b)$在第四象限}\\
            \end{cases}</script><p>设复数$z=a+bi(a,b\in\mathbb{R})$的模等于$r$，辐角为$\theta$</p>
<p>那么称$z=r(\cos{\theta}+i\sin{\theta})$为复数$z=a+bi(a,b\in\mathbb{R})$的三角式</p>
<h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><h3 id="一-平方与开方"><a href="#一-平方与开方" class="headerlink" title="一.平方与开方"></a>一.平方与开方</h3><p>若$z_1=r_1(\cos{\theta_1}+i\sin{\theta_1}),z_2=r_2(\cos{\theta_2}+i\sin{\theta_2})$，则：</p>
<script type="math/tex; mode=display">
\begin{align*}
z_1\cdot z_2&=r_1(\cos{\theta_1}+i\sin{\theta_1})\cdot r_2(\cos{\theta_2}+i\sin{\theta_2})\\
&=r_1r_2[\cos(\theta_1+\theta_2)+isin(\theta_1+\theta_2)]
\end{align*}\\
即: 积的模为模的积，积的辐角为辐角的和</script><p>复数的$n$次幂的模等于这个复数模的$n$次幂，它的辐角等于这个复数的辐角的$n$倍(***定理)，即：</p>
<script type="math/tex; mode=display">
z^n=r^n(\cos(n\theta)+i\sin(n\theta))</script><h3 id="二-除法"><a href="#二-除法" class="headerlink" title="二.除法"></a>二.除法</h3><p>若$z_1=r_1(\cos{\theta_1}+i\sin{\theta_1}),z_2=r_2(\cos{\theta_2}+i\sin{\theta_2})$，则：</p>
<script type="math/tex; mode=display">
\begin{align*}
\frac{z_1}{z_2}&=\frac{r_1(\cos{\theta_1}+i\sin{\theta_1})}{r_2(\cos{\theta_2}+i\sin{\theta_2})}\\
&=\frac{r_1}{r_2}[\cos(\theta_1-\theta_2)+i\sin(\theta_1-\theta_2)]
\end{align*}\\
即: 商的模为模的商，商的辐角为辐角的被除数减去除数的辐角</script><h3 id="三-开方"><a href="#三-开方" class="headerlink" title="三.开方"></a>三.开方</h3><p>复数$z=r(\cos\theta+i\sin\theta)$的$n(n\in\mathbb{N}^*)$次方根为：</p>
<script type="math/tex; mode=display">
\sqrt[n]z=\sqrt[n]r(\cos(\frac{\theta+2k\pi}{n})+i\sin(\frac{\theta+2k\pi}{n}))(k\in[0,n-1]\&k\in\mathbb{N})</script><p>复数的$n$次方根为$n$个复数，模均为这个复数的模的$n$次算数平方根，辐角分等于这个数的辐角与$2\pi$的$0,1,2\cdots n-1$倍的和的$n$分之一</p>
<h3 id="四-三角函数"><a href="#四-三角函数" class="headerlink" title="四.三角函数"></a>四.三角函数</h3><p>复数$z=\cos\theta+i\sin\theta=e^{i\theta}$，则：</p>
<script type="math/tex; mode=display">
\cos(n\theta)=Re(z^n)=\frac{z^{2n}+1}{2z^n}\\
\sin(n\theta)=Im(z^n)=\frac{z^{2n}-1}{2z^ni}\\
\tan(n\theta)=\frac{Im(z^n)}{Re(z^n)}=\frac{z^{2n}-1}{(z^{2n}+1)i}</script><h1 id="三-复数与方程"><a href="#三-复数与方程" class="headerlink" title="(三) 复数与方程"></a>(三) 复数与方程</h1><h2 id="一-实际方程-ax-2-bx-c-0-a-ne0-在复数集-mathbb-C-中有两个根"><a href="#一-实际方程-ax-2-bx-c-0-a-ne0-在复数集-mathbb-C-中有两个根" class="headerlink" title="一.实际方程$ax^2+bx+c=0(a\ne0)$在复数集$\mathbb{C}$中有两个根"></a>一.实际方程$ax^2+bx+c=0(a\ne0)$在复数集$\mathbb{C}$中有两个根</h2><script type="math/tex; mode=display">
x=\frac{-b\pm i\sqrt{-\Delta}}{2a}(\Delta<0)</script><h2 id="二-复平面上的曲线方程"><a href="#二-复平面上的曲线方程" class="headerlink" title="二.复平面上的曲线方程"></a>二.复平面上的曲线方程</h2><p>若复数$z$对应着复平面上的一个点$Z(x,y)$，就可以得出一些常用曲线的复数形式的方程：</p>
<script type="math/tex; mode=display">
\begin{align*}
&(1)方程\left\vert z-z_0\right\vert=r，表示以z_0为圆心，r为半径的圆\\
&(2)方程\left\vert z-z_1\right\vert=\left\vert z-z_2\right\vert，表示线段z_1z_2的垂直平分线\\
&(3)方程\left\vert z-z_1\right\vert+\left\vert z-z_2\right\vert=2a(a>0,2a>\left\vert Z_1Z_2\right\vert)，表示以Z_1Z_2为焦点，a为长半轴的椭圆\\
&\qquad若2a=\left\vert Z_1Z_2\right\vert，则此方程表示以Z_1Z_2为断点的线段\\
&(4)方程\left\vert \left\vert z-z_1\right\vert-\left\vert z-z_2\right\vert\right\vert=2a(0<2a<\left\vert Z_1Z_2\right\vert)表示以Z_1Z_2为焦点，实轴长为2a的椭圆
\end{align*}</script><h1 id="四-单位根"><a href="#四-单位根" class="headerlink" title="(四)单位根"></a>(四)单位根</h1><p>对于方程$x^n-1=0(n\in\mathbb{N}^*,n\geqslant2)$</p>
<p>由复数开方法则，就可以得到它的$n$个根</p>
<script type="math/tex; mode=display">
\epsilon_k=\cos\frac{2k\pi}{n}+i\sin\frac{2k\pi}{n}\qquad(k\in[0, n-1])</script><p>他们显然是1的$n$次方根，称为$n$次单位根</p>
<p>利用复数乘方公式，有：</p>
<script type="math/tex; mode=display">
\epsilon_k=(\cos\frac{2\pi}{n}+\sin\frac{2\pi}{n})^k=\epsilon_1^k</script><p>这说明，$n$个$n$次单位根可以表示为：</p>
<script type="math/tex; mode=display">
1,\epsilon_1,\epsilon_1^2,\epsilon_1^3,\cdots\epsilon_1^{n-1}</script><p>关于$n$次单为根，性质如下：</p>
<script type="math/tex; mode=display">
\begin{align*}
&(1)\left\vert\epsilon_k\right\vert=1\quad (k\in\mathbb{N})\\
&(2)\epsilon_j\epsilon_k=\epsilon_{j+k}\quad (j,k\in\mathbb{N})\\
&(3)\sum\limits_{i=0}^{n-1}\epsilon_1^i=0\quad (n\geqslant2)\\
&设m为整数，则：\\
&\sum\limits_{i=0}^{n-1}\epsilon_i^m=\begin{cases}n，当m时n的倍数\\
0，当m不是n的倍数\end{cases}
\end{align*}</script><h1 id="五-复数与向量的应用"><a href="#五-复数与向量的应用" class="headerlink" title="(五) 复数与向量的应用"></a>(五) 复数与向量的应用</h1><h2 id="一-设复平面上两点-Z-1Z-2-对应的复数分别是-z-1-z-2-，那么两点的距离满足："><a href="#一-设复平面上两点-Z-1Z-2-对应的复数分别是-z-1-z-2-，那么两点的距离满足：" class="headerlink" title="一.设复平面上两点$Z_1Z_2$对应的复数分别是$z_1,z_2$，那么两点的距离满足："></a>一.设复平面上两点$Z_1Z_2$对应的复数分别是$z_1,z_2$，那么两点的距离满足：</h2><script type="math/tex; mode=display">
\begin{align*}
\left\vert Z_1Z_2\right\vert^2&=\left\vert z_1-z_2\right\vert^2\\
&=(z_1-z_2)(\overline{z_1}-\overline{z_2})\\
&=\left\vert z_1\right\vert^2+|z_2|^2-(z_1\overline{z_1}+z_2\overline{z_2})
\end{align*}</script><h2 id="二-设复平面上两点-Z-1-Z-2-应的复数分别是-z-1-z-2-，那么线段-Z-1Z-2-定比分点-Z-对应的复数可以表示为"><a href="#二-设复平面上两点-Z-1-Z-2-应的复数分别是-z-1-z-2-，那么线段-Z-1Z-2-定比分点-Z-对应的复数可以表示为" class="headerlink" title="二.设复平面上两点$Z_1,Z_2$应的复数分别是$z_1,z_2$，那么线段$Z_1Z_2$定比分点$Z$对应的复数可以表示为"></a>二.设复平面上两点$Z_1,Z_2$应的复数分别是$z_1,z_2$，那么线段$Z_1Z_2$定比分点$Z$对应的复数可以表示为</h2><script type="math/tex; mode=display">
z=\frac{z_1+\lambda z_2}{1+\lambda}</script><h2 id="三-设复平面上三个点-Z-1-Z-2-Z-3-应的复数分别是-z-1-z-2-z-3-，这三点共线的充要条件是存在不全为零的实数-lambda-1-lambda-2-lambda-3-使如下两式同时成立"><a href="#三-设复平面上三个点-Z-1-Z-2-Z-3-应的复数分别是-z-1-z-2-z-3-，这三点共线的充要条件是存在不全为零的实数-lambda-1-lambda-2-lambda-3-使如下两式同时成立" class="headerlink" title="三.设复平面上三个点$Z_1,Z_2,Z_3$应的复数分别是$z_1,z_2,z_3$，这三点共线的充要条件是存在不全为零的实数$\lambda_1\lambda_2\lambda_3$,使如下两式同时成立:"></a>三.设复平面上三个点$Z_1,Z_2,Z_3$应的复数分别是$z_1,z_2,z_3$，这三点共线的充要条件是存在不全为零的实数$\lambda_1\lambda_2\lambda_3$,使如下两式同时成立:</h2><script type="math/tex; mode=display">
\begin{cases}
\lambda_1+\lambda_2+\lambda_3=0\\
\lambda_1z_1+\lambda_2z_2+\lambda_3z_3=0
\end{cases}</script><h2 id="四-设不共线的四点-A-B-C-D-对应的复数分别为-z-1-z-2-z-3-z-4-则四点共圆的充要条件是"><a href="#四-设不共线的四点-A-B-C-D-对应的复数分别为-z-1-z-2-z-3-z-4-则四点共圆的充要条件是" class="headerlink" title="四.设不共线的四点$A,B,C,D$对应的复数分别为$z_1,z_2,z_3,z_4$,则四点共圆的充要条件是:"></a>四.设不共线的四点$A,B,C,D$对应的复数分别为$z_1,z_2,z_3,z_4$,则四点共圆的充要条件是:</h2><script type="math/tex; mode=display">
\frac{z_3-z_1}{z_4-z_1}=\frac{z_3-z_2}{z_4-z_2}=\lambda(\lambda\in\mathbb{R}且\lambda\ne0)</script><h2 id="五-设不共线的三点-A-B-C-对应的复数-z-1-z-2-z-3-则-Delta-ABC-的面积公式为"><a href="#五-设不共线的三点-A-B-C-对应的复数-z-1-z-2-z-3-则-Delta-ABC-的面积公式为" class="headerlink" title="五.设不共线的三点$A,B,C$对应的复数$z_1,z_2,z_3$,则$\Delta ABC$的面积公式为:"></a>五.设不共线的三点$A,B,C$对应的复数$z_1,z_2,z_3$,则$\Delta ABC$的面积公式为:</h2><script type="math/tex; mode=display">
S_{\Delta ABC}=\frac{i}{4}\cdot
\begin{vmatrix}
1&1&1\\
z_1&z_2&z_3\\
\overline{z_1}&\overline{z_2}&\overline{z_3}
\end{vmatrix}</script>]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>基础多项式</title>
    <url>/2020/07/29/%E5%9F%BA%E7%A1%80%E5%A4%9A%E9%A1%B9%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="快速傅里叶变换"><a href="#快速傅里叶变换" class="headerlink" title="快速傅里叶变换"></a>快速傅里叶变换</h1><h2 id="多项式"><a href="#多项式" class="headerlink" title="多项式"></a>多项式</h2><p>一个环 $R$ 上的关于 $x$ 的多项式可以写作 </p>
<script type="math/tex; mode=display">
A(x) = \sum_{i=0}^na_ix^i</script><p>其中 $a_i \in \mathbb{R}$</p>
<p>$x$ 被称为这个多项式的自由元</p>
<p>多项式的次数被定义为其最高非零次项的次数，记为 $\deg A(x)$</p>
<h2 id="多项式运算"><a href="#多项式运算" class="headerlink" title="多项式运算"></a>多项式运算</h2><p>设 $A(x),\; B(x)$ 是次数不超过 $n$ 的多项式</p>
<p>那么加法和减法运算被定义为： </p>
<script type="math/tex; mode=display">
A(x) \pm B(x) = \sum^n_{i=0} (a_i \pm b_i)x^i</script><p>显然可以在 $O(n)$ 时间内计算这两个多项式的和或差</p>
<h2 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h2><p>设 $a, b$ 是两个数列，那么这两个数列的卷积 $c$ 的定义为 </p>
<script type="math/tex; mode=display">
c_k = \sum_{i+j=k} a_ib_j</script><h2 id="多项式乘法"><a href="#多项式乘法" class="headerlink" title="多项式乘法"></a>多项式乘法</h2><p>两个多项式的乘积被定义为：</p>
<script type="math/tex; mode=display">
A(x)B(x)=\sum_{i=0}^n\sum_{i=0}^na_ib_jx^{i+j}=\sum_{k=0}^{2n}c_kx^k</script><p>其中 $c$ 是 $a$ 与 $b$ 的卷积</p>
<p>朴素的按定义计算多项式乘法的时间复杂度是 $O(n^2)$ 的</p>
<h2 id="多项式点值表示"><a href="#多项式点值表示" class="headerlink" title="多项式点值表示"></a>多项式点值表示</h2><p>给定一个不超过 $n$ 次的多项式 $A(x)$ 以及 $n + 1$ 个不同的点 $x_0,\cdots,x_n$,令 $y_i = A(x_i)$</p>
<p>则这 $n + 1$ 组 $(xi , yi)$ 唯一的确定了这个多项式 $A(x)$</p>
<p>这些 $(x_i,y_i)$ 称作这个多项式的点值表示</p>
<p>如果给出 $A(x)$ 和 $B(x)$ 分别在 $x_0,\cdots,x_n$ 下的点值，则可以在 $O(n)$ 时间内得到 $A(x) \pm B(x)$ 或 $A(x)B(x)$ 在同一组位置处的点值</p>
<h2 id="系数与点值表示"><a href="#系数与点值表示" class="headerlink" title="系数与点值表示"></a>系数与点值表示</h2><p>给出 $n$ 次多项式 $A(x)$ 的各项系数，可以通过求值计算多项式的点值表示</p>
<p>给出 $n$ 次多项式 $A(x)$ 的点值表示，可以通过待定系数，解方程得到多项式的各项系数</p>
<p>得到多项式的各项系数</p>
<p>如何在多项式的系数和点值表示之间快速转换？</p>
<p>这促使我们考虑一组特殊的点值</p>
<h2 id="单位根"><a href="#单位根" class="headerlink" title="单位根"></a>单位根</h2><p><a href="https://alansblog.ink/2020/07/19/复数入门/#四-单位根" target="_blank" rel="noopener"><strong>仅供参考</strong></a></p>
<p>满足 $x^n−1=0$ 的 $x$ 被称作 $n$ 次单位根</p>
<p>设 $\omega$ 是 $n$ 次单位根</p>
<p>如果 $ω_0,ω_1,\cdots, ω_m(m=n-1)$ 恰好生成了所有的 $n$ 次单位根（即两两不同），则称 $ω$ 为本原单位根</p>
<p>这等价于 $n$ 是 最小的使得 $\omega^n−1=0$ 的正整数。我们用 $\omega_n$ 来表示一个 $n$ 次本原单位根</p>
<p>在复数域 $\mathbb{C}$ 上，$\omega_n = \exp(\frac{2πi}n)=\cos\frac{2π}n +i\sin\frac{2π}n$ 是一个本原单位根</p>
<p>下文首先考虑 $\mathbb{C}$ 上的多项式</p>
<p>在有限域（即模素数的情况）中，本原单位根与数论中的原根有关</p>
<h2 id="离散傅里叶变换"><a href="#离散傅里叶变换" class="headerlink" title="离散傅里叶变换"></a>离散傅里叶变换</h2><p>设 $a$ 是长度为 $n$ 的数列，对 $0 \le k &lt; n$，令</p>
<script type="math/tex; mode=display">
b_k=\sum_{i=0}^{n-1}a_i\cdot{\omega_n}^{ki}</script><p>则称 $b$ 为 $a$ 的离散傅里叶变换 $(DFT)$ ，记作 $b = F(a)$</p>
<p>容易看出，令 $A(x) = \sum a_ix^i$，则 $b_k$ 就是 $A(x)$ 在 ${ω_n}^k$ 处的点值</p>
<p>因此计算 $a$ 的 $DFT$ 与计算 $A(x)$ 在 ${\omega_n}^0,{\omega_n}^1,\cdots,{\omega_n}^{n−1}$ 处的点值表示是等价的</p>
<h2 id="离散傅里叶变换的逆变换"><a href="#离散傅里叶变换的逆变换" class="headerlink" title="离散傅里叶变换的逆变换"></a>离散傅里叶变换的逆变换</h2><p>对于长度为 $n$ 的序列 $a, b$，回忆 $DFT$ 的定义 :</p>
<script type="math/tex; mode=display">
b_k=\sum_{i=0}^{n-1}a_i{\omega_n}^{ki}(0\le k<n)\qquad(1)</script><p>下面我们来证明 $(1)$ 的逆变换$(IDFT)$如下 :</p>
<script type="math/tex; mode=display">
a_k=\frac 1n\sum_{i=0}^{n-1}b_i{\omega_n}^{-ki}(0\le k<n)\qquad(2)</script><p>考虑将$(1)$代入$b_i$, 有:</p>
<script type="math/tex; mode=display">
\begin{align*}
\sum_{i=0}^{n-1}b_i{\omega_n}^{-ki}&=\sum_{i=0}^{n-1}{\omega_n}^{-ki}\sum_{j=0}^{n-1}{\omega_n}^{ij}a_j\\
&=\sum_{j=0}^{n-1}a_j\sum_{i=0}^{n-1}{\omega_n}^{-ki}{\omega_n}^{ij}\\
&=\sum_{j=0}^{n-1}a_j\sum_{i=0}^{n-1}{\omega_n}^{i(j-k)}
\end{align*}</script><p>我们考虑式子中的$\sum\limits_{i=0}^{n-1}{\omega_n}^{i(j-k)}$这一部分</p>
<p>若 $j=k$ , 则</p>
<script type="math/tex; mode=display">
\sum_{i=0}^{n-1}{\omega_n}^{i(j-k)}=\sum_{i=0}^{n-1}1=n</script><p>若 $j=k$, 则由 $0\le j, k\le n$, 有$|j-k| &lt; n$, 故${\omega_n}^{j-k}\ne1$</p>
<p>因此可以由等比数列数列求和的结论得到</p>
<script type="math/tex; mode=display">
\begin{align*}
\sum_{i=0}^{n-1}{\omega_n}^{i(j-k)}&=\sum_{i=0}^{n-1}({\omega_n}^{j-k})^i\\
&=\frac{1-({\omega_n}^{j-k})^n}{1-{\omega_n}^{j-k}}\\
&=\frac{1-({\omega_n}^n)^{j-k}}{1-{\omega_n}^{j-k}}\\
&=\frac{1-1}{1-{\omega_n}^{j-k}}=0
\end{align*}</script><p>因此, 有</p>
<script type="math/tex; mode=display">
\begin{align*}
\frac 1n\sum_{i=0}^{n-1}b_i{\omega_n}^{-ki}&=\frac 1n\sum_{i=0}^{n-1}{\omega_n}^{-ki}\sum_{j=0}^{n-1}{\omega_n}^{ij}a_j\\
&=\frac 1n\sum_{j=0}^{n-1}a_j\sum_{i=0}^{n-1}{\omega_n}^{i(j-k)}\\
&=\frac 1nna_k=a_k
\end{align*}</script><p>即$(2)$成立</p>
<p>类似的，可以证明由 $(2)$ 成立可以推出 $(1)$ 成立，故这两式是互逆的</p>
<p>这就是 $IDFT$</p>
<p>$IDFT$ 是 $DFT$ 的逆变换，也就意味着已知多项式在单位根处的点值，$IDFT$ 能够求出多项式的各项系数. 在这种意义上，这个 过程也可以看作插值</p>
<h2 id="循环卷积"><a href="#循环卷积" class="headerlink" title="循环卷积"></a>循环卷积</h2><p>对于两个长度为 $n$ 的序列 $a, b$，定义</p>
<script type="math/tex; mode=display">
c_k=\sum_{(i+j)\;mod\;n\;=\;k}a_ib_j</script><p>则称 $c$ 为 $a$ 与 $b$ 的循环卷积，记为 $c = a ∗ b$</p>
<p>关于循环卷积与 $DFT$，我们有如下定理：</p>
<script type="math/tex; mode=display">
F(a*b)=F(a)\cdot F(b)</script><p>其中 $\cdot$ 表示逐点乘积</p>
<h2 id="快速傅里叶变换1"><a href="#快速傅里叶变换1" class="headerlink" title="快速傅里叶变换1"></a>快速傅里叶变换1</h2><p>按定义，我们可以 $O(n^2)$ 实现 $DFT$ 或 $IDFT$. 快速傅里叶变换是快速计算 $DFT$ 的方法，时间复杂度为 $O(n \log n)$</p>
<p>当 $n$ 为 $2$ 的幂次的时候，我们可以使用 $Cooley–Tukey$ 算法来实现 $FFT$</p>
<h2 id="单位根的一些性质"><a href="#单位根的一些性质" class="headerlink" title="单位根的一些性质"></a>单位根的一些性质</h2><p>考虑 $\omega_n$ 与$ω_m(m=2n)$, 我们有</p>
<script type="math/tex; mode=display">
({\omega_{2n}}^k)^2={\omega_n}^k\\
{\omega_{2n}}^{n+k}=-{\omega_{2n}}^k</script><p>设 $n = 2m$. 我们考虑将 $A(x)$ 的项按次数的奇偶性分类：</p>
<script type="math/tex; mode=display">
\begin{align*}
A(x)=\sum_{0\le i<n}a_ix^i&=\sum_{0\le i<m}a_{2i}x^{2i}+\sum_{0\le i<m}a_{2i+1}x^{2i+1}\\
&=\sum_{0\le i<m}a_{2i}x^{2i}+x\sum_{0\le i<m}a_{2i+1}x^{2i}
\end{align*}</script><p>定义</p>
<script type="math/tex; mode=display">
\begin{align*}
A_0(x)&=\sum_{0\le i<m}a_{2i}x^i\\
A_1(x)&=\sum_{0\le i<m}a_{2i+1}x^i
\end{align*}</script><p>那么 $A_0(x)$, $A_1(x)$ 都是次数不超过 $m$ 的多项式，并且有</p>
<script type="math/tex; mode=display">
A(x)=A_0(x^2)+xA_1(x^2)</script><h2 id="蝴蝶操作"><a href="#蝴蝶操作" class="headerlink" title="蝴蝶操作"></a>蝴蝶操作</h2><p>结合单位根的性质，对于 $0 ≤ k &lt; m$，我们有</p>
<script type="math/tex; mode=display">
\begin{align*}
A({ω_n}^k) &= A_0(({ω_n}^k)^2 ) + {ω_n}^kA_1(({ω_n}^k)^2) \\
&= A_0({ω_m}^k)+ {ω_n}^kA_1({ω_m}^k)\\
A({ω_n}^{m+k})&= A_0(({ω_n}^{m+k})^2)+{ω_n}^{m+k}A_1(({ω_n}^{m+k} )^2)\\
&= A_0({ω_m}^k)−{ω_n}^kA_1({ω_m}^k)
\end{align*}</script><p>以上两式常被称为蝴蝶操作</p>
<h2 id="快速傅里叶变换2"><a href="#快速傅里叶变换2" class="headerlink" title="快速傅里叶变换2"></a>快速傅里叶变换2</h2><p>通过蝴蝶操作的过程可以看出，如果我们得到了 $A_0(x), A_1(x)$ 在点 ${ω_m}^0,{ω_m}^1, . . . , {ω_m}^{m−1}$ 处的点值，我们可以在 $O(n)$ 时间内计算出 $A(x)$ 在 ${ω_n}^0 , {ω_n}^1,\cdots, {ω_n}^{n−1}$ 处的点值</p>
<p>而计算 $A0, A1$ 的点值的过程可以递归分治进行</p>
<p>根据主定理，我们可以在 $O(n \log n)$ 的时间内求出所要的 $A(x)$ 的点值表示</p>
<p>为了快速的进行 $IDFT$，对比 $DFT$ 与 $IDFT$ 的表达式，可以发现我们只需要将 $FFT$ 过程中用到的 $ω_n$ 全部替换为 $ω_n^{-1}$，最后再 乘以 $\frac 1n$ 即可。</p>
<p><img src="./FFT.png" alt=""></p>
<h2 id="位逆序置换"><a href="#位逆序置换" class="headerlink" title="位逆序置换"></a>位逆序置换</h2><p>可以观察到，令 $rev(x)$ 表示将 $x$ 的二进制位的顺序反转之后得到的数字，令 </p>
<script type="math/tex; mode=display">
a_i^\prime=a_{rev(i)}</script><p>则每次需要对 $a$ 进行的蝴蝶操作在 $a\prime$ 中变成了对两个相邻的序列的操作</p>
<p>把 $a$ 转化为 $a\prime$ 的过程常称为位逆序置换</p>
<h2 id="非递归的-FFT-实现"><a href="#非递归的-FFT-实现" class="headerlink" title="非递归的 $FFT$ 实现"></a>非递归的 $FFT$ 实现</h2><p>因此得到 $a\prime$ 后，我们首先对 $a\prime$ 的每一对相邻的长度为 $1$ 的子序 列做蝴蝶操作，然后对每一对相邻的长度为 $2$ 的子序列$\cdots\cdots$最 后对两个长度为 $\frac n2$ 的子序列做蝴蝶操作，我们就完成了对 $a$ 的 $FFT$</p>
<p>$DFT$ 与 $FFT$ 都是在 $\mathbb{C}$ 中进行的过程</p>
<p>在很多时候，我们往往是在对整数进行操作，并且经常要对某个素数 $p$ 取模</p>
<p>注意到单位根在 $DFT$ 中起了重要的作用，我们来考虑在模素数的时候是否存在和单位跟性质类似的元素</p>
<h2 id="原根"><a href="#原根" class="headerlink" title="原根"></a>原根</h2><p>设 $p$ 是素数. 由费马小定理，我们知道对于任意 $a$ 满足 $p - a$， 有</p>
<script type="math/tex; mode=display">
a^{p-1}\equiv1\pmod p</script><p>$g$ 称为模 $p$ 的原根，当且仅当 $g_0 , g_1 ,\cdots, g_q(q=p−2)$ 在模 p 意义下互 不相同。 可以证明，模质数的原根总是存在的</p>
<p>原根的性质和本原单位根非常类似. 换句话说，在 $\mod p$ 意义 下，$g$ 可以被看做一个 $p − 1$ 次本原单位根</p>
<h2 id="数论变换"><a href="#数论变换" class="headerlink" title="数论变换"></a>数论变换</h2><p>设 $n$ 满足 $n | p − 1$. 令 $ωn = g^{\frac{p−1}n} $. 那么有</p>
<script type="math/tex; mode=display">
{\omega_n}^n=(g^{\frac{p-1}n})^n\equiv1\pmod p</script><p>并且 ${ω_n}^0 , {ω_n}^1 ,\cdots, {ω_n}^{n−1}$ 互不相同</p>
<p>于是 $ω_n$ 在 $\mod p$ 意义下具有 $n$ 次本原单位根的性质。我们 以利用它类似的定义 $DFT$. 这被称为数论变换$NTT$</p>
<h3 id="快速数论变换"><a href="#快速数论变换" class="headerlink" title="快速数论变换"></a>快速数论变换</h3><p>如果 $n = 2k$，则也可以利用与 $FFT$ 类似的方式快速的计算数论变换。 但是因为 $2^k = n | p − 1$，这意味着快速数论变换对所选取的素数模数有着特殊的要求</p>
<p>比如常见的模数</p>
<script type="math/tex; mode=display">
P_{UOJ}=998244353=7\times17\times2^{23}+1</script><h2 id="FFT-的基本应用"><a href="#FFT-的基本应用" class="headerlink" title="$FFT$ 的基本应用"></a>$FFT$ 的基本应用</h2><p>$FFT$ 计算的是 $DFT$，因此 $FFT$ 的直接应用主要与卷积有关</p>
<ul>
<li>直接计算卷积 </li>
<li>进行多项式相关运算 </li>
<li>卷积与字符串匹配</li>
</ul>
<h3 id="计算卷积"><a href="#计算卷积" class="headerlink" title="计算卷积"></a>计算卷积</h3><p>注意到利用 $FFT$，我们能直接进行的是长度为 $2^k$ 的循环卷积</p>
<p>如果要进行一般的卷积运算，注意到两个长度为 $n$ 的序列的卷积长度为 $2n − 1$，因此一般会选择 $k$ 使得 $2^k \ge 2n − 1$，然后对序列进行长度为 $2^k$ 的 $FFT$</p>
<p>如果要进行一般的长度的循环卷积，则使用普通卷积来模拟</p>
<blockquote>
<ul>
<li><p>利用 FFT 进行多项式乘法 </p>
<blockquote>
<p>多项式乘法就是系数进行卷积的过程，因此可以使用 FFT 计算</p>
</blockquote>
</li>
<li><p>利用 FFT 进行高精度乘法</p>
<blockquote>
<p>高精度乘法就是多项式乘法，只需处理进位即可</p>
</blockquote>
</li>
</ul>
</blockquote>
<h2 id="卷积与字符串匹配"><a href="#卷积与字符串匹配" class="headerlink" title="卷积与字符串匹配"></a>卷积与字符串匹配</h2><p>假设 $x, y$ 是两个用正整数表示的字符，那么 $x = y$ 当且仅当 $(x − y)^2 = 0$</p>
<p>若 $a = (ai) $与 $b = (bi)$ 是长度分别是 $n, m$ 的两个字符串，那么 $b$ 在 $a$ 的第 $k$ 个位置匹配当且仅当</p>
<script type="math/tex; mode=display">
\sum_{i=1}^m(a_{i+k}-b_i)^2=\sum_{i=1}^m{a_{i+k}}^2+\sum_{i=1}^m{b_i}^2-2\sum_{i=1}^ma_{i+k}b_i=0</script><p>注意到其中前两项容易计算，而第三项可以化为卷积，因此可以使用 $FFT$ 计算</p>
<h2 id="含有通配符的字符串匹配"><a href="#含有通配符的字符串匹配" class="headerlink" title="含有通配符的字符串匹配"></a>含有通配符的字符串匹配</h2><p>如果 $b$ 中含有一种特殊的字符（通配符）可以与 $a$ 的任意字符匹配，如何求 $b$ 在 $a$ 中的匹配？ </p>
<p>不妨把通配符用 $0$ 表示，如果 $x$ 是普通字符，$y$ 可能是通配符， 那么 $x$ 与 $y$ 匹配当且仅当 $x = y$ 或 $y = 0$，也就是 $y(x − y)^2 = 0$</p>
<p>那么字符串的匹配就可以表达为：</p>
<script type="math/tex; mode=display">
\sum_{i=1}^mb_i(a_{i+k}-b_i)^2=\sum_{i=1}^m{a_{i+k}}^2b_i+\sum_{i=1}^m{b_i}^3-2\sum_{i=1}^ma_{i+k}{b_i}^2=0</script><p>类似的，这个转化后也可以利用 $FFT$ 计算</p>
<h1 id="多项式与形式幂级数"><a href="#多项式与形式幂级数" class="headerlink" title="多项式与形式幂级数"></a>多项式与形式幂级数</h1><h2 id="形式幂级数"><a href="#形式幂级数" class="headerlink" title="形式幂级数"></a>形式幂级数</h2><p>环 $R$ 上的形式幂级数形如</p>
<script type="math/tex; mode=display">
A(x)=\sum_{n\ge0}a_nx^n</script><p>其中 $a_n\in R$. x 称为这个形式幂级数的自由元</p>
<p>多项式是仅有有限项非零的形式幂级数</p>
<p>因此，形式幂级数可以 看成是对多项式的推广</p>
<p> 一般形式幂级数中的自由元不带入具体数值</p>
<h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><p>形式幂级数的运算规则与多项式的运算规则是类似的 </p>
<p>同样多项式类似，形式幂级数的乘法对应两个无穷数列的卷积</p>
<h2 id="生成函数"><a href="#生成函数" class="headerlink" title="生成函数"></a>生成函数</h2><p>可以看出，形式幂级数 $A(x)$ 自然的对应着一个无穷的数列 $a = (a_0, a_1, a_2, \cdots)$</p>
<p>因此 $A(x)$ 称为数列 $a$ 的生成函数</p>
<h2 id="模意义下的多项式"><a href="#模意义下的多项式" class="headerlink" title="模意义下的多项式"></a>模意义下的多项式</h2><p>设 $A(x), B(x), P(x)$ 是多项式。我们称 $A(x) ≡ B(x) \pmod {R(x)}$，如果存在多项式 $Q(x)$，使得</p>
<script type="math/tex; mode=display">
A(x)-B(x)=P(x)Q(x)</script><p>因此，多项式也可以在模意义下讨论</p>
<p>在实际运算中，我们时常只关心多项式（形式幂级数）的前有限 项，并且希望多项式（形式幂级数）在这种意义下参与运算</p>
<p>如 果只关心前 $n$ 项，我们采用记号 $\mod x^n$ 表示</p>
<h2 id="形式幂级数的逆元"><a href="#形式幂级数的逆元" class="headerlink" title="形式幂级数的逆元"></a>形式幂级数的逆元</h2><p>设 $A(x)$ 是形式幂级数。如果 $a_0\ne0$, 那么存在形式幂级数 $B(x)$，使得 $A(x)B(x) = 1$. 这时，称 $B(x)$ 是 $A(x)$ 的逆元，记 作 $B(x) = \frac1{A(x)}$</p>
<p>通过比较系数，我们可以得到:</p>
<script type="math/tex; mode=display">
\sum_{i=0}^ka_ib_{k-i}=[k=0]\Rightarrow
\begin{cases}
b_0=\frac 1{a_0}\\
b_n=-\frac 1{a_0}\sum\limits_{i=0}^{n-1}a_{n-i}b_i
\end{cases}</script><h2 id="形式幂级数的除法"><a href="#形式幂级数的除法" class="headerlink" title="形式幂级数的除法"></a>形式幂级数的除法</h2><p>通过定义逆元，我们可以定义除以一个形式幂级数为乘以其逆元</p>
<h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><p>定义斐波那契数列满足 $f(0) = f(1) = 1, f(n) = f(n−1) + f(n−2)$<br>求斐波那契数列的生成函数</p>
<p>可以发现我们有 $F(x) = (x + x^2 )F(x) + 1$. 因此答案是</p>
<script type="math/tex; mode=display">
F(x)=\frac 1{1-x-x^2}</script><h2 id="逆元的计算"><a href="#逆元的计算" class="headerlink" title="逆元的计算"></a>逆元的计算</h2><p>假设我们已经计算出了 $B_0(x) = B(x) \mod x^k$，那么我们有</p>
<script type="math/tex; mode=display">
A(x)B_0(x)\equiv1\pmod {x^k}</script><p>这意味着</p>
<script type="math/tex; mode=display">
(A(x)B_0(x)-1)^2\equiv0\pmod {x^{2k}}</script><p>那么我们有</p>
<script type="math/tex; mode=display">
B(x)\equiv B_0(x)(2-A(x)B_0(x))\pmod{x^{2k}}</script><p>由此可以计算出 $g(x)$ 的前 $2k$ 项</p>
<p>根据主定理，计算 $B(x) \mod x^n$ 的时间复杂度为 $O(n \log n)$</p>
<h2 id="导数与积分"><a href="#导数与积分" class="headerlink" title="导数与积分"></a>导数与积分</h2><p>设 $A(x) = \sum\limits_{n≥0}a_nx^n$ 是形式幂级数。定义 $A(x)$ 的（形式）导数为</p>
<script type="math/tex; mode=display">
A\prime(x)=\frac{\mathrm d}{\mathrm dx}A(x)=\sum_{n\ge1}na_nx^{n-1}</script><p>类似的，定义定义 $A(x)$ 的（形式）积分为</p>
<script type="math/tex; mode=display">
\int A(x)\mathrm x=\sum_{n\ge0}\frac1{n+1}a_nx^{n+1}</script><h2 id="对数"><a href="#对数" class="headerlink" title="对数"></a>对数</h2><p>（自然）对数可以由下式定义：</p>
<script type="math/tex; mode=display">
\log(1 + x)=\sum_{n≥1}(−1)^{n−1}\frac{x^n}n</script><p>设 $A(x)$ 是形式幂级数。如果 $[x^0]A(x) = 1$, 则 $A(x)$ 的对数也可以类似定义：</p>
<script type="math/tex; mode=display">
\log A(x)=\sum_{n\ge1}(-1)^{n-1}\frac{(A(x)-1)^n}n</script><p>我们有</p>
<script type="math/tex; mode=display">
\frac{\mathrm d}{\mathrm dx}\log A(x)=\frac{A\prime(x)}{A(x)}</script><p>因此，</p>
<script type="math/tex; mode=display">
\log A(x)=\int\frac{A\prime(x)}{A(x)}\mathrm dx</script><h2 id="等幂和"><a href="#等幂和" class="headerlink" title="等幂和"></a>等幂和</h2><p>给出 $n$ 个数 $α<em>1, . . . , α_n$ 定义 $p_k = \sum\limits^n</em>{i=1} α_i^k$</p>
<p>对于 $1 \le k \le n$， 求 $p_k, n ≤ 10^5$</p>
<p>注意到 $\sum\limits_{k≥0} α_kx^k = \frac1 {1−αx}$因此</p>
<p><img src="./TD.png" alt=""></p>
<p><img src="./TD2.png" alt=""></p>
<h2 id="指数"><a href="#指数" class="headerlink" title="指数"></a>指数</h2><p><img src="./TD3.png" alt=""></p>
<p><img src="./TD4.png" alt=""></p>
<center> <a href="./基础多项式.pdf">附件下载 </center>]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title>悬线Dp</title>
    <url>/2020/07/24/%E6%82%AC%E7%BA%BFDp/</url>
    <content><![CDATA[<h1 id="ZJOI2007-棋盘制作"><a href="#ZJOI2007-棋盘制作" class="headerlink" title="[ZJOI2007]棋盘制作"></a><a href="https://www.luogu.com.cn/problem/P1169" target="_blank" rel="noopener">[ZJOI2007]棋盘制作</a></h1><p>这比较模板, 算是裸的悬线$dp$</p>
<p>看见$N,M\leqslant2000$, 对了, 那就是了</p>
<p>时间复杂度$O(NM)$妥妥的</p>
<p>那么悬线法就是维护以这个点为某个边界条件, 维护其他边界范围</p>
<p>一般常用的是将这个点作为矩形的下底边, 用$left$维护最左边的范围, $right$维护最右边的范围, $up$维护上边界</p>
<p>所以这个点所在的矩阵大小就是$(right-left+1)*up$</p>
<p>如果要求什么正方形之类的, 对边特殊处理一下即可</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">2005</span>;</span><br><span class="line"><span class="keyword">int</span> N, M, Map[Maxn][Maxn];</span><br><span class="line"><span class="keyword">int</span> Left[Maxn][Maxn], Right[Maxn][Maxn], Up[Maxn][Maxn];</span><br><span class="line"><span class="keyword">int</span> AnsS, AnsQ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%d %d"</span>, &amp;N, &amp;M);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= M; ++j)</span><br><span class="line">            <span class="built_in">scanf</span> (<span class="string">"%d"</span>, Map[i] + j), Left[i][j] = Right[i][j] = j, Up[i][j] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= M; ++j) <span class="keyword">if</span> (Map[i][j] ^ Map[i][j - <span class="number">1</span>]) Left[i][j] = Left[i][j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = M - <span class="number">1</span>; j; --j) <span class="keyword">if</span> (Map[i][j + <span class="number">1</span>] ^ Map[i][j]) Right[i][j] = Right[i][j + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= M; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">1</span> &amp;&amp; Map[i][j] ^ Map[i - <span class="number">1</span>][j])</span><br><span class="line">            &#123;</span><br><span class="line">                Left[i][j] = max(Left[i - <span class="number">1</span>][j], Left[i][j]);</span><br><span class="line">                Right[i][j] = min(Right[i - <span class="number">1</span>][j], Right[i][j]);</span><br><span class="line">                Up[i][j] = Up[i - <span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> Len = Right[i][j] - Left[i][j] + <span class="number">1</span>;</span><br><span class="line">            AnsS = max(AnsS, min(Len, Up[i][j]));</span><br><span class="line">            AnsQ = max(AnsQ, Len * Up[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"%d\n%d\n"</span>, AnsS * AnsS, AnsQ);</span><br><span class="line">    system (<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>悬线Dp</tag>
      </tags>
  </entry>
  <entry>
    <title>完全平方数</title>
    <url>/2020/09/23/%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/</url>
    <content><![CDATA[<h1 id="完全平方数"><a href="#完全平方数" class="headerlink" title="完全平方数"></a><a href="https://www.luogu.com.cn/problem/P4318" target="_blank" rel="noopener">完全平方数</a></h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>就是请你求第$n$无平方因字数</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>有感觉的同学会发现，这个似乎和$\mu$有关</p>
<p>此话怎讲？</p>
<p>先考虑$\mu$的定义</p>
<script type="math/tex; mode=display">
\mu(x)=
\begin{cases}
1\quad\qquad\text{x = 1}\\
0\quad\qquad\text{x为某个不为1的完全平方数的倍数}\\
(-1)^k\quad\text{x为无平方因子数}\land x=p_1p_2\cdots p_k
\end{cases}</script><p>那么显然可以得到，无平方因子数的个数可以有如下表示</p>
<script type="math/tex; mode=display">
count=\sum_{i=1}^n\mu^2(i)</script><p>即所有无平方因字数的贡献都为$1$，而其他数没有贡献</p>
<p>那么从这里开始就可以有两种做法了</p>
<h2 id="容斥"><a href="#容斥" class="headerlink" title="容斥"></a>容斥</h2><p>就是说，要从简单的入手</p>
<p>用$n$去减掉带有平方因子数的个数</p>
<p>那么就可以来枚举一下每个完全平方数对答案的贡献</p>
<p>那么，现在有$p_1,p_2\cdots p_k$这些素数</p>
<p>$p_i^2$的贡献就有$\left\lfloor\frac n{p_i^2}\right\rfloor$</p>
<p>但是例如$p_1^2p_2^2$这个数它其实是被计算了两次的</p>
<p>多枚举几个数以后，会发现由偶数个素数构成的数会被重复计算，那么重复的部分是需要减去的</p>
<p><img src="https://s1.ax1x.com/2020/09/23/wxldOJ.png" alt=""></p>
<p>如图，红绿蓝三个交集再三个大圆中被重复计算了，中间那个像勒洛三角形的部分再减去原交集的时候同时也被剪掉了，所以又要加上它的贡献</p>
<p>那么回到这道题，就是说，一个数由$k$个因子构成，那么他的贡献可以表示为<code>(k &amp; 1) ? -1 : 1</code></p>
<p>那么这不就变回了莫比乌斯函数了吗？</p>
<p>所以可以得到：</p>
<script type="math/tex; mode=display">
ans=n-\sum_{i=2}^\sqrt n\mu(i)\left\lfloor\frac n{i^2}\right\rfloor</script><p>就可以直接写了</p>
<p>用二分查找这个应该就不用说了吧</p>
<h3 id="Code-100"><a href="#Code-100" class="headerlink" title="Code(100)"></a>Code(100)</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">5e4</span>;</span><br><span class="line"><span class="keyword">int</span> T, A, B;</span><br><span class="line"><span class="keyword">int</span> P[Maxn + <span class="number">10</span>], Cnt;</span><br><span class="line"><span class="keyword">int</span> mu[Maxn + <span class="number">10</span>];</span><br><span class="line"><span class="keyword">bool</span> Vis[Maxn + <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= Maxn; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!Vis[i]) P[++Cnt] = i, mu[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= Cnt &amp;&amp; i * P[j] &lt;= Maxn; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            Vis[i * P[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % P[j]) mu[i * P[j]] = -mu[i];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Check</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">ans</span><span class="params">(x)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">2</span>, r; i * i &lt;= x; ++i)</span><br><span class="line">		ans += mu[i] * (x / i / i);</span><br><span class="line">	<span class="keyword">return</span> ans &gt;= A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> X)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll l(X), r(X &lt;&lt; 1), ans(0);</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">ll <span class="title">Mid</span><span class="params">((l + r) &gt;&gt; <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (Check(Mid)) ans = Mid, r = Mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> l = Mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Init();</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">"%d"</span>, &amp;A);</span><br><span class="line">        Find(A);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个时间复杂度是$O(5e4+T\log n)$</p>
<p>理论上乱写都是可以过的</p>
<p>但是还是可以在稍稍优化一下</p>
<p>那么就要考虑对这个求和进行类整数分块</p>
<p>可以证明$\left\lfloor\frac n{i^2}\right\rfloor$在$i\in[1,\sqrt n]$的取值是连续的</p>
<p>那么加上这样一个分块，这道题就可以过了</p>
<h3 id="Code-100-1"><a href="#Code-100-1" class="headerlink" title="Code(100)"></a>Code(100)</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">5e4</span>;</span><br><span class="line"><span class="keyword">int</span> T, A, B;</span><br><span class="line"><span class="keyword">int</span> P[Maxn + <span class="number">10</span>], Cnt;</span><br><span class="line"><span class="keyword">int</span> mu[Maxn + <span class="number">10</span>];</span><br><span class="line"><span class="keyword">bool</span> Vis[Maxn + <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= Maxn; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!Vis[i]) P[++Cnt] = i, mu[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= Cnt &amp;&amp; i * P[j] &lt;= Maxn; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            Vis[i * P[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % P[j]) mu[i * P[j]] = -mu[i];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Maxn; ++i) mu[i] += mu[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Check</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">ll <span class="title">ans</span><span class="params">(x)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">2</span>, r; l * l &lt;= x; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">		r = min(<span class="built_in">sqrt</span>(x / (x / l / l)), <span class="built_in">sqrt</span>(x));</span><br><span class="line">		ans += (mu[r] - mu[l - <span class="number">1</span>]) * (x / l / l);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans &gt;= A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> X)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll l(X), r(X &lt;&lt; 1), ans(0);</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">ll <span class="title">Mid</span><span class="params">((l + r) &gt;&gt; <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (Check(Mid)) ans = Mid, r = Mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> l = Mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Init();</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">"%d"</span>, &amp;A);</span><br><span class="line">        Find(A);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="杜教筛"><a href="#杜教筛" class="headerlink" title="杜教筛"></a>杜教筛</h2><p>其实我们发现$\mu^2(i)$也是一个不完全积性函数</p>
<p>那么就是可以考虑使用杜教筛的</p>
<p>杜教筛就不细说了，需要了解杜教筛的可以看我的<a href="https://alansblog.ink/2020/08/19/杜教筛/" target="_blank" rel="noopener">这篇博客</a></p>
<p>考虑构造函数$g(x)$</p>
<p>使得$\mu^2*g$能够方便的表示</p>
<p>能够方便表示的函数可以想到有：$\epsilon,1,id$</p>
<p>那么显然$\epsilon,id$是不好的得到的</p>
<p>那就考虑$\mu^2*g=1$的$g$的构造（其实可以直接$\text{Min_25筛}$，不需要怎么构造别的函数）</p>
<p>那么就是说要让：</p>
<script type="math/tex; mode=display">
\sum_{d|n}\mu^2(d)g(\frac nd)=1</script><p>考虑$\mu^2(d)$有贡献时，当且仅到$d$为无平方因子数，此时要让$g(\frac nd)$也有贡献，整体贡献才可能为$1$</p>
<p>那么感觉一下，$g(\frac nd)$大概是一个与完全平方数有关的函数</p>
<p>那么定义$g(x)=[x==\left\lfloor\sqrt x\right\rfloor^2]$，即 $x$是否是完全平方数</p>
<p>那么对于$\mu^2*g=1$就是成立的了，简单证明一下：</p>
<blockquote>
<p>要让$\mu^2(d)g(\frac nd)=1$当且仅当$d$为无平方因字数且$\frac nd$为完全平方数时才有贡献</p>
<p>那么分两种情况考虑：</p>
<blockquote>
<p>$d$为无平方因子数：那么显然当$\frac nd$不为$1$时$g(\frac nd)$的函数值都为$0$，那么只有$d=n$时，$f(n)g(1)=1$</p>
<p>$d$不为无平方因子数：就是只有当$\frac nd$为$n$的最大平方因子时，$d$才是无平方因子数，$\frac nd$也是完全平方数，此时才有$1$的贡献</p>
</blockquote>
</blockquote>
<p>所以证明了这个构造是没有问题的</p>
<p>接下来，就是杜教筛的套路：</p>
<script type="math/tex; mode=display">
\begin{align*}
g(1)S(n)&=\sum_{i=1}^n(\mu^2*g)(i)-\sum_{i=2}^ng(i)S(\left\lfloor\frac ni\right\rfloor)\\
g(1)S(n)&=n-\sum_{i=2}^ng(i)S(\left\lfloor\frac ni\right\rfloor)\\
\end{align*}</script><p>考虑到$g$函数的性质，会发现只有当$i$为完全平方数时，才有贡献</p>
<p>那么这个又可以写成：</p>
<script type="math/tex; mode=display">
S(n)=n-\sum_{i=2}^\sqrt n S(\left\lfloor\frac n{i^2}\right\rfloor)</script><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MMu</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= Maxn) <span class="keyword">return</span> mu[x];</span><br><span class="line">    <span class="keyword">if</span> (Mu[x]) <span class="keyword">return</span> Mu[x];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Ans</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l(<span class="number">2</span>); <span class="number">1l</span>l * l * l &lt;= x; ++l) Ans += MMu(x / (l * l));</span><br><span class="line">    <span class="keyword">return</span> Mu[x] = x - Ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是一个样子的，最后套上二分，这道题就愉快的结束了</p>
<h3 id="Code-100-2"><a href="#Code-100-2" class="headerlink" title="Code(100)"></a>Code(100)</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="built_in">unordered_map</span> &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; Mu;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">1e6</span>;</span><br><span class="line"><span class="keyword">int</span> T, A, B;</span><br><span class="line"><span class="keyword">int</span> P[Maxn + <span class="number">10</span>], Cnt;</span><br><span class="line"><span class="keyword">int</span> mu[Maxn + <span class="number">10</span>];</span><br><span class="line"><span class="keyword">bool</span> Vis[Maxn + <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= Maxn; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!Vis[i]) P[++Cnt] = i, mu[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= Cnt &amp;&amp; <span class="number">1l</span>l * i * P[j] &lt;= Maxn; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            Vis[i * P[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % P[j]) mu[i * P[j]] = mu[i];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mu[i] += mu[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MMu</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= Maxn) <span class="keyword">return</span> mu[x];</span><br><span class="line">    <span class="keyword">if</span> (Mu[x]) <span class="keyword">return</span> Mu[x];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Ans</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l(<span class="number">2</span>); <span class="number">1l</span>l * l * l &lt;= x; ++l) Ans += MMu(x / (l * l));</span><br><span class="line">    <span class="keyword">return</span> Mu[x] = x - Ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> X)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll l(X), r(X &lt;&lt; 1);</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">ll <span class="title">Mid</span><span class="params">((l + r) &gt;&gt; <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (MMu(Mid) &gt;= X) r = Mid;</span><br><span class="line">        <span class="keyword">else</span> l = Mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"%lld\n"</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Init();</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">"%d"</span>, &amp;A);</span><br><span class="line">        Find(A);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有时间的话，再用$\text{Min_25}$筛写一次吧</p>
<p><strong>注意：</strong>不用开$\text{long long}$的地方就别开$\text{long long}$，不明白为什么有的$OJ$连这个都要卡</p>
<p><img src="https://s1.ax1x.com/2020/09/24/wxXz4K.png" alt=""></p>
]]></content>
      <tags>
        <tag>莫比乌斯反演</tag>
        <tag>容斥</tag>
        <tag>前缀和</tag>
        <tag>Min_25筛</tag>
        <tag>杜教筛</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索专题</title>
    <url>/2020/09/05/%E6%90%9C%E7%B4%A2%E4%B8%93%E9%A2%98/</url>
    <content><![CDATA[<h1 id="必备技能"><a href="#必备技能" class="headerlink" title="必备技能"></a>必备技能</h1><ul>
<li>STL</li>
</ul>
<blockquote>
<ul>
<li>队列</li>
<li>优先队列</li>
</ul>
</blockquote>
<p>那就可以了</p>
<hr>
<h1 id="fc-DFS-amp-BFS"><a href="#fc-DFS-amp-BFS" class="headerlink" title="fc(DFS&amp;BFS)"></a>fc(DFS&amp;BFS)</h1><p>相信大家都对搜索(深搜/款搜)有了一定程度上自己的理解了</p>
<p>然后据我所了解，可能大家对这两个东西的区分度可能不是特别高，然后请允许我来<del>口胡</del>(对比、分析？)一下这两个东西</p>
<p>先来一个小练习：</p>
<p>用搜索求斐波那契数列的第$n$项</p>
<p><del>可能在座的各位已经会了递推求解、矩阵快速幂求解、通项公式求解</del></p>
<p>但还是希望大家能拿起自己的草稿纸，画一画这个运行的大概的过</p>
<p><img src="https://s1.ax1x.com/2020/09/08/wQlXmn.png" alt=""></p>
<h2 id="深度优先搜索-Depth-First-Search"><a href="#深度优先搜索-Depth-First-Search" class="headerlink" title="深度优先搜索(Depth First Search)"></a>深度优先搜索(Depth First Search)</h2><p>优势：</p>
<ul>
<li>适合状态不易储存的情况</li>
<li>有时候对子问题的依赖很强</li>
<li>符合人类的思考习惯</li>
</ul>
<p>劣势：</p>
<ul>
<li>很容易超时</li>
<li>很容易爆栈</li>
</ul>
<h2 id="宽度优先搜索-Breadth-First-Search-（Baidu-First-Search）"><a href="#宽度优先搜索-Breadth-First-Search-（Baidu-First-Search）" class="headerlink" title="宽度优先搜索(Breadth First Search （Baidu First Search）)"></a>宽度优先搜索(Breadth First Search <del>（Baidu First Search）</del>)</h2><p>优势：</p>
<ul>
<li>适合状态容易储存的问题</li>
<li>不容易爆栈（搜索深度远大于$\text{DFS}$）</li>
<li>能够将父状态继承给子状态</li>
<li>可以跑最短路啊，各种最优化问题</li>
</ul>
<p>劣势：</p>
<ul>
<li>可能产生大量的无用状态导致$MLE$</li>
<li>对某些数据结构的要求有点高</li>
</ul>
<p>接下来干嘛，练题？</p>
<p><del>太没意思了吧。。。</del></p>
<p>来点有意思的？</p>
<hr>
<h1 id="奇技淫巧一：记忆化搜索-伪dp"><a href="#奇技淫巧一：记忆化搜索-伪dp" class="headerlink" title="奇技淫巧一：记忆化搜索(伪dp)"></a>奇技淫巧一：记忆化搜索(伪dp)</h1><p>先让大家用搜索求一求</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">ll n, Feb[<span class="number">105</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">feb</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">1</span> || x == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (feb(x - <span class="number">1</span>) + feb(x -  <span class="number">2</span>)) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%lld"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">3</span>; i &lt;= n; ++i) </span><br><span class="line">        Feb[i] = (Feb[i - <span class="number">1</span>] + Feb[i - <span class="number">2</span>]) % mod;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"%lld\n"</span>, Feb[n]);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"%lld\n"</span>, feb(n));</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好像$n$从$40$开始，这两个方式跑出来的时间差距就越来越大了</p>
<p>咋搞？</p>
<p>嗯，如题：记忆化</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">ll n, Feb[<span class="number">105</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">ll ans[<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">feb</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">1</span> || x == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (ans[x]) <span class="keyword">return</span> ans[x];</span><br><span class="line">    <span class="keyword">return</span> ans[x] = (feb(x - <span class="number">1</span>) + feb(x -  <span class="number">2</span>)) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%lld"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">3</span>; i &lt;= n; ++i) </span><br><span class="line">        Feb[i] = (Feb[i - <span class="number">1</span>] + Feb[i - <span class="number">2</span>]) % mod;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"%lld\n"</span>, Feb[n]);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"%lld\n"</span>, feb(n));</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实这个没有什么不一样的</p>
<p>就是记忆化，请大家$YY$一下就好</p>
<h2 id="来点例题？"><a href="#来点例题？" class="headerlink" title="来点例题？"></a>来点例题？</h2><h3 id="SHOI2012滑雪"><a href="#SHOI2012滑雪" class="headerlink" title="SHOI2012滑雪"></a><a href="https://www.luogu.com.cn/problem/P1434" target="_blank" rel="noopener">SHOI2012滑雪</a></h3><p>那么就是用一个$f[i][j]$来记录在$(i,j)$能往下滑的最大距离</p>
<p>那么转移的话就是</p>
<script type="math/tex; mode=display">
f[i][j]=max(f[i-1][j], f[i+1][j],f[i][j-1],f[i][j+1])+1</script><p>当然，这个方程并不完全正确，大家还需要判断一下边界条件和这个高度的大小</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, ans;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">105</span>][<span class="number">105</span>], h[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"><span class="keyword">int</span> mx[] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> my[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (f[x][y]) <span class="keyword">return</span> f[x][y];</span><br><span class="line">    f[x][y] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i(<span class="number">0</span>); i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> nx = x + mx[i];</span><br><span class="line">        <span class="keyword">int</span> ny = y + my[i];</span><br><span class="line">        <span class="keyword">if</span> (nx &lt; <span class="number">1</span> || nx &gt; n || ny &lt; <span class="number">1</span> || ny &gt; m) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (h[nx][ny] &gt;= h[x][y]) <span class="keyword">continue</span>;</span><br><span class="line">        f[x][y] = max(f[x][y], dfs(nx, ny) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[x][y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i(<span class="number">1</span>); i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j(<span class="number">1</span>); j &lt;= m; ++j)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; h[i][j];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i(<span class="number">1</span>); i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j(<span class="number">1</span>); j &lt;= m; ++j)</span><br><span class="line">            ans = max(ans, dfs(i, j));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Achen"><a href="#Achen" class="headerlink" title="Achen"></a><a href="https://www.luogu.com.cn/problem/U130279" target="_blank" rel="noopener">Achen</a></h3><p>手动模拟一下</p>
<p>会发现，其实$A/B$左右是否是空的，对于这道题没有本质的影响</p>
<p>因为要走遍所有的点的话，这只有一种方案</p>
<p>然后$A/B$的顺序对于本题也没有本质影响</p>
<p>来两张图？</p>
<p><img src="https://s1.ax1x.com/2020/09/10/wGGFde.png" alt=""></p>
<p><img src="https://s1.ax1x.com/2020/09/10/wGoMo8.png" alt=""></p>
<p>好像就是如果$A$不是最靠左的点，那么$A$的实际位置应该是再往右走一格的位置，$B$也同理</p>
<p>那么所有的问题都可以转化为$A,B$分别为端点的问题了</p>
<p>再想，这个又能怎么考虑呢？</p>
<p><img src="https://s1.ax1x.com/2020/09/10/wG7sq1.png" alt=""></p>
<p>这啥意思？</p>
<p>就是到最右端点的两种方案</p>
<p>如果我们用一个数组$f[i]$来表示经过了$i$点左边的所有点后，最后到达$i$这样的情况的方案数</p>
<p>那么它可以写成这样$f[i] = f[i - 1] + f[i - 3]$</p>
<p><strong>Code</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">ll <span class="title">X</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">char</span> <span class="title">O</span><span class="params">(getchar())</span></span>;</span><br><span class="line">	<span class="keyword">while</span> (O &lt; <span class="string">'0'</span> || O &gt; <span class="string">'9'</span>) O = getchar();</span><br><span class="line">	<span class="keyword">for</span> (; O &gt;= <span class="string">'0'</span> &amp;&amp; O &lt;= <span class="string">'9'</span>; O = getchar()) X = (X &lt;&lt; <span class="number">1</span>) + (X &lt;&lt; <span class="number">3</span>) + (O ^ <span class="number">48</span>);</span><br><span class="line">	<span class="keyword">return</span> X;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll Maxn = <span class="number">1e6</span> + <span class="number">10</span>, Mod = <span class="number">998244353</span>;</span><br><span class="line">ll Feb[Maxn] = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">ll T, N, A, B;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (Feb[x]) <span class="keyword">return</span> Feb[x];</span><br><span class="line">	<span class="keyword">return</span> Feb[x] = (dfs(x - <span class="number">1</span>) + dfs(x - <span class="number">3</span>)) % Mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	T = Read();</span><br><span class="line">	<span class="keyword">while</span> (T--)</span><br><span class="line">	&#123;</span><br><span class="line">		N = Read(), A = Read(), B = Read();</span><br><span class="line">		<span class="keyword">if</span> (A &gt; B) swap(A, B);</span><br><span class="line">		<span class="keyword">if</span> (A &gt; <span class="number">1</span>) A += <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (B &lt; N) B -= <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (B &lt; A) <span class="built_in">puts</span>(<span class="string">"0"</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span> (<span class="string">"%lld\n"</span>, dfs(B - A));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就可以了</p>
<p><del>其实递推更简单，但是没有这个记搜快</del></p>
<h3 id="过河卒"><a href="#过河卒" class="headerlink" title="过河卒"></a><a href="https://www.luogu.com.cn/problem/P1002" target="_blank" rel="noopener">过河卒</a></h3><p>个人觉得这是一个板子题<del>水题</del></p>
<p>极其无脑的模拟就可以了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">50</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> __read()</span><br><span class="line">&#123;</span><br><span class="line">    int x(0), t(1);</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">'0'</span> || o &gt; <span class="string">'9'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">'-'</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">'0'</span> &amp;&amp; o &lt;= <span class="string">'9'</span>; o = getchar()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, x, y;</span><br><span class="line">ll f[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> mx[] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">-2</span>, <span class="number">-2</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> my[] = &#123;<span class="number">2</span>, <span class="number">-2</span>, <span class="number">2</span>, <span class="number">-2</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; n || y &gt; m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (f[x][y] == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (f[x][y]) <span class="keyword">return</span> f[x][y];</span><br><span class="line">    <span class="keyword">return</span> f[x][y] = dfs(x + <span class="number">1</span>, y) + dfs(x, y + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = __read(), m = __read();</span><br><span class="line">    x = __read(), y = __read();</span><br><span class="line">    f[n][m] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i(<span class="number">0</span>); i &lt; <span class="number">9</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> nx = x + mx[i];</span><br><span class="line">        <span class="keyword">int</span> ny = y + my[i];</span><br><span class="line">        <span class="keyword">if</span> (nx &lt; <span class="number">0</span> || nx &gt; n || ny &lt; <span class="number">0</span> || ny &gt; m) <span class="keyword">continue</span>;</span><br><span class="line">        f[nx][ny] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dfs(<span class="number">0</span>, <span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>嗯，记得开$long\;long$我失算了，因为没开，交了三次。。。</p>
<p>难受。。。</p>
<h1 id="奇技淫巧二：疯狂剪枝"><a href="#奇技淫巧二：疯狂剪枝" class="headerlink" title="奇技淫巧二：疯狂剪枝"></a>奇技淫巧二：疯狂剪枝</h1><p>那就是遇见不可能有贡献的答案可以直接返回</p>
<h2 id="来点例题？-1"><a href="#来点例题？-1" class="headerlink" title="来点例题？"></a>来点例题？</h2><h3 id="数的划分-加强版"><a href="#数的划分-加强版" class="headerlink" title="数的划分(加强版)"></a><a href="https://www.luogu.com.cn/problem/U130408" target="_blank" rel="noopener">数的划分(加强版)</a></h3><p>我们可以先写一个暴力，康康它可以怎么记忆化</p>
<p>$DFS$的时候，我们就记录三个参数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> __read()</span><br><span class="line">&#123;</span><br><span class="line">    int x(0), t(1);</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">'0'</span> || o &gt; <span class="string">'9'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">'-'</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">'0'</span> &amp;&amp; o &lt;= <span class="string">'9'</span>; o = getchar()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">205</span>][<span class="number">10</span>][<span class="number">205</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> rest, <span class="keyword">int</span> num, <span class="keyword">int</span> last)</span><span class="comment">//rest -&gt; 还剩多少， 还应该分几次， last -&gt; 保证枚举出来时单调的</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!num) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rest) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ans</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = last; i &lt;= rest; ++i)</span><br><span class="line">        ans += dfs(rest - i, num - <span class="number">1</span>, i);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span> (f, <span class="number">-1</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dfs(n, k, <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>记忆化一下，代码没怎么变</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> __read()</span><br><span class="line">&#123;</span><br><span class="line">    int x(0), t(1);</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">'0'</span> || o &gt; <span class="string">'9'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">'-'</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">'0'</span> &amp;&amp; o &lt;= <span class="string">'9'</span>; o = getchar()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">205</span>][<span class="number">10</span>][<span class="number">205</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> rest, <span class="keyword">int</span> num, <span class="keyword">int</span> last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (~f[rest][num][last]) <span class="keyword">return</span> f[rest][num][last];</span><br><span class="line">    <span class="keyword">if</span> (!num) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rest) <span class="keyword">return</span> f[rest][num][last] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> f[rest][num][last] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rest &lt; num * last) <span class="keyword">return</span> f[rest][num][last] = <span class="number">0</span>;</span><br><span class="line">    f[rest][num][last] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = last; i &lt;= rest; ++i)</span><br><span class="line">        f[rest][num][last] += dfs(rest - i, num - <span class="number">1</span>, i);</span><br><span class="line">    <span class="keyword">return</span> f[rest][num][last];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span> (f, <span class="number">-1</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dfs(n, k, <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看看题解，惊艳了，这种吊打我代码神仙写法都有</p>
<p>当然，我将这种写法呢，只是为了让大家深刻理解一下这的记忆化搜索还有剪枝优化</p>
<h1 id="奇技淫巧三：双向BFS、折半搜索"><a href="#奇技淫巧三：双向BFS、折半搜索" class="headerlink" title="奇技淫巧三：双向BFS、折半搜索"></a>奇技淫巧三：双向BFS、折半搜索</h1><p>怎么说？如题！</p>
<h2 id="八数码难题"><a href="#八数码难题" class="headerlink" title="八数码难题"></a><a href="https://www.luogu.com.cn/problem/P1379" target="_blank" rel="noopener">八数码难题</a></h2><p>双向$BFS$嘛，对吧？</p>
<p>那就从首尾两端分别搜一次呗</p>
<p>这有什么好处呢？</p>
<p>简单的说，这个东西它及大幅度的剪掉了无用的状态</p>
<p>上图？</p>
<p><img src="https://s1.ax1x.com/2020/09/11/wYbAtx.png" alt=""></p>
<p>如果要把这个搜索树给遍历完，那么这个的时间复杂度就是$O(2^{n+1})$</p>
<p>那么如果$n$的数量级在$30、40$左右，那么恭喜你，完了！绝对$TLE$！</p>
<p>但是$CJ$我表示不服，我就只会搜索。。。</p>
<p>那么我们稍微修改一下这棵树</p>
<p>怎么讲？</p>
<p>有很多叶子节点时没有用的！！！</p>
<p>那么我们让这棵树有两个根，看看那些叶子结点的信息重合了</p>
<p>重合了就可以更新答案</p>
<p>那么时间复杂度？$O(\sqrt{2^{n+1}})$，很可以！</p>
<p>如果原来是$1e12$的复杂度</p>
<p>根号一下就是$1e6$，随便跑啊！！！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mx[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> my[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> Now, Next, Ans = <span class="number">123804765</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span> &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; en[<span class="number">2</span>];</span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mswap</span><span class="params">(<span class="keyword">char</span> &amp;a, <span class="keyword">char</span> &amp;b)</span></span>&#123;a ^= b ^= a ^= b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Get</span><span class="params">(<span class="keyword">int</span> state,<span class="keyword">int</span> k,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> a[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">	short x, y, l = en[w][state];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j &gt;= <span class="number">0</span>; --j)&#123;</span><br><span class="line">			<span class="keyword">if</span>(state % <span class="number">10</span> == <span class="number">0</span>) x = i,y = j;</span><br><span class="line">			a[i][j] = <span class="keyword">char</span>((state % <span class="number">10</span> - <span class="number">0</span>) + <span class="string">'0'</span>), state /= <span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	short nx = x + mx[k];</span><br><span class="line">	short ny = y + my[k];</span><br><span class="line">	<span class="keyword">if</span>(nx &lt; <span class="number">0</span> || ny &lt; <span class="number">0</span> || nx &gt; <span class="number">2</span> || ny &gt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	mswap(a[x][y], a[nx][ny]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; ++j)&#123;</span><br><span class="line">			state = state * <span class="number">10</span> + <span class="keyword">int</span>(a[i][j] - <span class="string">'0'</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">if</span>(en[w].count(state)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	en[w][state] = l + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	Now = q[x].front();</span><br><span class="line">		q[x].pop();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)&#123;</span><br><span class="line">			Next = Get(Now, i, x);</span><br><span class="line">			<span class="keyword">if</span>(!Next)<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(en[!x].count(Next))&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, en[<span class="number">0</span>][Next] + en[<span class="number">1</span>][Next]);</span><br><span class="line">				<span class="built_in">exit</span>(<span class="number">0</span>); </span><br><span class="line">			&#125;</span><br><span class="line">			q[x].push(Next);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">	q[<span class="number">0</span>].push(Now);</span><br><span class="line">	q[<span class="number">1</span>].push(Ans);</span><br><span class="line">	<span class="keyword">while</span>(q[<span class="number">0</span>].size() || q[<span class="number">1</span>].size())&#123;</span><br><span class="line">		<span class="keyword">if</span>(q[<span class="number">0</span>].size())work(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span>(q[<span class="number">1</span>].size())work(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;Now);</span><br><span class="line">	<span class="keyword">if</span>(Now == Ans)<span class="built_in">puts</span>(<span class="string">"0"</span>);</span><br><span class="line">	<span class="keyword">else</span> bfs();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是吧，挺简单的</p>
<h1 id="奇技淫巧四：IDA"><a href="#奇技淫巧四：IDA" class="headerlink" title="奇技淫巧四：IDA*"></a>奇技淫巧四：IDA*</h1><h2 id="来到例题？"><a href="#来到例题？" class="headerlink" title="来到例题？"></a>来到例题？</h2><h3 id="铁盘整理"><a href="#铁盘整理" class="headerlink" title="铁盘整理"></a><a href="https://www.luogu.com.cn/problem/P2534" target="_blank" rel="noopener">铁盘整理</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> __read()</span><br><span class="line">&#123;</span><br><span class="line">    int x(0), t(1);</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">'0'</span> || o &gt; <span class="string">'9'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">'-'</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">'0'</span> &amp;&amp; o &lt;= <span class="string">'9'</span>; o = getchar()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a[maxn], f[maxn], limit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> _abs(<span class="keyword">int</span> x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="keyword">return</span> -x;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Check</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">res</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i(<span class="number">1</span>); i &lt;= n; ++i)</span><br><span class="line">        res += (_abs(a[i] - a[i + <span class="number">1</span>]) != <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bdfs</span><span class="params">(<span class="keyword">int</span> dep, <span class="keyword">int</span> pre)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> g = Check();</span><br><span class="line">    <span class="keyword">if</span> (dep + g &gt; limit) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span> (dep &gt; limit) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span> (g == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"%d\n"</span>, dep);</span><br><span class="line">        system(<span class="string">"pause"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (i != pre) &#123;</span><br><span class="line">            reverse (a + <span class="number">1</span>, a + i + <span class="number">1</span>);</span><br><span class="line">            bdfs(dep + <span class="number">1</span>, i);</span><br><span class="line">            reverse (a + <span class="number">1</span>, a + i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = __read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[i] = __read(), f[i] = a[i];</span><br><span class="line">    sort (f + <span class="number">1</span>, f + n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[i] = lower_bound(f + <span class="number">1</span>, f + n + <span class="number">1</span>, a[i]) - f;</span><br><span class="line">    a[n + <span class="number">1</span>] = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; limit &lt;= (n &lt;&lt; <span class="number">1</span>) - <span class="number">2</span>; ++limit) bdfs(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="骑士精神"><a href="#骑士精神" class="headerlink" title="骑士精神"></a><a href="https://www.luogu.com.cn/problem/P2324" target="_blank" rel="noopener">骑士精神</a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, X, Y, Get;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mx[] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">-2</span>, <span class="number">-2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> my[] = &#123;<span class="number">2</span>, <span class="number">-2</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">2</span>, <span class="number">-2</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> Now[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="keyword">char</span> Goal[<span class="number">10</span>][<span class="number">10</span>] = &#123;</span><br><span class="line">    &#123;<span class="string">'1'</span>,<span class="string">'1'</span>,<span class="string">'1'</span>,<span class="string">'1'</span>,<span class="string">'1'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'0'</span>,<span class="string">'1'</span>,<span class="string">'1'</span>,<span class="string">'1'</span>,<span class="string">'1'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'0'</span>,<span class="string">'0'</span>,<span class="string">'*'</span>,<span class="string">'1'</span>,<span class="string">'1'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'0'</span>,<span class="string">'0'</span>,<span class="string">'0'</span>,<span class="string">'0'</span>,<span class="string">'1'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'0'</span>,<span class="string">'0'</span>,<span class="string">'0'</span>,<span class="string">'0'</span>,<span class="string">'0'</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">char</span> &amp;x,<span class="keyword">char</span> &amp;y)</span></span>&#123;x ^= y ^= x ^= y;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">G</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>;++j)<span class="keyword">if</span> (Now[i][j] != Goal[i][j])++Cnt;</span><br><span class="line">    <span class="keyword">return</span> Cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IDA_STAR</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> Dep, <span class="keyword">int</span> Limit, <span class="keyword">int</span> Dir)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Get)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (Dep &gt; Limit)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (!G())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Dep);</span><br><span class="line">        Get = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> nx = x + mx[i];</span><br><span class="line">        <span class="keyword">int</span> ny = y + my[i];</span><br><span class="line">        <span class="keyword">if</span>(nx &lt; <span class="number">0</span> || nx &gt;= <span class="number">5</span> || nx &lt;<span class="number">0</span> || ny &gt;= <span class="number">5</span>)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(i + Dir == <span class="number">7</span>)<span class="keyword">continue</span>;</span><br><span class="line">        Swap(Now[x][y], Now[nx][ny]);</span><br><span class="line">        <span class="keyword">if</span> (G() + Dep &lt;= Limit)IDA_STAR(nx, ny, Dep + <span class="number">1</span>, Limit, i);</span><br><span class="line">        Swap(Now[x][y], Now[nx][ny]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        Get = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> Ch = getchar();</span><br><span class="line">            <span class="keyword">while</span>((Ch != <span class="string">'0'</span>) &amp;&amp; (Ch != <span class="string">'1'</span>) &amp;&amp; (Ch != <span class="string">'*'</span>))Ch = getchar();</span><br><span class="line">            Now[i][<span class="number">0</span>] = Ch;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; <span class="number">5</span>; ++j)Now[i][j] = getchar();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; ++j)</span><br><span class="line">                <span class="keyword">if</span>(Now[i][j] == <span class="string">'*'</span>) X = i, Y = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">15</span>; ++i)IDA_STAR(X, Y, <span class="number">0</span>, i, <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">if</span> (!Get)<span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><del>我可能没时间写了，<a href="https://oi-wiki.org/search/astar/" target="_blank" rel="noopener">好网站</a></del></p>
]]></content>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>数位DP</title>
    <url>/2020/07/22/%E6%95%B0%E4%BD%8DDP/</url>
    <content><![CDATA[<h1 id="HDU3652-B-Number"><a href="#HDU3652-B-Number" class="headerlink" title="HDU3652 B-Number"></a><a href="https://vjudge.net/problem/HDU-3652#author=0" target="_blank" rel="noopener">HDU3652 B-Number</a></h1><p>这道题, 是非常典型的一个例子, 堪称数位$Dp$的模板</p>
<h2 id="状态设计"><a href="#状态设计" class="headerlink" title="状态设计:"></a>状态设计:</h2><p>令$Dp[Pos][Lst][Num]$表示当前枚举的这个数是第$Pos$位, 前面数字的状态为$Lst$, 前面的数的和对$13$取模的结果为$Num$</p>
<p>可以枚举第$Pos$为可能的值$i$, 并有如下转移</p>
<script type="math/tex; mode=display">
Ans=\sum\limits_{i=1}^{\min(limit,\;9)}Dp[pos-1][State][(Num*10+i)\%13]</script><p>解释一下$State$:</p>
<script type="math/tex; mode=display">
\begin{align*}
    if (&State == 0)\\
        &if (i == 1) return 1;\\
        &else\;return 0;\\
    else& if (State == 1)\\
        &if (i == 1) return 1;\\
        &else\;if (i == 3) return 2;\\
        &else\;return 0;\\
    retu&rn 2;
\end{align*}</script><p>这应该算是比较明白的了</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">13</span>;</span><br><span class="line"><span class="keyword">int</span> N, A[<span class="number">15</span>], Dp[<span class="number">15</span>][<span class="number">3</span>][<span class="number">15</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Get</span><span class="params">(<span class="keyword">int</span> Lst, <span class="keyword">int</span> Now)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Lst == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> (Now == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (Lst == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> (Now == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Now == <span class="number">3</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> Pos, <span class="keyword">int</span> Lst, <span class="keyword">int</span> Num, <span class="keyword">int</span> Lim)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Pos == <span class="number">0</span>) <span class="keyword">return</span> Num == <span class="number">0</span> &amp;&amp; Lst == <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (!Lim &amp;&amp; ~Dp[Pos][Lst][Num]) <span class="keyword">return</span> Dp[Pos][Lst][Num];</span><br><span class="line">    <span class="keyword">int</span> Limit = Lim ? A[Pos] : <span class="number">9</span>, Ans(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= Limit; ++i)</span><br><span class="line">        Ans += DFS(Pos - <span class="number">1</span>, Get(Lst, i), (Num * <span class="number">10</span> + i) % M, Lim &amp;&amp; i == Limit);</span><br><span class="line">    <span class="keyword">return</span> Lim ? Ans : Dp[Pos][Lst][Num] = Ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Work</span><span class="params">(<span class="keyword">int</span> X)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Pos</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (X)</span><br><span class="line">    &#123;</span><br><span class="line">        A[++Pos] = X % <span class="number">10</span>;</span><br><span class="line">        X /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DFS(Pos, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(Dp, <span class="number">-1</span>, <span class="keyword">sizeof</span> Dp);</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span> (<span class="string">"%d"</span>, &amp;N) != EOF) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Work(N));</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="ZJOI2010-数字计数"><a href="#ZJOI2010-数字计数" class="headerlink" title="[ZJOI2010]数字计数"></a><a href="https://www.luogu.com.cn/problem/P2602" target="_blank" rel="noopener">[ZJOI2010]数字计数</a></h1><p>重复十次相同的操作……</p>
<p>因为考虑到有前导0,  会对0的统计造成影响, 所以要排除前导零的影响</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll A, B;</span><br><span class="line">ll Dp[<span class="number">20</span>][<span class="number">20</span>], Num[<span class="number">20</span>];</span><br><span class="line"><span class="function">ll <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> Pos, <span class="keyword">int</span> Nmb, ll Sum, <span class="keyword">bool</span> Lim, <span class="keyword">bool</span> Led)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Pos == <span class="number">0</span>) <span class="keyword">return</span> Sum;</span><br><span class="line">    <span class="keyword">if</span> (!Lim &amp;&amp; Led &amp;&amp; ~Dp[Pos][Sum]) <span class="keyword">return</span> Dp[Pos][Sum];</span><br><span class="line">    <span class="keyword">int</span> Up = Lim ? Num[Pos] : <span class="number">9</span>;</span><br><span class="line">    <span class="function">ll <span class="title">Ans</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= Up; ++i)</span><br><span class="line">        Ans += DFS(Pos - <span class="number">1</span>, Nmb, Sum + ((i || Led) &amp;&amp; (i == Nmb)), (i == Up) &amp;&amp; Lim, Led || i);</span><br><span class="line">    <span class="keyword">if</span> (!Lim &amp;&amp; Led) Dp[Pos][Sum] = Ans;</span><br><span class="line">    <span class="keyword">return</span> Ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Get</span><span class="params">(ll X, <span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span> (Dp, <span class="number">-1</span>, <span class="keyword">sizeof</span> Dp);</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Len</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (X)</span><br><span class="line">    &#123;</span><br><span class="line">        Num[++Len] = X % <span class="number">10</span>;</span><br><span class="line">        X /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DFS(Len, N, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%lld %lld"</span>, &amp;A, &amp;B);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; ++i) <span class="built_in">printf</span> (<span class="string">"%lld "</span>, Get(B, i) - Get(A - <span class="number">1</span>, i));</span><br><span class="line">    system (<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数位Dp</tag>
      </tags>
  </entry>
  <entry>
    <title>摆渡车</title>
    <url>/2020/09/15/%E6%91%86%E6%B8%A1%E8%BD%A6/</url>
    <content><![CDATA[<h1 id="摆渡车"><a href="#摆渡车" class="headerlink" title="摆渡车"></a><a href="https://ac.nowcoder.com/acm/problem/21471" target="_blank" rel="noopener">摆渡车</a></h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>你可以操控一辆车的发车时间，你也知道跑一次往返的时间，你还知道每一个人到达车站的时间</p>
<p>让你找到一种方案使得所有人的等待时间之和最少，求这个最小时间</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>第一反应是把到达车站的人作为一个整体<br>然后我们可以枚举最近的一次发车时间</p>
<p>假设现在的时间是$\text{i}$，最近的一次发车时间是$\text{j}$<br>那么从$j\sim i$的等待时间可以表示为$\sum_{j&lt;t_x\le i}i-t_x$<br>那么我们把这个拆开来看</p>
<script type="math/tex; mode=display">
\begin{align*}
\sum_{j<t_x\le i}i-t&=\sum_{j<t_x\le i}i-\sum_{j < t_x\le i}t_x\\
&=(cnt_i-cnt_j)*i-(sum_i-sumj)
\end{align*}</script><p>貌似变得友好了呢</p>
<p>直观感觉一下，我们有效的最近的发车时间应该是不能小于($\text{i-m}$)的</p>
<p>那么其实就是有一部分人在上一次发车时就开始等待了<br>那么这个也是要加入贡献的</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, t, mt, ans(<span class="number">0x7fffffff</span>);</span><br><span class="line"><span class="keyword">int</span> cnt[maxn], sum[maxn], f[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">x</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">o</span><span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">'0'</span> || o &gt; <span class="string">'9'</span>) o = getchar();</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">'0'</span> &amp;&amp; o &lt;= <span class="string">'9'</span>; o = getchar()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">wait</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (cnt[r] - cnt[l]) * r - (sum[r] - sum[l]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = Read(), m = Read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        mt = max(t = Read(), mt);</span><br><span class="line">        cnt[t]++, sum[t] += t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m + mt; ++i) cnt[i] += cnt[i - <span class="number">1</span>], sum[i] += sum[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m + mt; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= m &amp;&amp; cnt[i] == cnt[i - m]) &#123;</span><br><span class="line">            f[i] = f[i - m];</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        f[i] = cnt[i] * i - sum[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = max(i - <span class="number">2</span> * m + <span class="number">1</span>, <span class="number">0</span>); j &lt;= i - m; ++j)</span><br><span class="line">            f[i] = min(f[i], f[j] + wait(j, i));</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= mt) ans = min(ans, f[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Dp优化</tag>
      </tags>
  </entry>
  <entry>
    <title>旧试题</title>
    <url>/2020/08/23/%E6%97%A7%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h1 id="P4619-SDOI2018-旧试题"><a href="#P4619-SDOI2018-旧试题" class="headerlink" title="P4619 [SDOI2018]旧试题"></a><a href="https://www.luogu.com.cn/problem/P4619" target="_blank" rel="noopener">P4619 [SDOI2018]旧试题</a></h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>这里没有奇奇怪怪的描述</p>
<p>这道题说白了就是求：</p>
<script type="math/tex; mode=display">
\sum_{i=1}^A\sum_{j=1}^B\sum_{k=1}^C\text{d}(ijk)\\
其中\text{d}(x)表示x的约数个数</script><p>这道题和<a href="https://www.luogu.com.cn/problem/P3327" target="_blank" rel="noopener">P3327 [SDOI2015]约数个数和</a>比较类似，其实就是多了一个$j$</p>
<h2 id="问题化简"><a href="#问题化简" class="headerlink" title="问题化简"></a>问题化简</h2><p>我们可以知道：</p>
<script type="math/tex; mode=display">
\text{d}(ijk)=\sum_{x|i}\sum_{y|j}\sum_{z|k}[x\perp y][y\perp z][z\perp x]</script><p>即，原式可以化为：</p>
<script type="math/tex; mode=display">
\begin{align*}
\sum_{i=1}^A\sum_{j=1}^B\sum_{k=1}^C\text{d}(ijk)&=\sum_{i=1}^A\sum_{j=1}^B\sum_{k=1}^C\sum_{x|i}\sum_{y|j}\sum_{z|k}[x\perp y][y\perp z][x\perp z]\\
&=\sum_{x=1}^A\sum_{y=1}^B\sum_{z=1}^C[x\perp y][y\perp z][x\perp z][\frac Ax][\frac By][\frac Cz]\\
&\text{选择x$\perp$y进行反演，即：}\\
&=\sum_{x=1}^A\sum_{y=1}^B\sum_{z=1}^C(\sum_{d|\gcd(x,y)}\mu(d))[y\perp z][x\perp z][\frac Ax][\frac By][\frac Cz]\\
&=\sum_{d=1}^{\min(A,B)}\mu(d)\sum_{x=1}^{\lfloor\frac Ad\rfloor}\sum_{y=1}^{\lfloor\frac Bd\rfloor}\sum_{z=1}^C[yd\perp z][xd\perp z][\frac A{xd}][\frac B{yd}][\frac Cz]\\
&\text{整理一下可以得到：}\\
&=\sum_{z=1}^C[\frac Cz]\sum_{d=1}^{\min(A,B)}\mu(d)[d\perp z](\sum_{x=1}^{\frac Ad}[x\perp z][\frac A{dx}])(\sum_{y=1}^{\frac Bd}[y\perp z][\frac B{dx}])
\end{align*}</script><p>这样一来，我们就成功了一大半了</p>
<p>现在，我们发现有两串看似比较相似的运算，我们可以用一个函数来代替它:</p>
<script type="math/tex; mode=display">
f(n,k)=\sum_{i=1}^n[i\perp k][\frac ni]\\
g(n,k)=\sum_{i=1}^n\mu(i)[i\perp k]</script><p>那么：</p>
<script type="math/tex; mode=display">
\begin{align*}
Ans&=\sum_{z=1}^C[\frac Cz]\sum_{d=1}^{\min(A,B)}\mu(d)[d\perp z]f(\frac Ad,z)f(\frac Bd,z)\\
&=\sum_{z=1}^C[\frac Cz]\sum (g(r,z)-g(l-1,z))f(\frac Al,z)f(\frac Bl,z)\\
\end{align*}</script><p>这里，我们发现$\sum (g(r,z)-g(l-1,z))f(\frac Al,z)f(\frac Bl,z)$其实与$z$本身无关</p>
<p>简言之，我们只需要考虑$z$的无平方因子数</p>
<p>即：</p>
<script type="math/tex; mode=display">
lw(z)=\prod_{i=1} P_i^1</script><p>但是如何快速求解这两个函数呢？</p>
<p>按照老套路，我们可以用$f(n,k/x)\;or\;g(n,k/x)$减去这其中不可行的得到</p>
<p>那么就有：</p>
<script type="math/tex; mode=display">
\begin{align*}
f(n,k)&=\sum_{i=1}^n[i\perp k][\frac ni]\\
&=\sum_{i=1}^n[i\perp \frac kx][\frac ni]-\sum_{i=1}^n[i\perp \frac kx][\frac ni][x|i]\\
&=f(n,k/x)-\sum_{d=1}^{[\frac nx]}[dx\perp\frac kx][\frac n{dx}][x|kx]\\
&=f(n,k/x)-\sum_{d=1}^{[\frac nx]}[dx\perp\frac kx][\frac n{dx}]\\
&=f(n,k/x)-[x\perp \frac kx]\sum_{d=1}^{[\frac nx]}[d\perp\frac kx][\frac n{dx}]\\
&=f(n,k/x)-f([\frac nx],k/x)
\end{align*}</script><p>那么还有：</p>
<script type="math/tex; mode=display">
\begin{align*}
g(n,k)&=\sum_{i=1}^n\mu(i)[i\perp k]
\\&=\sum_{i=1}^n\mu(i)[i\perp \frac kx]-\sum_{i=1}^n\mu(i)[i\perp\frac kx][x|i]
\\&=g(n,k/x)-\sum_{d=1}^{[\frac nx]}\mu(dx)[dx\perp\frac kx][x|dx]
\\&=g(n, k/x)-\sum_{d=1}^{[\frac nx]}\mu(d)\mu(x)[d\perp x][dx\perp \frac kx][x|dx]
\\&=g(n,k/x)-\mu(x)[x\perp\frac kx]\sum_{d=1}^{[\frac nx]}\mu(d)[d\perp x][d\perp\frac kx]
\\&=g(n,k/x)-\mu(x)[x\perp\frac kx]\sum_{d=1}^{[\frac nx]}\mu(d)[d\perp (x*\frac kx)]
\\&=g(n,k/x)+\sum_{d=1}^{[\frac nx]}\mu(d)[d\perp k]
\\&=g(n,k/x)+g([\frac nx],k)
\end{align*}</script><p>根据上文，我们知道所有的$k$都一定是我平方因字数，所以这个结论很好得到</p>
<p>即：</p>
<script type="math/tex; mode=display">
\begin{align*}
f(n,k)&=f(n,k/x)-f(\lfloor\frac nx\rfloor,k/x)\\
g(n,k)&=g(n,k/x)+g(\lfloor\frac nx\rfloor,k)
\end{align*}</script><p>现在，最后的问题就是关于这两个函数的边界的问题了</p>
<script type="math/tex; mode=display">
\begin{align*}
g(n,1)&=\sum_{i=1}^n\mu(i)\qquad\text{这个可以直接前缀和预处理}
\\f(n,1)&=\sum_{i=1}^n[\frac ni]\qquad\,\text{这个用数论分块吗？}
\end{align*}</script><p>下面有一个非常巧妙的，线性求接的办法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Prework</span><span class="params">(<span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	D[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!Ip[i]) P[++P[<span class="number">0</span>]] = i, D[i] = <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= P[<span class="number">0</span>] &amp;&amp; i * P[j] &lt;= N; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			Ip[i * P[j]] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (i % P[j]) D[i * P[j]] = D[i] &lt;&lt; <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				D[i * P[j]] = (D[i] &lt;&lt; <span class="number">1</span>) - D[i / P[j]];</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) D[i] += D[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于这个的证明我先鸽了，<del>不会</del></p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">2e5</span> + <span class="number">10</span>, Lim = <span class="number">2e5</span>, Mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">ll D[Maxn], F[Maxn][<span class="number">10</span>], G[Maxn][<span class="number">10</span>], S[Maxn], Ans;</span><br><span class="line"><span class="keyword">int</span> Prim[Maxn], Mu[Maxn], Lw[Maxn];</span><br><span class="line"><span class="keyword">bool</span> IP[Maxn];</span><br><span class="line"><span class="keyword">int</span> T, A, B, C;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">X</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">O</span><span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (O &lt; <span class="string">'0'</span> || O &gt; <span class="string">'9'</span>) O = getchar ();</span><br><span class="line">    <span class="keyword">for</span> (; O &gt;= <span class="string">'0'</span> &amp;&amp; O &lt;= <span class="string">'9'</span>; O = getchar ()) X = (X &lt;&lt; <span class="number">1</span>) + (X &lt;&lt; <span class="number">3</span>) + (O ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> X; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Prework</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mu[<span class="number">1</span>] = D[<span class="number">1</span>] = Lw[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= Lim; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!IP[i]) Prim[++Prim[<span class="number">0</span>]] = i, Mu[i] = <span class="number">-1</span>, D[i] = <span class="number">2</span>, Lw[i] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= Prim[<span class="number">0</span>] &amp;&amp; i * Prim[j] &lt;= Lim; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> New = i * Prim[j];</span><br><span class="line">            IP[New] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % Prim[j]) D[New] = D[i] &lt;&lt; <span class="number">1</span>, Lw[New] = Lw[i] * Prim[j], Mu[New] = -Mu[i];</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                D[New] = (D[i] &lt;&lt; <span class="number">1</span>) - D[i / Prim[j]];</span><br><span class="line">                Lw[New] = Lw[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Lim; ++i) D[i] += D[i - <span class="number">1</span>], Mu[i] += Mu[i - <span class="number">1</span>];</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r; l &lt;= A; l = r + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        r = min(A / (A / l), B / (B / l));</span><br><span class="line">        G[r][<span class="number">1</span>] = Mu[r];</span><br><span class="line">        F[A / l][<span class="number">1</span>] = D[A / l];</span><br><span class="line">        F[B / l][<span class="number">1</span>] = D[B / l];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span> (S, <span class="number">0</span>, <span class="keyword">sizeof</span> S);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> z = <span class="number">1</span>; z &lt;= C; ++z) S[Lw[z]] += <span class="number">1l</span>l * C / z;</span><br><span class="line">    Ans = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">UpDate</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r; l &lt;= A; l = r + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        r = min(A / (A / l), B / (B / l));</span><br><span class="line">        G[r][k] = G[r][k - <span class="number">1</span>] + G[r / x][k];</span><br><span class="line">        F[A / l][k] = F[A / l][k - <span class="number">1</span>] - F[(A / l) / x][k - <span class="number">1</span>];</span><br><span class="line">        F[B / l][k] = F[B / l][k - <span class="number">1</span>] - F[(B / l) / x][k - <span class="number">1</span>]; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//x就是上文中推公式用的x，k表示的是第k个素数，因为空间的问题，就写成这个鬼样子了</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> z, <span class="keyword">int</span> u, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ll <span class="title">Tmp</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r; l &lt;= A; l = r + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        r = min(A / (A / l), B / (B / l));</span><br><span class="line">        Tmp += (G[r][k] - G[l - <span class="number">1</span>][k]) * F[A / l][k] * F[B / l][k];</span><br><span class="line">        Tmp = (Tmp % Mod + Mod) % Mod;</span><br><span class="line">    &#125;</span><br><span class="line">    Ans = (Ans + S[z] * Tmp % Mod) % Mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = u; <span class="number">1l</span>l * Prim[v] * z &lt;= C; v++) UpDate(Prim[v], k + <span class="number">1</span>), DFS(z * Prim[v], v + <span class="number">1</span>, k + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T = Read();</span><br><span class="line">    Prework();</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        A = Read(), B = Read(), C = Read();</span><br><span class="line">        <span class="keyword">if</span> (A &gt; B) swap (A, B);</span><br><span class="line">        Init();</span><br><span class="line">        DFS (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"%lld\n"</span>, Ans);</span><br><span class="line">    &#125;</span><br><span class="line">    system (<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title>最长异或路径</title>
    <url>/2020/09/16/%E6%9C%80%E9%95%BF%E5%BC%82%E6%88%96%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h1 id="The-XOR-longest-Path"><a href="#The-XOR-longest-Path" class="headerlink" title="The XOR-longest Path"></a><a href="https://ac.nowcoder.com/acm/problem/50349" target="_blank" rel="noopener">The XOR-longest Path</a></h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定一棵树, 让你求树上异或和最大的简单路径的异或和</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>想要异或和最大, 那么我们想要的显然是贪心, 那就是尽量让他们在二进制下不相同</p>
<p>这样考虑的话, 我们可以想到的是$01$字典树, 从高次项向低处贪心, 能保证最值</p>
<p>那么还有一个问题, 如何求一个简单路径的异或值?</p>
<p>我们又可以想到关于异或的优良性质:$x\otimes y\otimes x=y$</p>
<p>就是说, 可以随机找一个根, 求$root$到其他所有结点的链的路径异或和</p>
<p>如果我们要求的是$sum<em>{i,j}$, 那么它就可以十分简单的表示为$sum</em>{root,i}\otimes sum_{root,j}$</p>
<p>那么我们把所有的从根开始的路径插入到$01$字典树中, 暴力查询跟新答案就好惹</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">100000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> Tree[Maxn * <span class="number">31</span>][<span class="number">2</span>], Id;</span><br><span class="line"><span class="keyword">int</span> Xor[Maxn];</span><br><span class="line"><span class="keyword">int</span> N, U, V, C, Ans;</span><br><span class="line"><span class="keyword">int</span> Head[Maxn], Next[Maxn &lt;&lt; <span class="number">1</span>], Edge[Maxn &lt;&lt; <span class="number">1</span>], W[Maxn &lt;&lt; <span class="number">1</span>], Cur;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> U, <span class="keyword">int</span> V, <span class="keyword">int</span> C)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Next[++Cur] = Head[U];</span><br><span class="line">    Head[U] = Cur;</span><br><span class="line">    Edge[Cur] = V;</span><br><span class="line">    W[Cur] = C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> X, <span class="keyword">int</span> Rt = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> &lt;&lt; <span class="number">30</span>; i; i &gt;&gt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> F = X &amp; i;</span><br><span class="line">        <span class="keyword">if</span> (!Tree[Rt][F]) Tree[Rt][F] = ++Id;</span><br><span class="line">        Rt = Tree[Rt][F];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> X, <span class="keyword">int</span> Rt = <span class="number">0</span>, <span class="keyword">int</span> Ans = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> &lt;&lt; <span class="number">30</span>; i; i &gt;&gt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> F = X &amp; i;</span><br><span class="line">        <span class="keyword">if</span> (Tree[Rt][!F]) Ans += i, Rt = Tree[Rt][!F];</span><br><span class="line">        <span class="keyword">else</span> Rt = Tree[Rt][F];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> U, <span class="keyword">int</span> F)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = Head[U]; i; i = Next[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Edge[i] == F) <span class="keyword">continue</span>;</span><br><span class="line">        Xor[Edge[i]] = Xor[U] ^ W[i];</span><br><span class="line">        DFS(Edge[i], U);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;<span class="keyword">return</span> a &gt; b ? a : b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;U, &amp;V, &amp;C);</span><br><span class="line">        AddEdge(U, V, C), AddEdge(V, U, C);</span><br><span class="line">    &#125;</span><br><span class="line">    DFS(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) Insert(Xor[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) Ans = max(Ans, Query(Xor[i]));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>字典树</tag>
      </tags>
  </entry>
  <entry>
    <title>Reviwe</title>
    <url>/2020/07/12/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="T1-生物实验"><a href="#T1-生物实验" class="headerlink" title="T1:生物实验"></a>T1:生物实验</h1><ul>
<li><p>你有$n$个瓶子,其中$m$瓶有毒,然后你有$k\left(k\geqslant m\right)$ 只老鼠</p>
</li>
<li><p>每次每个瓶子只会有一只老鼠吃它!</p>
</li>
<li><p>每次有老鼠死后瓶子会被标记,以后不会再有老鼠去吃它了</p>
</li>
<li><p>问期望多少次可以把所有有毒的瓶子全部找到</p>
<p>对于$100\%$的数据有$T \leqslant 1000, N \leqslant 500, M \leqslant 200, M\leqslant K \leqslant N$</p>
</li>
</ul>
<p><strong>输入</strong>:</p>
<p>第一行是一个$T$</p>
<p>接下来$T$行每行三个正整数: $n, m, k$</p>
<p><strong>输出:</strong></p>
<p>一共有$T$行</p>
<p>对于每一组数据输出一行答案</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解:"></a>题解:</h1><blockquote>
<p>$DP[i]$表示还剩下$i$瓶有毒的期望步数</p>
<p>那么这个可以构成一张$DAG$</p>
<p>因为$i$ 这个点只能与比$i$小的点建一条有向边</p>
<p>既然已经知道有一张$DAG$了, 那么就可以拓扑逆向跑一边就可以得出答案了</p>
<script type="math/tex; mode=display">
Dp[i] = \frac{\mathrm{C}_n^k}{\mathrm{C}_{n + i}^k}\times\left(Dp[i] + 1\right) + \sum\limits_{k=1}^i\frac{\mathrm{C}_n^{k-j}\cdot\mathrm{C}_m^j}{\mathrm{C}_{n+m}^k}\left(Dp[i-k] + 1\right)</script><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">Maxn</span><span class="params">(<span class="number">1e3</span> + <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> T, N, M, K;<span class="comment">//N个瓶子, M瓶有毒, K只老鼠</span></span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"><span class="keyword">double</span> Dp[Maxn];<span class="comment">//死了i只老鼠的期望步数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> M, <span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Ans</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; ++i) Ans *= <span class="keyword">double</span>(N--) / <span class="keyword">double</span>(M - i);</span><br><span class="line">    <span class="keyword">return</span> Ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> k)</span><span class="comment">//C(k, a)/C(k, b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Ans</span><span class="params">(<span class="number">1.0</span>)</span></span>;</span><br><span class="line">    Ans = <span class="keyword">double</span> (C(k, a)) / <span class="keyword">double</span> (C(k, b));</span><br><span class="line">    <span class="keyword">return</span> Ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span><span class="comment">//C(k - j, a) * C(j, b) / C(k, c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">double</span> <span class="title">Ans</span><span class="params">(<span class="number">1.0</span>)</span></span>;</span><br><span class="line">    Ans = <span class="keyword">double</span> (C(k - j, a)) / <span class="keyword">double</span>(C(k, c)) * <span class="keyword">double</span>(C(j, b));</span><br><span class="line">    <span class="keyword">return</span> Ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%d\n"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">"%d %d %d"</span>, &amp;N, &amp;M, &amp;K);</span><br><span class="line">        n = N - M;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            k = min(K - M + i, n + i);</span><br><span class="line">            <span class="keyword">double</span> P = C(n, n + i, k), Temp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j) Temp += (Dp[i - j] + <span class="number">1.0</span>) * C(n, i, n + i, j, k);</span><br><span class="line">            Dp[i] = (Temp + P) / (<span class="number">1.0</span> - P);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"%.2lf\n"</span>, Dp[M]);</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>李超线段树</title>
    <url>/2020/08/02/%E6%9D%8E%E8%B6%85%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    <content><![CDATA[<h1 id="HEOI2013-Segment"><a href="#HEOI2013-Segment" class="headerlink" title="[HEOI2013]Segment"></a><a href="https://www.luogu.com.cn/problem/P4097" target="_blank" rel="noopener">[HEOI2013]Segment</a></h1><p>不厚道得借鉴一些$OI\;Wiki$的好东西</p>
<p>此题, 大概就是模板题了</p>
<p>其实, 如果按照常规思路, 想到的东西大概也是一样的</p>
<p>和线段树一样, 我们需要维护$X$轴上的信息</p>
<p>就是说, 我们只需要记录对于每一个$X$, 它对应的答案是啥</p>
<blockquote>
<p>对答案没有贡献的线段, 相当于就被丢弃了</p>
<p>所以此时的线段树中的值, 就是唯一的比较的对象了</p>
</blockquote>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="情况一"><a href="#情况一" class="headerlink" title="情况一:"></a>情况一:</h3><p>那么如果这个区间没有被覆盖, 可以直接标记为最值</p>
<h3 id="情况二"><a href="#情况二" class="headerlink" title="情况二:"></a>情况二:</h3><p>如果这个被覆盖了, 那么又要分三种情况</p>
<p>我们另绿色为新加入的点</p>
<h4 id="1-New-k-gt-T-X-k"><a href="#1-New-k-gt-T-X-k" class="headerlink" title="(1)$New.k&gt;T_X.k$"></a>(1)$New.k&gt;T_X.k$</h4><ul>
<li><strong>1.中值可以被更新</strong></li>
</ul>
<p><img src="./greater.png" alt=""></p>
<p>我们看见, 此时新的线段可以更新到$mid$的位置, 它也可以继续更新$mid+1$到$r$的位置, 但是$l$到$mid$的部分, 就不一定可以更新了, 但是我们可以看见, 它仍有一部分是可以更新的</p>
<ul>
<li><p><strong>2.中值无法更新</strong></p>
<p><img src="./greater2.png" alt=""></p>
</li>
</ul>
<p>那么对于这种情况, 我们就不需要更新$l$到$mid$的值了, 但是我们也有可能更新$mid+1$到$r$</p>
<h4 id="2-New-k-lt-T-X-k"><a href="#2-New-k-lt-T-X-k" class="headerlink" title="(2)$New.k&lt;T_X.k$"></a>(2)$New.k&lt;T_X.k$</h4><p><img src="./less.png" alt=""></p>
<p><img src="./less2.png" alt=""></p>
<p>同理分析即可</p>
<h4 id="3-斜率相等"><a href="#3-斜率相等" class="headerlink" title="(3)斜率相等"></a>(3)斜率相等</h4><p>显然是要截距大的啊, 是吧</p>
<h2 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>这个操作将长度为$n$的线段, 分成了$\log n$段去更新, 复杂度为$O(\log n)$</p>
<p>对于每一个$O(\log n)$的区间, 我们有花费$O(\log n)$的时间往下更新</p>
<p>故插入的时间复杂度大约为$O(\log^2n)$</p>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>就得到包含$x$的所有区间的中值</p>
<p>那么这样的区间有多少呢?</p>
<blockquote>
<p>口胡开始了, 假设这个点为$P$, 他左边有$X$个节点, 那么右边就有$N-X-1$个节点, 那么左端点的个数就有$X$个, 右端点就有$N-X-1$个</p>
<p>乘法原理, 求和算期望, 就可以了</p>
</blockquote>
<p>!#%!$%!@:%&gt;!”$%!@#%!@$!”@&gt;%3!@#&gt;%#&gt;:&gt;”1”</p>
<p>$Fake$了啊</p>
<p>这棵树一共就才多少节点, 一共就只有多少层 ?</p>
<p>$\log n$?</p>
<p>差不多, $\log n$跑一次就可以出答案了</p>
<p>快乐水过了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">1005</span>;</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">double</span> X, Y;</span><br><span class="line">bool Xf(1), Yf(1);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> X, Y, G;</span><br><span class="line">&#125;Points[Maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Solve</span><span class="params">(<span class="keyword">double</span> M)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    double x(0), y(0), Temp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        Temp = <span class="built_in">sqrt</span>((X - Points[i].X) * (X - Points[i].X) + (Y - Points[i].Y) * (Y - Points[i].Y));</span><br><span class="line">        <span class="keyword">if</span> (!Temp) <span class="keyword">continue</span>;</span><br><span class="line">        x += Points[i].G / Temp * (Points[i].X - X);</span><br><span class="line">        y += Points[i].G / Temp * (Points[i].Y - Y);</span><br><span class="line">    &#125;</span><br><span class="line">    Temp = <span class="built_in">sqrt</span>(x * x + y * y);</span><br><span class="line">    Y += M / Temp * y;</span><br><span class="line">    X += M / Temp * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">"%d %d %d"</span>, &amp;Points[i].X, &amp;Points[i].Y, &amp;Points[i].G);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> M = <span class="number">10000</span>, tx, ty;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tx = X, ty = Y;</span><br><span class="line">        Solve(M);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(tx - X) &lt; <span class="number">0.00001</span> &amp;&amp; <span class="built_in">abs</span>(ty - Y) &lt; <span class="number">0.00001</span>) <span class="keyword">break</span>;</span><br><span class="line">        M *= <span class="number">0.9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"%.3lf %.3lf\n"</span>, X, Y);</span><br><span class="line">    system (<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>学习笔记</tag>
        <tag>李超线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>树状数组</title>
    <url>/2020/09/22/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="一维树状数组"><a href="#一维树状数组" class="headerlink" title="一维树状数组"></a>一维树状数组</h1><p>这是一个单次修改、查询都为$O(\log n)$的数据结构，空间复杂度为 $O(n)$</p>
<p>当然有时候还是会用一些辅助数组的</p>
<h2 id="树状数组-1-：单点修改，区间查询"><a href="#树状数组-1-：单点修改，区间查询" class="headerlink" title="树状数组 1 ：单点修改，区间查询"></a><a href="https://loj.ac/problem/130" target="_blank" rel="noopener">树状数组 1 ：单点修改，区间查询</a></h2><p>有这样一个区间查询，首先想到的就是用左右端点的前缀和做差去维护</p>
<p>那么对于裸的前缀和，一次修改操作的时间复杂度为$O(n)$</p>
<p>所以想到用数据结构乱搞一下</p>
<p>那么就是用树状数组去维护，具体就不细说了，直接上代码</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> ll __read()</span><br><span class="line">&#123;</span><br><span class="line">    ll x(0), t(1);</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">'0'</span> || o &gt; <span class="string">'9'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">'-'</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">'0'</span> &amp;&amp; o &lt;= <span class="string">'9'</span>; o = getchar()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll n, m;</span><br><span class="line">ll t[maxn], d[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Update</span><span class="params">(ll x, ll val)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ll <span class="title">temp</span><span class="params">(x)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (x &lt;= n) &#123;</span><br><span class="line">        t[x] += val;</span><br><span class="line">        d[x] += val * temp;</span><br><span class="line">        x += lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Query</span><span class="params">(ll x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans(0), temp(x);</span><br><span class="line">    <span class="keyword">while</span> (x) &#123;</span><br><span class="line">        ans += t[x] * (temp + <span class="number">1</span>) - d[x];</span><br><span class="line">        x ^= lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = __read(), m = __read();</span><br><span class="line">    ll last = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        ll x = __read();</span><br><span class="line">        Update(i, x - last);</span><br><span class="line">        last = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        ll opt = __read(), l = __read(), r = __read();</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">1</span>) &#123;</span><br><span class="line">            ll k = __read();</span><br><span class="line">            Update(l, k);</span><br><span class="line">            Update(r + <span class="number">1</span>, -k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span> (<span class="string">"%lld\n"</span>, Query(r) - Query(l - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="树状数组-2-：区间修改，单点查询"><a href="#树状数组-2-：区间修改，单点查询" class="headerlink" title="树状数组 2 ：区间修改，单点查询"></a><a href="https://loj.ac/problem/131" target="_blank" rel="noopener">树状数组 2 ：区间修改，单点查询</a></h2><p>考虑维护一个差分序列</p>
<p>那么这个数的差分序列的前缀和就是这个数</p>
<p>如果对区间$[l,r]$整体修改，即$a[l]-a[l-1]$与$a[r+1]-a[r]$的值发生了改变</p>
<p>即我们只需要去修改$cf[l]$和$cf[r+1]$的权值</p>
<h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> __read() &#123;</span><br><span class="line">    int x(0), t(1);</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">o</span><span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">'0'</span> || o &gt; <span class="string">'9'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">'-'</span>)</span><br><span class="line">            t = <span class="number">-1</span>;</span><br><span class="line">        o = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">'0'</span> &amp;&amp; o &lt;= <span class="string">'9'</span>; o = getchar()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">ll t[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Update</span><span class="params">(<span class="keyword">int</span> x, ll val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x &lt;= n) &#123;</span><br><span class="line">        t[x] += val;</span><br><span class="line">        x += lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="function">ll <span class="title">ans</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (x) &#123;</span><br><span class="line">        ans += t[x];</span><br><span class="line">        x ^= lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = __read(), m = __read();</span><br><span class="line">    <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = __read();</span><br><span class="line">        Update(i, x - last);</span><br><span class="line">        last = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="keyword">int</span> opt = __read(), l = __read();</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> r = __read(), k = __read();</span><br><span class="line">            Update(l, k);</span><br><span class="line">            Update(r + <span class="number">1</span>, -k);</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, Query(l));</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="树状数组-3-：区间修改，区间查询"><a href="#树状数组-3-：区间修改，区间查询" class="headerlink" title="树状数组 3 ：区间修改，区间查询"></a><a href="https://loj.ac/problem/132" target="_blank" rel="noopener">树状数组 3 ：区间修改，区间查询</a></h2><p>按照上一个操作的思想，现在得到了差分序列${cf}$</p>
<p>此时要求的是区间$[l,r]$的和</p>
<p>按照差分的写法，就应该是</p>
<script type="math/tex; mode=display">
ans=  \sum_{i=l}^r\sum_{j=1}^icf[j]</script><p>为了方便考虑，那么就可以用$r$的前缀和前去$l-1$的前缀和</p>
<p>那么考虑求$[1,r]$的和</p>
<script type="math/tex; mode=display">
\begin{align*}
 ans&=\sum_{i=1}^r\sum_{j=1}^icf[j]\\
 &=\sum_{i=1}^r(r-i+1)cf[i]\\
 &=(r+1)\sum_{i=1}^rcf[i]-\sum_{i=1}^ri\cdot cf[i]
 \end{align*}</script><p>我们发现，这个似乎变成了两个需要维护的序列，那就写两个呗</p>
<h2 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll maxn = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> ll __read()</span><br><span class="line">&#123;</span><br><span class="line">    ll x(0), t(1);</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">'0'</span> || o &gt; <span class="string">'9'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">'-'</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">'0'</span> &amp;&amp; o &lt;= <span class="string">'9'</span>; o = getchar()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll n, m;</span><br><span class="line">ll t[maxn], d[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Update</span><span class="params">(ll x, ll val)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ll <span class="title">temp</span><span class="params">(x)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (x &lt;= n) &#123;</span><br><span class="line">        t[x] += val;</span><br><span class="line">        d[x] += val * temp;</span><br><span class="line">        x += lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Query</span><span class="params">(ll x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans(0), temp(x);</span><br><span class="line">    <span class="keyword">while</span> (x) &#123;</span><br><span class="line">        ans += t[x] * (temp + <span class="number">1</span>) - d[x];</span><br><span class="line">        x ^= lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = __read(), m = __read();</span><br><span class="line">    ll last = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        ll x = __read();</span><br><span class="line">        Update(i, x - last);</span><br><span class="line">        last = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        ll opt = __read(), l = __read(), r = __read();</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">1</span>) &#123;</span><br><span class="line">            ll k = __read();</span><br><span class="line">            Update(l, k);</span><br><span class="line">            Update(r + <span class="number">1</span>, -k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span> (<span class="string">"%lld\n"</span>, Query(r) - Query(l - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二维树状数组"><a href="#二维树状数组" class="headerlink" title="二维树状数组"></a>二维树状数组</h1><p>这个和一维树状数组的思路大致相同，但是每次修改、查询的复杂度都是$O(\log_2n\times\log_2m)$</p>
<h2 id="二维树状数组-1：单点修改，区间查询"><a href="#二维树状数组-1：单点修改，区间查询" class="headerlink" title=" 二维树状数组 1：单点修改，区间查询"></a><a href="https://loj.ac/problem/133" target="_blank" rel="noopener"> 二维树状数组 1：单点修改，区间查询</a></h2><p>直接维护二维前缀和，简单容斥一下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> __read()</span><br><span class="line">&#123;</span><br><span class="line">    int x(0), t(1);</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">'0'</span> || o &gt; <span class="string">'9'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">'-'</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">'0'</span> &amp;&amp; o &lt;= <span class="string">'9'</span>; o = getchar()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, opt;</span><br><span class="line">ll t[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= n; i += lowbit(i))</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = y; j &lt;= m; j += lowbit(j))</span><br><span class="line">            t[i][j] += val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ll <span class="title">ans</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i; i ^= lowbit(i))</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = y; j; j ^= lowbit(j))</span><br><span class="line">            ans += t[i][j];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = __read(), m = __read();</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span> (<span class="string">"%d"</span>, &amp;opt)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = __read(), b = __read(), x = __read();</span><br><span class="line">            Update(a, b, x);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> a = __read(), b = __read(), c = __read(), d = __read();</span><br><span class="line">            <span class="built_in">printf</span> (<span class="string">"%lld\n"</span>, Query(c, d) + Query(a - <span class="number">1</span>, b - <span class="number">1</span>) - Query(a - <span class="number">1</span>, d) - Query(c, b - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二维树状数组-2：区间修改，单点查询"><a href="#二维树状数组-2：区间修改，单点查询" class="headerlink" title="二维树状数组 2：区间修改，单点查询"></a><a href="https://loj.ac/problem/134" target="_blank" rel="noopener">二维树状数组 2：区间修改，单点查询</a></h2><p>简单地说，维护二维差分序列可以做到区间修改，直接二维前缀和就是一个单点查询</p>
<p>考虑如何去构造差分序列</p>
<p>对于每一维，可以有$cf[i][j]=a[i][j]-a[i][j-1]$或$cf[i][j]=a[i][j]-a[i-1][j]$</p>
<p>确实，这个可以把两维分开，看成$n$个一维的，但是下面还有区间修改区间查询的</p>
<p>所以这里要说的显然不是一维的做法</p>
<p>考虑合并行和列的差分序列后，与二维前缀和的关系</p>
<p>容易发现：</p>
<script type="math/tex; mode=display">
\begin{align*}
a[x][y]&=\sum_{i=1}^x\sum_{j=1}^ycf[i][j]\\
a[x-1][y]&=\sum_{i=1}^{x-1}\sum_{j=1}^ycf[i][j]\\
a[x][y-1]&=\sum_{i=1}^x\sum_{j=1}^{y-1}cf[i][j]\\
a[x-1][y-1]&=\sum_{i=1}^{x-1}\sum_{j=1}^{y-1}cf[i][j]
\end{align*}</script><p>那么就可以轻松的得到$cf[x][y]=a[x][y]-a[x-1][y]-a[x][y-1]+a[x-1][y-1]$了</p>
<p>就是说现在已经构造出了二维前缀和等于该点原本的值的差分序列了</p>
<p>考虑如何区间修改呢</p>
<p>这得画图</p>
<p><a href="https://imgchr.com/i/wXbyct" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/09/23/wXbyct.png" alt="wXbyct.png" border="0" /></a></p>
<p>那么蓝色矩形就是需要修改的矩形，按照差分数组的定义，差分序列发生改变了的点就是图中四个绿色的小矩形，就可以直接改了</p>
<h2 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> __read()</span><br><span class="line">&#123;</span><br><span class="line">    int x(0), t(1);</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">'0'</span> || o &gt; <span class="string">'9'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">'-'</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">'0'</span> &amp;&amp; o &lt;= <span class="string">'9'</span>; o = getchar()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, opt;</span><br><span class="line">ll t[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= n; i += lowbit(i))</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = y; j &lt;= m; j += lowbit(j))</span><br><span class="line">            t[i][j] += val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ll <span class="title">ans</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i; i ^= lowbit(i))</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = y; j; j ^= lowbit(j))</span><br><span class="line">            ans += t[i][j];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = __read(), m = __read();</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span> (<span class="string">"%d"</span>, &amp;opt)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = __read(), b = __read(), c = __read(), d = __read(), x = __read();</span><br><span class="line">            Update(a, b, x);</span><br><span class="line">            Update(a, d + <span class="number">1</span>, -x);</span><br><span class="line">            Update(c + <span class="number">1</span>, b, -x);</span><br><span class="line">            Update(c + <span class="number">1</span>, d + <span class="number">1</span>, x);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> a = __read(), b = __read();</span><br><span class="line">            <span class="built_in">printf</span> (<span class="string">"%lld\n"</span>, Query(a, b));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二维树状数组-3：区间修改，区间查询"><a href="#二维树状数组-3：区间修改，区间查询" class="headerlink" title="二维树状数组 3：区间修改，区间查询"></a><a href="https://loj.ac/problem/135" target="_blank" rel="noopener">二维树状数组 3：区间修改，区间查询</a></h2><p>这个就是继承了<strong>二维树状数组2</strong>和<strong>树状数组3</strong>的思想了</p>
<p>现在得到了二维差分序列，需要求的确实这样一个东西</p>
<script type="math/tex; mode=display">
ans=\sum_{x=xl}^{xr}\sum_{y=yl}^{yr}\sum_{i=1}^x\sum_{j=1}^ycf[i][j]</script><p>丑死了。。。</p>
<p>还是直接考虑简单容斥，那就只剩下一个二维前缀和了</p>
<script type="math/tex; mode=display">
\begin{align*}
ans&=\sum_{x=1}^{xr}\sum_{y=1}^{yr}\sum_{i=1}^x\sum_{j=1}^ycf[i][j]\\
&=\sum_{i=1}^{xr}\sum_{j=1}^{yr}cf[i][j]*(x-i+1)*(y-j+1)\\
&=\sum_{i=1}^{xr}\sum_{j=1}^{yr}cf[i][j]*(xy-xj+x-iy+ij-i+y-j+1)\\
&=\sum_{i=1}^{xr}\sum_{j=1}^{yr}cf[i][j]*((xy+x+y+1)-(xj-j)-(iy-i)+ij)\\
&=\sum_{i=1}^{xr}\sum_{j=1}^{yr}cf[i][j]*\big((x+1)(y+1)-(x+1)j-(y+1)i+ij\big)\\
&=\sum_{i=1}^{xr}\sum_{j=1}^{yr}cf[i][j]*(x+y)(y+1)-\sum_{i=1}^{xr}\sum_{j=1}^{yr}cf[i][j]*(x+1)*j-\sum_{i=1}^{xr}\sum_{j=1}^{yr}cf[i][j]*(y+1)*i+\sum_{i=1}^{xr}\sum_{j=1}^{yr}cf[i][j]*ij\\
&=(x+y)(y+1)\sum_{i=1}^{xr}\sum_{j=1}^{yr}cf[i][j]-(x+1)\sum_{i=1}^{xr}\sum_{j=1}^{yr}cf[i][j]*j-(y+1)\sum_{i=1}^{xr}\sum_{j=1}^{yr}cf[i][j]*i+\sum_{i=1}^{xr}\sum_{j=1}^{yr}cf[i][j]*ij\\
\end{align*}</script><p>所以分别要维护的就是$cf[i][j], cf[i][j]<em>j, cf[i][j]</em>i, cf[i][j]*ij$四个数组了</p>
<p>嗯~ o(<em>￣▽￣</em>)o，就可以愉快的跑路走人了</p>
<h2 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> __read()</span><br><span class="line">&#123;</span><br><span class="line">    int x(0), t(1);</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">'0'</span> || o &gt; <span class="string">'9'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">'-'</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">'0'</span> &amp;&amp; o &lt;= <span class="string">'9'</span>; o = getchar()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, opt;</span><br><span class="line">ll t[<span class="number">4</span>][maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= n; i += lowbit(i))</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = y; j &lt;= m; j += lowbit(j)) &#123;</span><br><span class="line">            t[<span class="number">0</span>][i][j] += val;</span><br><span class="line">            t[<span class="number">1</span>][i][j] += val * y;</span><br><span class="line">            t[<span class="number">2</span>][i][j] += val * x;</span><br><span class="line">            t[<span class="number">3</span>][i][j] += val * x * y;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i; i ^= lowbit(i))</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = y; j; j ^= lowbit(j))</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k(<span class="number">0</span>); k &lt; <span class="number">4</span>; ++k) </span><br><span class="line">                ans[k] += t[k][i][j];</span><br><span class="line">    <span class="keyword">return</span> (x + <span class="number">1</span>) * (y + <span class="number">1</span>) * ans[<span class="number">0</span>] - (x + <span class="number">1</span>) * ans[<span class="number">1</span>] - (y + <span class="number">1</span>) * ans[<span class="number">2</span>] + ans[<span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = __read(), m = __read();</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span> (<span class="string">"%d"</span>, &amp;opt)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = __read(), b = __read(), c = __read(), d = __read(), x = __read();</span><br><span class="line">            Update(a, b, x);</span><br><span class="line">            Update(a, d + <span class="number">1</span>, -x);</span><br><span class="line">            Update(c + <span class="number">1</span>, b, -x);</span><br><span class="line">            Update(c + <span class="number">1</span>, d + <span class="number">1</span>, x);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> a = __read(), b = __read(), c = __read(), d = __read();</span><br><span class="line">            <span class="built_in">printf</span> (<span class="string">"%lld\n"</span>, Query(c, d) - Query(a - <span class="number">1</span>, d) - Query(c, b - <span class="number">1</span>) + Query(a - <span class="number">1</span>, b - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>杜教筛</title>
    <url>/2020/08/19/%E6%9D%9C%E6%95%99%E7%AD%9B/</url>
    <content><![CDATA[<h1 id="杜教筛"><a href="#杜教筛" class="headerlink" title="杜教筛"></a>杜教筛</h1><p>简单的说是用来求数论函数的前缀和，时间复杂度低于线性时间复杂度</p>
<p>如求：$S(n)=\sum_{i=1}^nf(i)$</p>
<p>常规思路，构造类似数论分块的玩意儿$S(\lfloor\frac ni\rfloor)$，就这个</p>
<p>先构造函数$g$，考虑用迪利克雷卷积先乱搞一下</p>
<script type="math/tex; mode=display">
\begin{align*}
\sum_{i=1}^n\sum_{d|n}g(d)f(\frac id)&=\sum_{i=1}g(i)S(\lfloor\frac ni\rfloor)\\
&=\sum_{i=1}^ng(i)\sum_{j=1}^{\lfloor\frac ni\rfloor}f(j)\\
&=\sum_{i=1}^n\sum_{j=1}^{\lfloor\frac ni\rfloor\\}g(i)f(j) \\
\text{令:  i * j = d}\\
&=\sum_{d=1}^n\sum_{i|d}^ng(i)f(\frac di)\qquad\text{证毕!!}
\\\Leftrightarrow\sum_{i=1}^n(f*g)(i)&=\sum_{i=1}g(i)S(\lfloor\frac ni\rfloor)\\
\end{align*}</script><p>那么就可以有：</p>
<script type="math/tex; mode=display">
g(1)S(n)=\sum(f*g)(i)-\sum_{i=2}^ng(i)S(\lfloor\frac ni\rfloor)</script><p>嗯嗯，这个就可以数论分块乱搞了</p>
<p>来，看个实例</p>
<h1 id="P4213-【模板】杜教筛（Sum"><a href="#P4213-【模板】杜教筛（Sum" class="headerlink" title="P4213 【模板】杜教筛（Sum)"></a><a href="https://www.luogu.com.cn/problem/P4213" target="_blank" rel="noopener">P4213 【模板】杜教筛（Sum)</a></h1><p>求</p>
<script type="math/tex; mode=display">
S_1 = \sum_{i=1}^n\varphi(i)\\
S_2 = \sum_{i=1}^n\mu(i)</script><p>先来看看第一问：</p>
<p>首先，我们知道$\mu*1=id$，这个应该是很好证明的，<del>反正我不会</del></p>
<script type="math/tex; mode=display">
\sum_{i=1}^n\sum_{d|i}\varphi(d)=\sum_{i=1}^nS_1(\lfloor\frac ni\rfloor)\\
\begin{align*}
\therefore S_1&=\sum_{i=1}^n(\varphi*1)(i)-\sum_{i=2}^nS(\lfloor\frac ni\rfloor)\\
&=\sum_{i=1}^ni-\sum_{i=2}^nS(\lfloor\frac ni\rfloor)
\end{align*}</script><p>来，再看看第二问：</p>
<script type="math/tex; mode=display">
\sum_{i=1}^n\sum_{d|i}\mu(d)=\sum S_2(\lfloor\frac ni\rfloor)\\
\begin{align*}
\therefore S_2&=\sum_{i=1}^n(\mu*1)(i)-\sum_{i=2}^nS(\lfloor\frac ni\rfloor)\\
&=\sum_{i=1}^n\epsilon(i)-\sum_{i=2}^nS(\lfloor\frac ni\rfloor)\\
&=1-\sum_{i=2}^nS(\lfloor\frac ni\rfloor)
\end{align*}</script><p>这个推出来了，问题就变得十分的简单了</p>
<p>但是我们又发现了一个更大的问题：数组开不下</p>
<p>怎么办？</p>
<p>我们发现问题是离散的，并不是连续的</p>
<p>那么我们就可以用$map$之类的好工具</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="built_in">unordered_map</span> &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; Mu;</span><br><span class="line"><span class="built_in">unordered_map</span> &lt;<span class="keyword">int</span>, ll&gt; Phi;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">5e6</span>;</span><br><span class="line"><span class="keyword">int</span> T, A, B;</span><br><span class="line"><span class="keyword">int</span> P[Maxn + <span class="number">10</span>], Cnt;</span><br><span class="line"><span class="keyword">int</span> mu[Maxn + <span class="number">10</span>];</span><br><span class="line">ll phi[Maxn + <span class="number">10</span>];</span><br><span class="line"><span class="keyword">bool</span> Vis[Maxn + <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mu[<span class="number">1</span>] = phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= Maxn; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!Vis[i]) P[++Cnt] = i, mu[i] = <span class="number">-1</span>, phi[i] = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= Cnt &amp;&amp; i * P[j] &lt;= Maxn; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            Vis[i * P[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % P[j]) mu[i * P[j]] = -mu[i], phi[i * P[j]] = phi[i] * phi[P[j]];</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                phi[i * P[j]] = phi[i] * P[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Maxn; ++i) mu[i] += mu[i - <span class="number">1</span>], phi[i] += phi[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">PPhi</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= Maxn) <span class="keyword">return</span> phi[x];</span><br><span class="line">    <span class="keyword">if</span> (Phi[x]) <span class="keyword">return</span> Phi[x];</span><br><span class="line">    ll Ans = <span class="number">1l</span>l * x * (x + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (ll l(<span class="number">2</span>), r; l &lt;= x; l = r + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        r = x / (x / l);</span><br><span class="line">        Ans -= (r - l + <span class="number">1</span>) * PPhi(x / l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Phi[x] = Ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">MMu</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= Maxn) <span class="keyword">return</span> mu[x];</span><br><span class="line">    <span class="keyword">if</span> (Mu[x]) <span class="keyword">return</span> Mu[x];</span><br><span class="line">    <span class="function">ll <span class="title">Ans</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (ll l(<span class="number">2</span>), r; l &lt;= x; l = r + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        r = x / (x / l);</span><br><span class="line">        Ans -= (r - l + <span class="number">1</span>) * MMu(x / l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Mu[x] = Ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Init();</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">"%d"</span>, &amp;A);</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">"%lld %d\n"</span>, PPhi(A), MMu(A));</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>前缀和</tag>
        <tag>学习笔记</tag>
        <tag>数学</tag>
        <tag>杜教筛</tag>
      </tags>
  </entry>
  <entry>
    <title>模板</title>
    <url>/2020/06/24/%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h1 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h1> <video id="video" controls="" preload="none" poster="http://media.w3.org/2010/05/sintel/poster.png">
      <source id="mp4" src="http://media.w3.org/2010/05/sintel/trailer.mp4" type="video/mp4">
      <source id="webm" src="http://media.w3.org/2010/05/sintel/trailer.webm" type="video/webm">
      <source id="ogv" src="http://media.w3.org/2010/05/sintel/trailer.ogv" type="video/ogg">
      <p>Your user agent does not support the HTML5 Video element.</p>
    </video>


<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">id</span>=<span class="string">"video"</span> <span class="attr">controls</span>=<span class="string">""</span> <span class="attr">preload</span>=<span class="string">"none"</span> <span class="attr">poster</span>=<span class="string">"http://media.w3.org/2010/05/sintel/poster.png"</span>&gt;</span>//poster是封面</span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">id</span>=<span class="string">"mp4"</span> <span class="attr">src</span>=<span class="string">"http://media.w3.org/2010/05/sintel/trailer.mp4"</span> <span class="attr">type</span>=<span class="string">"video/mp4"</span>&gt;</span>//id为支持的视频的格式</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Your user agent does not support the HTML5 Video element.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>就可以了</p>
<h1 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a>音乐</h1><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1374056689&auto=0&height=66"></iframe>

<p><img src="music.png" alt=""></p>
<p><img src="music2.png" alt=""></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">frameborder</span>=<span class="string">"no"</span> <span class="attr">border</span>=<span class="string">"0"</span> <span class="attr">marginwidth</span>=<span class="string">"0"</span> <span class="attr">marginheight</span>=<span class="string">"0"</span> <span class="attr">width</span>=<span class="string">330</span> <span class="attr">height</span>=<span class="string">86</span> <span class="attr">src</span>=<span class="string">"//music.163.com/outchain/player?type=2&amp;id=1374056689&amp;auto=0&amp;height=66"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="哔哩哔哩"><a href="#哔哩哔哩" class="headerlink" title="哔哩哔哩"></a>哔哩哔哩</h1><iframe class="bilibili"src="//player.bilibili.com/player.html?aid=73773499&cid=146795963&page=1&high_quality=1&danmaku=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="width: 100%; height: 500px; max-width: 100%；align:center; padding:20px 0;"> </iframe>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">class</span>=<span class="string">"bilibili"</span> <span class="attr">src</span>=<span class="string">"//player.bilibili.com/player.html?aid=73773499&amp;cid=146795963&amp;page=1&amp;high_quality=1&amp;danmaku=1"</span> <span class="attr">scrolling</span>=<span class="string">"no"</span> <span class="attr">border</span>=<span class="string">"0"</span> <span class="attr">frameborder</span>=<span class="string">"no"</span> <span class="attr">framespacing</span>=<span class="string">"0"</span> <span class="attr">allowfullscreen</span>=<span class="string">"true"</span> <span class="attr">style</span>=<span class="string">"width: 100%; height: 500px; max-width: 100%；align:center; padding:20px 0;"</span>&gt;</span> <span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>该地址应该就可以了?</p>
<h1 id="pdf"><a href="#pdf" class="headerlink" title="pdf"></a>pdf</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm install hexo-pdf --save</span><br></pre></td></tr></table></figure>


	<div class="row">
    <embed src="Problem.pdf" width="100%" height="550" type="application/pdf">
	</div>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;%pdf Problem.pdf%&#125;</span><br></pre></td></tr></table></figure>
<p>pdf 后面是跟的相对路径</p>
<hr>
<h1 id="文章内容折叠"><a href="#文章内容折叠" class="headerlink" title="文章内容折叠"></a>文章内容折叠</h1><h2 id="hexo-sliding-spoiler插件"><a href="#hexo-sliding-spoiler插件" class="headerlink" title="hexo-sliding-spoiler插件"></a>hexo-sliding-spoiler插件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm install hexo-sliding-spoiler --save</span><br></pre></td></tr></table></figure>
<h2 id="自定义设置"><a href="#自定义设置" class="headerlink" title="自定义设置"></a>自定义设置</h2><p><strong>1.</strong>默认是 <code>Show: .../ Hide: ...</code>，我们可以更改前面的字。</p>
<p><strong>2.</strong>打开文件<code>F:\OI\Blog\hexo\node_modules\_hexo-sliding-spoiler@1.2.1@hexo-sliding-spoiler\assets\spoiler.css</code>，大概25-31行？修改其中的<code>content</code></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.spoiler</span><span class="selector-class">.collapsed</span> <span class="selector-class">.spoiler-title</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">"Show: "</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.spoiler</span><span class="selector-class">.expanded</span> <span class="selector-class">.spoiler-title</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">"Hide: "</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% spoiler "隐藏内容的标题" %&#125;</span><br><span class="line"></span><br><span class="line">隐藏文字隐藏文字隐藏文字。  </span><br><span class="line">支持 <span class="code">`markdown`</span> 语法</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>支持 <span class="strong">**粗体**</span>、<span class="emphasis">*斜体*</span></span><br><span class="line"><span class="bullet">- </span>支持列表</span><br><span class="line"><span class="bullet">- </span>支持md插入图片语法</span><br><span class="line"><span class="bullet">- </span>支持html插入图片语法</span><br><span class="line"><span class="bullet">- </span>支持行内代码 <span class="code">`markdown`</span></span><br><span class="line"><span class="bullet">- </span>支持代码块</span><br><span class="line">  </span><br><span class="line"><span class="code">    ```cpp</span></span><br><span class="line"><span class="code">    #include &lt;initializer_list&gt;</span></span><br><span class="line"><span class="code">    #include &lt;iostream&gt;</span></span><br><span class="line"><span class="code">    struct A &#123;</span></span><br><span class="line"><span class="code">        A() &#123; std::cout &lt;&lt; "1"; &#125;</span></span><br><span class="line"><span class="code">        A(int) &#123; std::cout &lt;&lt; "2"; &#125;</span></span><br><span class="line"><span class="code">        A(std::initializer_list&lt;int&gt;) &#123; std::cout &lt;&lt; "3"; &#125;</span></span><br><span class="line"><span class="code">    &#125;;</span></span><br><span class="line"><span class="code">    int main(int argc, char *argv[]) &#123;</span></span><br><span class="line"><span class="code">        A a1;</span></span><br><span class="line"><span class="code">        A a2&#123;&#125;;</span></span><br><span class="line"><span class="code">        A a3&#123; 1 &#125;;</span></span><br><span class="line"><span class="code">        A a4&#123; 1, 2 &#125;;</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code">    ```// 此处加点文字，防止排版错误：因为这是代码块内的代码。使用时可删除</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>支持表格</span><br><span class="line"></span><br><span class="line"><span class="code">    | 文字 | 文字 |</span></span><br><span class="line"><span class="code">    | ---- | ---- |</span></span><br><span class="line"><span class="code">    | 文字 | 文字 |</span></span><br><span class="line"></span><br><span class="line">&#123;% endspoiler %&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h2><p>隐藏文字隐藏文字隐藏文字。<br>支持 <code>markdown</code> 语法</p>
<ul>
<li><p>支持 <strong>粗体</strong>、<em>斜体</em></p>
</li>
<li><p>支持列表</p>
</li>
<li><p>支持md插入图片语法</p>
</li>
<li><p>支持html插入图片语法</p>
</li>
<li><p>支持行内代码 <code>markdown</code></p>
</li>
<li><p>支持代码块</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    A() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"1"</span>; &#125;</span><br><span class="line">    A(<span class="keyword">int</span>) &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"2"</span>; &#125;</span><br><span class="line">    A(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt;) &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"3"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    A a1;</span><br><span class="line">    A a2&#123;&#125;;</span><br><span class="line">    A a3&#123; <span class="number">1</span> &#125;;</span><br><span class="line">    A a4&#123; <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line">​```<span class="comment">// 此处加点文字，防止排版错误：因为这是代码块内的代码。使用时可删除</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>支持表格</p>
<p>  | 文字 | 文字 |<br>  | —— | —— |<br>  | 文字 | 文字 |</p>
<p>  事实证明不支持表格</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>其他板子</tag>
      </tags>
  </entry>
  <entry>
    <title>莫比乌斯反演</title>
    <url>/2020/06/14/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/</url>
    <content><![CDATA[<h3 id="P3911-最小公倍数之和"><a href="#P3911-最小公倍数之和" class="headerlink" title="P3911 最小公倍数之和"></a><a href="https://www.luogu.com.cn/problem/P3911" target="_blank" rel="noopener">P3911 最小公倍数之和</a></h3><script type="math/tex; mode=display">
求\sum\limits_{i=1}^n\sum\limits_{j=1}^n{lcm(a_i,a_j)}\\
\forall a_i \in \left[ 1, \;Maxn\right]</script><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><script type="math/tex; mode=display">
\sum\limits_{i=1}^n\sum\limits_{j=1}^n{lcm(a_i,a_j)}\\
\Leftrightarrow\sum\limits_{i=1}^n\sum\limits_{j=1}^n{lcm(i,j)}\cdot c_i \cdot c_j\\
{PS： c_i,\; c_j分别别表示i，j出现的次数}</script><h5 id="化简："><a href="#化简：" class="headerlink" title="化简："></a>化简：</h5><script type="math/tex; mode=display">
\sum\limits_{i=1}^n\sum\limits_{j=1}^nlcm(i,\;j)\cdot i \cdot j\\
\Leftrightarrow\sum\limits_{i=1}^n\sum\limits_{j=1}^n\frac{i \cdot j \cdot c_i \cdot c_j}{\gcd(i,\;j)}\\
\Leftrightarrow\sum\limits_{d=1}^n\;d\;\sum\limits_{i=1}^\left[\frac{n}{d}\right]\sum\limits_{j=1}^\left[\frac{n}{d}\right]\left[ \gcd(i,\;j) = 1\right]\cdot i \cdot j \cdot c_{id} \cdot c_{jd} \\
\Leftrightarrow\sum\limits_{d=1}^n\;d\;\sum\limits_{i=1}^\left[\frac{n}{d}\right]\sum\limits_{j=1}^\left[\frac{n}{d}\right]\sum\limits_{k\mid \gcd (i,j)}\mu(k)\cdot i\cdot j\cdot c_{id}\cdot c_{jd}\\
\Leftrightarrow\sum\limits_{d=1}^n\sum\limits_{k=1}^\left[\frac{n}{d}\right]\;d\cdot \mu(k)\sum\limits_{i=1}^\left[\frac{n}{kd}\right]\sum\limits_{j=1}^\left[\frac{n}{kd}\right] i\cdot j\cdot c_{idk}\cdot c_{jdk}\cdot k^2\\
\Leftrightarrow\sum\limits_{T=1}^nT\cdot\;(\sum\limits_{i=1}^\left[ \frac{n}{T} \right]i\cdot c_{iT})^2 \cdot \sum\limits_{k \mid T}\mu(k) \cdot k</script><p>然后有：</p>
<script type="math/tex; mode=display">
\sum\limits_{k \mid T}\mu(k) \cdot k</script><p>这个可以预处理的</p>
<h5 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">5e4</span>;</span><br><span class="line">ll N, Temp, MaxNum, Ans;</span><br><span class="line">ll Cnt[Maxn + <span class="number">5</span>], Mu[Maxn + <span class="number">5</span>], Pri[Maxn + <span class="number">5</span>], S[Maxn + <span class="number">5</span>], Tot;</span><br><span class="line"><span class="keyword">bool</span> Vis[Maxn + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> Maxn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= Maxn; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!Vis[i]) Pri[++Tot] = i, Mu[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= Tot &amp;&amp; i * Pri[j] &lt;= Maxn; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            Vis[i * Pri[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % Pri[j]) Mu[i * Pri[j]] = -Mu[i];</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                Mu[i * Pri[j]] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Maxn; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= Maxn; j += i) S[j] += Mu[i] * i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Max</span><span class="params">(ll &amp;X, ll Y)</span> </span>&#123;X = (X &gt; Y ? X : Y);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;N);</span><br><span class="line">    <span class="keyword">while</span> (N--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;Temp);</span><br><span class="line">        Cnt[Temp]++;</span><br><span class="line">        Max(MaxNum, Temp);</span><br><span class="line">    &#125;</span><br><span class="line">    Init(MaxNum);</span><br><span class="line">    <span class="keyword">for</span> (ll T = <span class="number">1</span>; T &lt;= MaxNum; ++T)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">ll <span class="title">Temp</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= MaxNum / T; ++i) Temp += i * Cnt[i * T];</span><br><span class="line">        Ans += T * Temp * Temp * S[T];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, Ans);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Ps-双倍经验AT2500"><a href="#Ps-双倍经验AT2500" class="headerlink" title="Ps : 双倍经验AT2500"></a>Ps : 双倍经验<a href="https://www.luogu.com.cn/problem/AT5200" target="_blank" rel="noopener">AT2500</a></h5><p>只需要在这道题的基础上减去自己的贡献再乘上2的逆元，注意<strong>取模</strong>啊！！！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll Maxn = <span class="number">1e6</span>, Mod = <span class="number">998244353</span>;</span><br><span class="line">ll N, Temp, MaxNum, Ans, TempA;</span><br><span class="line">ll Cnt[Maxn + <span class="number">5</span>], Mu[Maxn + <span class="number">5</span>], Pri[Maxn + <span class="number">5</span>], S[Maxn + <span class="number">5</span>], Tot;</span><br><span class="line"><span class="keyword">bool</span> Vis[Maxn + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> Maxn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= Maxn; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!Vis[i]) Pri[++Tot] = i, Mu[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= Tot &amp;&amp; i * Pri[j] &lt;= Maxn; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            Vis[i * Pri[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % Pri[j]) Mu[i * Pri[j]] = -Mu[i];</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                Mu[i * Pri[j]] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Mu[i] &lt; <span class="number">0</span>) Mu[i] += Mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Maxn; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= Maxn; j += i) S[j] = (S[j] + Mu[i] * i % Mod) % Mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Max</span><span class="params">(ll &amp;X, ll Y)</span> </span>&#123;X = (X &gt; Y ? X : Y);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">Pow</span><span class="params">(ll Y, ll X = <span class="number">2</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ll <span class="title">Ans</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (Y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Y &amp; <span class="number">1</span>) Ans = Ans * X % Mod;</span><br><span class="line">        X = X * X % Mod;</span><br><span class="line">        Y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Ans % Mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;N);</span><br><span class="line">    <span class="keyword">while</span> (N--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;Temp);</span><br><span class="line">        TempA = (TempA + Temp) % Mod;</span><br><span class="line">        Cnt[Temp]++;</span><br><span class="line">        Max(MaxNum, Temp);</span><br><span class="line">    &#125;</span><br><span class="line">    Init(MaxNum);</span><br><span class="line">    <span class="keyword">for</span> (ll T = <span class="number">1</span>; T &lt;= MaxNum; ++T)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">ll <span class="title">Temp</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= MaxNum / T; ++i) Temp = (Temp + i * Cnt[i * T] % Mod) % Mod;</span><br><span class="line">        Ans = (Ans + T * Temp % Mod * Temp % Mod * S[T] % Mod) % Mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, (Ans - TempA + Mod) % Mod * Pow(Mod - <span class="number">2</span>) % Mod);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="P1447-NOI2010-能量采集"><a href="#P1447-NOI2010-能量采集" class="headerlink" title="P1447 [NOI2010]能量采集"></a><a href="https://www.luogu.com.cn/problem/1447" target="_blank" rel="noopener">P1447 [NOI2010]能量采集</a></h3><script type="math/tex; mode=display">
求\sum\limits_{i=1}^n\sum\limits_{j=1}^m\left[(2\cdot\gcd(i,j))-1\right]</script><h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><script type="math/tex; mode=display">
\sum\limits_{i=1}^n\sum\limits_{j=1}^m\left[(2\cdot\gcd(i,j))-1\right]\\\\
\Leftrightarrow\sum\limits_{i=1}^n\sum\limits_{j=1}^m 2 \cdot\gcd(i,j) - m\cdot n\\\\
\Leftrightarrow2\cdot\sum\limits_{d=1}^nd\;\cdot\sum\limits_{i=1}^\left[\frac{n}{d}\right]\sum\limits_{j=1}^\left[\frac{m}{d}\right]\left[\gcd(i,j)=1\right]-m\cdot n\\\\
\Leftrightarrow2\cdot\sum\limits_{d=1}^nd\;\cdot\sum\limits_{i=1}^\left[\frac{n}{d}\right]\sum\limits_{j=1}^\left[\frac{m}{d}\right]\sum\limits_{k\mid\gcd(i,j)}\mu(k)-m\cdot n\\\\
\Leftrightarrow2\cdot\sum\limits_{d=1}^nd\cdot\sum\limits_{k=1}^\left[\frac{n}{d}\right]\mu(k)\cdot\left[\frac{n}{dk}\right]\cdot\left[\frac{m}{dk}\right]-m\cdot n\\\\
\Leftrightarrow2\cdot\sum\limits_{T=1}^n\left[\frac{n}{T}\right]\cdot\left[\frac{m}{T}\right]\sum\limits_{d\mid T}^\left[\frac{n}{T}\right]d\cdot\mu(\frac{T}{d})-m\cdot n\\\\</script><h5 id="化简：-1"><a href="#化简：-1" class="headerlink" title="化简："></a>化简：</h5><script type="math/tex; mode=display">
令：h(n) = \sum\limits_{d\mid T}^\left[\frac{n}{T}\right]d\cdot\mu(\frac{T}{d})\\\\
h=id*\mu\\\\
\because \mu * 1=\epsilon\\\\
\therefore h*1=id* (\mu * 1)\\\\
\therefore h*1=id*\epsilon\\\\
\therefore h*1=id\\\\
又\because id = \varphi * 1\\\\
\therefore h = \varphi\\\\
即：2\cdot\sum\limits_{T=1}^n\left[\frac{n}{T}\right]\cdot\left[\frac{m}{T}\right]\sum\limits_{d\mid T}^\left[\frac{n}{T}\right]d\cdot\mu(\frac{T}{d})-m\cdot n\\\\
\Leftrightarrow2\cdot\sum\limits_{T=1}^n\varphi(T)\cdot\left[\frac{n}{T}\right]\cdot\left[\frac{m}{T}\right]-m\cdot n</script><h5 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">1e5</span>;</span><br><span class="line">ll N, M, Ans, Cnt;</span><br><span class="line">ll Phi[Maxn + <span class="number">10</span>], Pri[Maxn + <span class="number">10</span>];</span><br><span class="line"><span class="keyword">bool</span> Vis[Maxn + <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= Maxn; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!Vis[i]) Phi[i] = i - <span class="number">1</span>, Pri[++Cnt] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= Cnt &amp;&amp; i * Pri[j] &lt;= Maxn; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            Vis[i * Pri[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % Pri[j]) Phi[i * Pri[j]] = Phi[i] * Phi[Pri[j]];</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                Phi[i * Pri[j]] = Phi[i] * Pri[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Maxn; ++i) Phi[i] += Phi[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Init();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>, &amp;N, &amp;M);</span><br><span class="line">    <span class="keyword">if</span> (N &gt; M) swap(N, M);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r; l &lt;= N; l = r + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        r = min(N / (N / l), M / (M / l));</span><br><span class="line">        Ans += <span class="number">2</span> * (Phi[r] - Phi[l - <span class="number">1</span>]) * (N / l) * (M / l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>, Ans - N * M);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="P5221-Product"><a href="#P5221-Product" class="headerlink" title="P5221 Product"></a><a href="https://www.luogu.com.cn/problem/P5221" target="_blank" rel="noopener">P5221 Product</a></h3><script type="math/tex; mode=display">
求:\prod\limits_{i=1}^N\prod\limits_{j=1}^N\frac{lcm(i,j)}{\gcd(i,j)}(mod\;104857601)</script><h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><script type="math/tex; mode=display">
\prod\limits_{i=1}^N\prod\limits_{j=1}^N\frac{\operatorname{lcm}(i,j)}{\gcd(i,j)}\\
\Leftrightarrow\prod\limits_{i=1}^N\prod\limits_{j=1}^N\frac{i\cdot j}{\gcd(i,j)^2}\\
\Leftrightarrow\prod\limits_{i=1}^N\prod\limits_{j=1}^Ni\cdot j\prod\limits_{i=1}^N\prod\limits_{j=1}^N\frac{1}{\gcd(i,j)^2}\\</script><h5 id="化简"><a href="#化简" class="headerlink" title="化简:"></a>化简:</h5><script type="math/tex; mode=display">
其中:\prod\limits_{i=1}^N\prod\limits_{j=1}^Ni\cdot j
\\=\prod\limits_{i=1}^N\left(i^N\cdot N!\right)\\
=\left(N!\right)^N\prod\limits_{i=1}^Ni^N\\
=\left(N!\right)^N\cdot\left(N!\right)^N\\
=\left(N!\right)^{2N}</script><script type="math/tex; mode=display">
其中还有:\prod\limits_{i=1}^N\prod\limits_{j=1}^N\frac{1}{\gcd(i,j)^2}\\
=\prod\limits_{d=1}^N\prod\limits_{i=1}^N\prod\limits_{j=1}^N\frac{1}{d^2\cdot\left[\gcd(i,j)=d\right]}\\
若:gcd(i,j)\ne d\;则整体贡献为1\\
=\left(\prod\limits_{d=1}^Nd^{\sum\limits_{i=1}^N\sum\limits_{j=1}^N\left[\gcd(i, j)=d\right]}\right)^{-2}\\
=\left(\prod\limits_{d=1}^Nd^{\sum\limits_{i=1}^\frac{N}{d}\sum\limits_{j=1}^\frac{N}{d}\left[\gcd(i, j)=1\right]}\right)^{-2}\\
令:sum(x) = \sum\limits_{i=1}^x\varphi(i)\\
=\left(\prod\limits_{d=1}^Nd^{2sum(\frac{N}{d}) - 1}\right)^{-2}\\
\therefore Ans = (N!)^{2N}\left(\prod\limits_{d=1}^Nd^{2sum(\frac{N}{d}) - 1}\right)^{-2}</script><h5 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxn = <span class="number">1e6</span>, Mod = <span class="number">104857601</span>;</span><br><span class="line"><span class="keyword">int</span> N, Cnt, Phi[Maxn + <span class="number">5</span>], Fac(<span class="number">1</span>), Tmp(<span class="number">1</span>), Pri[Maxn/<span class="number">2</span>];</span><br><span class="line"><span class="keyword">bool</span> Vis[Maxn + <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> X, <span class="keyword">int</span> Y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Y %= (Mod - <span class="number">1</span>);</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Ans</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (Y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Y &amp; <span class="number">1</span>) Ans = <span class="number">1l</span>l * Ans * X % Mod;</span><br><span class="line">        X = <span class="number">1l</span>l * X * X % Mod;</span><br><span class="line">        Y &gt;&gt;= <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Ans % Mod;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> Maxn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= Maxn; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        Fac = <span class="number">1l</span>l * Fac * i % Mod;</span><br><span class="line">        <span class="keyword">if</span> (!Vis[i]) Pri[++Cnt] = i, Phi[i] = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= Cnt &amp;&amp; i * Pri[j] &lt;= Maxn; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            Vis[i * Pri[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % Pri[j]) Phi[i * Pri[j]] = Phi[i] * (Pri[j] - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                Phi[i * Pri[j]] = Phi[i] * Pri[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Maxn; ++i) Phi[i] = ( Phi[i - <span class="number">1</span>] + <span class="number">2l</span>l * Phi[i]) % (Mod - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= Maxn; ++i) Tmp = <span class="number">1l</span>l * Tmp * Pow(i, Phi[Maxn / i] - <span class="number">1</span>) % Mod;</span><br><span class="line">    Fac = Pow(Fac, Maxn * <span class="number">2</span>);</span><br><span class="line">    Tmp = <span class="number">1l</span>l * Pow(<span class="number">1l</span>l * Tmp * Tmp % Mod, Mod - <span class="number">2</span>) * Fac % Mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">    Init(N);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Tmp);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>莫比乌斯反演</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>生成函数</title>
    <url>/2020/09/06/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="生成函数简介"><a href="#生成函数简介" class="headerlink" title="生成函数简介"></a>生成函数简介</h1><p>生成函数（$\text{generating function}$），又称母函数，是一种形式幂级数，其每一项的系数可以提供关于这个序列的信息。</p>
<p>生成函数有许多不同的种类，但大多可以表示为单一的形式：</p>
<script type="math/tex; mode=display">
F(x)=\sum_na_nk_n(x)</script><p>其中$k_n(x)$被称为核函数。不同的核函数会导出不同的生成函数，拥有不同的性质。举个例子：</p>
<ul>
<li><p>普通生成函数： $k_n(x)=x^n$</p>
</li>
<li><p>指数生成函数： $k_n(x)=\frac{x^n}{n!}$</p>
</li>
<li><p>狄利克雷生成函数： $k_n(x)=\frac1{n^x}$</p>
</li>
</ul>
<p>另外，对于生成函数$F(x)$，我们用$[k_n(x)]F(x)$来表示它的第$n$项的核函数对应的系数，也就是$a_n$。</p>
<h1 id="普通生成函数"><a href="#普通生成函数" class="headerlink" title="普通生成函数"></a>普通生成函数</h1><p>序列$a$的普通生成函数（$\text{ordinary generating function，OGF}$）定义为形式幂级数：</p>
<script type="math/tex; mode=display">
F(x)=\sum_na_nx^n</script><p> $a$既可以是有穷序列，也可以是无穷序列。常见的例子（假设$a$以$0$为起点）：</p>
<ul>
<li>序列$a=\langle1,2,3\rangle$的普通生成函数是$1+2x+3x^2$</li>
<li>序列$a=\langle1,1,1,\cdots\rangle$的普通生成函数是$\sum_{n\ge0}x^n$</li>
<li>序列$a=\langle1,2,4,8,16,\cdots\rangle$的生成函数是$\sum_{n\ge 0}2^nx^n$</li>
<li>序列$a=\langle1,3,5,7,9,\cdots\rangle$的生成函数是$\sum_{n\ge0}(2n+1)x^n$</li>
</ul>
<p>换句话说，如果序列$a$有通项公式，那么它的普通生成函数的系数就是通项公式。</p>
<h2 id="基本运算"><a href="#基本运算" class="headerlink" title="基本运算"></a>基本运算</h2><p>考虑两个序列$a,b$的普通生成函数，分别为$F(x),G(x)$。那么有：</p>
<script type="math/tex; mode=display">
F(x)\pm G(x)=\sum_n(a_n+b_n)x^n</script><p>因此$F(x)\pm G(x)$是序列$\langle a_n+b_n\rangle$的普通生成函数。</p>
<p>考虑乘法运算，也就是卷积：</p>
<script type="math/tex; mode=display">
F(x)G(x)=\sum_nx^n\sum_{i=0}^na_ib_{n-i}</script><p>因此$F(x)G(x)$是序列</p>
<script type="math/tex; mode=display">
\langle\sum_{i=0}^na_ib_{n-i}\rangle</script><p>的普通生成函数。</p>
<h2 id="封闭形式"><a href="#封闭形式" class="headerlink" title="封闭形式"></a>封闭形式</h2><p>在运用生成函数的过程中，我们不会一直使用形式幂级数的形式，而会适时地转化为封闭形式以更好地化简。</p>
<p>例如：$\langle1,1,1,\cdots\rangle$的普通生成函数$F(x)=\sum_{n\ge0}x^n$，我们可以发现：</p>
<script type="math/tex; mode=display">
F(x)x+1=F(x)</script><p>那么解这个方程得到：</p>
<script type="math/tex; mode=display">
F(x)=\frac1{1-x}</script><p> 这就是$\sum_{n\ge0}x^n$的封闭形式。</p>
<p>证明的话就先鸽着</p>
<p>考虑等比数列$\langle1,p,p^2,p^3,p^4,\cdots\rangle$的生成函数$F(x)=\sum_{n\ge0}p^nx^n$，有：</p>
<script type="math/tex; mode=display">
\begin{align*}
F(x)px+1&=F(x)
\\F(x)&=\frac1{1-px}
\end{align*}</script><p>等比数列的封闭形式与展开形式是常用的变换手段。</p>
<p>请求出下列数列的普通生成函数（形式幂级数形式和封闭形式）。难度的循序渐进的。</p>
<ol>
<li><p>$a=\langle0,1,1,1,1,\cdots\rangle$</p>
</li>
<li><p>$a=\langle1,0,1,0,1,\cdots\rangle$</p>
</li>
<li><p>$a=\langle1,2,3,4,5,\cdots\rangle$</p>
</li>
<li><p>$a_n=\dbinom{m}{n}\;(m是常数，n\ge0)$</p>
</li>
<li><p>$a_n=\dbinom{m+n}{n}$</p>
</li>
</ol>
<p><a href="https://oi-wiki.org/math/gen-func/ogf/" target="_blank" rel="noopener"><strong>答案</strong></a></p>
<h2 id="斐波那契数列的生成函数"><a href="#斐波那契数列的生成函数" class="headerlink" title="斐波那契数列的生成函数"></a>斐波那契数列的生成函数</h2><p>接下来我们来推导斐波那契数列的生成函数。</p>
<p>斐波那契数列定义为:</p>
<script type="math/tex; mode=display">
a_0=0,a_1=1,a_n=a_{n-1}+a_{n-2}(n>1)</script><p>设它的普通生成函数是$F(x)$，那么根据它的递推式，我们可以类似地列出关于$F(x)$的方程：</p>
<script type="math/tex; mode=display">
F(x)=xF(x)+x^2F(x)-a_0x+a_1x+a_0</script><p>那么解的：</p>
<script type="math/tex; mode=display">
F(x)=\frac x{1-x-x^2}</script><p>接下来的问题是，如何求出他的展开形式？</p>
<h3 id="展开方式一"><a href="#展开方式一" class="headerlink" title="展开方式一"></a>展开方式一</h3><p>不妨将$x+x^2$当作为一个整体，那么可以得到：</p>
<script type="math/tex; mode=display">
\begin{align*}
F(x)&=\frac x{1-(x+x^2)}
\\&=\sum_{n\ge0}(x+x^2)^n
\\&=\sum_{n\ge0}\sum_{i=0}^n\dbinom{n}{i}x^{2i}x^{n-i}
\\&=\sum_{n\ge0}\sum_{i=0}^n\dbinom{n}{i}x^{n+i}
\\&=\sum_{n\ge0}x^n\sum_{i=0}^n\dbinom{n-i}{i}
\end{align*}</script><p>我们得到了$a_n$的通项公式，但那并不是我们熟知的有关黄金分割比的形式。</p>
<h3 id="展开方式二"><a href="#展开方式二" class="headerlink" title="展开方式二"></a>展开方式二</h3><p>考虑求解一个待定系数的方程：</p>
<script type="math/tex; mode=display">
\frac A{1-ax}+\frac B{1-bx}=\frac x{1-x-x^2}</script><p>通分得到：</p>
<script type="math/tex; mode=display">
\frac {A-Abx+B-aBx}{(1-ax)(1-bx)}=\frac x{1-x-x^2}</script><p>待定项系数相等，我们得到：</p>
<script type="math/tex; mode=display">
\begin{cases}
A+B=0\\
-Ab-aB=1\\
a+b=1
ab=-1
\end{cases}</script><p>解得：</p>
<script type="math/tex; mode=display">
\begin{cases}
A=\frac1{\sqrt5}\\
B=-\frac1{\sqrt5}\\
a=\frac{1+\sqrt5}2\\
b=\frac{1-\sqrt5}2\\
\end{cases}</script><p>那么我们根据等比数列的展开式，就可以得到斐波那契数列的通项公式：</p>
<script type="math/tex; mode=display">
\frac x{1-x-x^2}=\sum_{n\ge0}x^n\frac 1{\sqrt5}\left(\left(\dfrac{1+\sqrt5}2\right)^n-\left(\dfrac{1-\sqrt5}2\right)^n\right)</script><p>这也被称为斐波那契数列的另一个封闭形式（$\frac x{1-x-x^2}$ 是一个封闭形式）。</p>
<p>对于任意多项式 $P(x), Q(x)$，生成函数$\frac{P(X)}{Q(x)}$的展开式都可以使用上述方法求出。在实际运用的过程中，我们往往先求出$Q(x)$的根，把分母表示为$\prod(1-p_ix)^{d_i}$的形式，然后再求分子。</p>
<h2 id="鸽"><a href="#鸽" class="headerlink" title="鸽~"></a>鸽~</h2><p>牛顿二项式定理、卡特兰数的生成函数先鸽一鸽</p>
]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>鸽~</tag>
        <tag>生成函数</tag>
      </tags>
  </entry>
  <entry>
    <title>进阶数据结构1</title>
    <url>/2020/07/27/%E8%BF%9B%E9%98%B6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%841/</url>
    <content><![CDATA[<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><h2 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法:"></a>基本方法:</h2><ul>
<li>前缀和</li>
<li>差分</li>
<li>离散化</li>
<li>离线</li>
<li>二分</li>
<li>倍增</li>
<li>双指针</li>
<li>永久记忆化</li>
</ul>
<h2 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构:"></a>基本数据结构:</h2><ul>
<li><p>线段树</p>
</li>
<li><p>树状数组</p>
</li>
<li><p>$ST$表</p>
</li>
<li><p>单调队列</p>
</li>
<li><p>单调栈</p>
</li>
<li><p>并查集</p>
</li>
</ul>
<h2 id="树上问题基本方法"><a href="#树上问题基本方法" class="headerlink" title="树上问题基本方法"></a>树上问题基本方法</h2><ul>
<li>求$LCA$<ul>
<li>$O(n)-O(\log n)$</li>
<li>$O(n\log n)-O(1)$</li>
</ul>
</li>
<li>$DFS$序</li>
<li>链差分</li>
</ul>
<h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><p>线段树就是对一个序列递归地取中点分成两部分形成的分治树。任何以单点为基本单位的分治树都可以适配任意区间，而取中点分治保证了树高为$O(\log n)$。合并所有被完整包含的极大区间即可得到目标区间。</p>
<h2 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h2><p>将序列长度扩充成$2$的幂，建线段树，自底向上将每个节点的右儿子删除，这样会剩下$n$个节点。可以用一个数组来存储，其中下标$i$存储包含 $i$的最小节点，这个数组就称为树状数组。 </p>
<p>树状数组的英文名为 $Fenwick\;tree$ 或 $Binary\;Indexed \;Tree$， 可以缩写为 $BIT$。</p>
<p>对于一个线段树支持的操作，如果可以不用任何作为右儿子的节点，就可以用树状数组实现。 </p>
<p>大多数情况下，无论是代码实现难度还是运行效率，树状数组都有碾压性的优势。</p>
<h2 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h2><ul>
<li><p>区间加一个数, 查询单点</p>
</li>
<li><p>区间加一个数, 查询单点和</p>
</li>
<li><p>区间加等差数列, 查询单点</p>
</li>
</ul>
<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>用两个指针扫描, 扫描过程中保持两个指针的距离不超过一个定值</p>
<h2 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h2><p>维护一个序列，支持以下操作：</p>
<ul>
<li><p>在后面插入元素； </p>
</li>
<li><p>删除最前面的元素； </p>
</li>
<li><p>求序列中元素的最小值。<br>插入元素时，队尾的更大的元素不会再产生贡献，可以直接删去。这样队列中实际存在的元素单调递减。 </p>
</li>
</ul>
<p>常结合双指针使用。</p>
<h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><p>将序列中的元素依次插入一个栈，若栈顶元素更小，则它的答案已经可以确定，从而可以弹出。这样栈中的元素单调递减。</p>
<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>用来维护不相交集合。可以缩写为$DSU$。 </p>
<p>通常只使用路径压缩策略。即使只压缩一半的路径，均摊复杂度仍然是$O(\log n)$。 </p>
<p>另有带权并查集，维护点权差的传递。可以利用取模后的权值差来分类。</p>
<p>注：所谓的 $DSU\;on\;tree$ 实际上是树的链分治，和 $DSU$ 并 没有任何关系，因此这个称呼并不合理。</p>
<hr>
<h1 id="平衡树相关"><a href="#平衡树相关" class="headerlink" title="平衡树相关"></a>平衡树相关</h1><h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><p>每个节点有一个关键字，每个节点的关键字均不小于左子树中任何节点的关键字，且均不大于右子树中任何节点的关键字，或者说按树的中序遍历排列这些关键字得到的数列单调不降。 </p>
<p>二叉搜索树的英文为 $Binary\;Search \;Tree$，可缩写为 $BST$。</p>
<p><img src="./BST.png" alt=""></p>
<h2 id="平衡树"><a href="#平衡树" class="headerlink" title="平衡树"></a>平衡树</h2><p>平衡树全称平衡二叉搜索树，是深度为 $O(log\;n)$ 的二叉搜 索树。 </p>
<p>平衡树有很多种，学会 $Splay$ 和 $Treap$ 就够用了，当然有兴趣可以多学，虽然没啥用。</p>
<p>在普通 $BST$ 的基础上，每个节点随机分配一个权值，调整树的形态使得这些权值满足堆性质。</p>
<p> 可以证明任何时候树的期望深度为 $O(\log \;n)$。 </p>
<p>名称来自 $Tree + Heap$，故又称树堆。</p>
<h2 id="权值线段树"><a href="#权值线段树" class="headerlink" title="权值线段树"></a>权值线段树</h2><p>设 $C_x$ 为 $x$ 的出现次数，建线段树维护 $C$ 的前缀和。由于 $C$ 的下标是权值，这样的线段树常称为权值线段树。</p>
<h2 id="线段树上二分"><a href="#线段树上二分" class="headerlink" title="线段树上二分"></a>线段树上二分</h2><p>二分的过程可以视为在分治树上自顶向下移动，既然线段树是分治树，那么自然可以直接在线段树上移动。</p>
<h2 id="动态开店线段树"><a href="#动态开店线段树" class="headerlink" title="动态开店线段树"></a>动态开店线段树</h2><p>最开始没有点，不建树，当修改操作用到了不存在的点时 再创建这个点。如果查询操作用到了不存在的点，可以直 接算出相应的答案。 </p>
<p>适用于无法离散化的情况。</p>
<h2 id="Splay"><a href="#Splay" class="headerlink" title="$Splay$"></a>$Splay$</h2><p>每次操作后都通过某种方法旋转，使最后一个被访问的节点成为根节点。 </p>
<p>可以证明 $n$ 次操作的总复杂度为 $O(n \log n)$，即一次操作 的均摊复杂度为 $O(log n)$，但某一次操作的复杂度可能达到 $O(n)$。 </p>
<p>可直译为伸展树。</p>
<h2 id="FHQ-quad-Treap"><a href="#FHQ-quad-Treap" class="headerlink" title="$FHQ\quad Treap$"></a>$FHQ\quad Treap$</h2><p>$Treap$ 可以实现分裂与合并，只要在过程中维护堆性质，复杂度并不会改变。插入和删除都可以通过分裂与合并来实 现，这样就不再需要旋转过程。</p>
<h2 id="反转操作"><a href="#反转操作" class="headerlink" title="反转操作"></a>反转操作</h2><p>把对应的区间分裂出来, 反转左右子树即可</p>
<h2 id="最大子段和"><a href="#最大子段和" class="headerlink" title="最大子段和"></a>最大子段和</h2><p>合并两个区间的最值区间信息时，只有两种情况： </p>
<blockquote>
<ol>
<li><p>最值区间位于某一个区间； </p>
</li>
<li><p>最值区间横跨两个区间。 </p>
</li>
</ol>
</blockquote>
<p>只需要维护前后缀信息，就可以计算第二种情况。</p>
<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>通常情况下，常数：$Treap &lt; Splay &lt; 无旋 Treap$。 </p>
<ul>
<li>$Treap$ 常用于维护有序表； </li>
<li>$Splay$ 维护有序表效率低，而且实现不方便； </li>
<li>$Splay$ 常用于 $LCT$ 或维护序列； </li>
<li>无旋 $Treap$ 也可以维护序列，便于实现可持久化，但效率较低。</li>
</ul>
<hr>
<h1 id="高维问题"><a href="#高维问题" class="headerlink" title="高维问题"></a>高维问题</h1><h2 id="维度组成"><a href="#维度组成" class="headerlink" title="维度组成"></a>维度组成</h2><ul>
<li><p>如果对操作的位置有限制，问题就有位置轴。 </p>
</li>
<li><p>如果对操作的权值有限制，问题就有权值轴。 </p>
</li>
<li><p>如果对操作的顺序有要求，问题就有时间轴。</p>
</li>
</ul>
<p>位置轴和权值轴并没有本质区别。 </p>
<p>权值线段树只是指明了维护的是权值轴，和维护位置轴的线段树并没有本质区别。</p>
<h2 id="时间轴变换"><a href="#时间轴变换" class="headerlink" title="时间轴变换"></a>时间轴变换</h2><p>将某一轴视为时间轴，按时间顺序插入，从而将前缀查询转化为某个时间点的查询。</p>
<h2 id="离线扫描"><a href="#离线扫描" class="headerlink" title="离线扫描"></a>离线扫描</h2><p>将所有询问和数据集合一起按新的时间轴排序。</p>
<h2 id="分治树"><a href="#分治树" class="headerlink" title="分治树"></a>分治树</h2><p>维护某一维数据的基本方法是使用分治树。 </p>
<p>通常所说的数据结构是显式的分治树，包括线段树和平衡 树；通常所说的分治使用隐式的分治树。</p>
<h2 id="CDQ分治"><a href="#CDQ分治" class="headerlink" title="CDQ分治"></a>CDQ分治</h2><p>通过分治维护时间维。 </p>
<p>通常的 CDQ 分治只查询时间前缀，也可以做到查询时间区间，实现比较繁琐。</p>
<h2 id="整体二分"><a href="#整体二分" class="headerlink" title="整体二分"></a>整体二分</h2><p>用分治维护需要二分的维度，在分治树上二分。</p>
<h2 id="分治树的组合"><a href="#分治树的组合" class="headerlink" title="分治树的组合"></a>分治树的组合</h2><ul>
<li>树状数组套平衡树：空间 $O(n log n)$，效率一般 </li>
<li>树状数组套线段树：空间 $O(n \log_2 n)$，效率一般，各线段树可以同时二分</li>
<li>线段树套树：支持不可减外层信息分治套树状数组：离线，空间 $O(n)$，效率很高，可以在隐式分治树上二分 </li>
<li>分治套线段树：离线，空间 $O(n)$，效率较高，支持较复杂的操作 </li>
<li>树状数组套压缩 $trie$：空间 $O(n \log n)$，实现难度较大 </li>
<li>“重量”平衡树套树：支持外层插入，实现难度较大</li>
</ul>
<h2 id="KDT"><a href="#KDT" class="headerlink" title="$KDT$"></a>$KDT$</h2><p>维护 $k$ 维空间矩形信息的复杂度为 $O(n^{1−\frac1k} )$，空间 $O(n)$， 且支持高维标记，但是不能剪枝时常数巨大。</p>
<hr>
<h1 id="根号大法好"><a href="#根号大法好" class="headerlink" title="根号大法好"></a>根号大法好</h1><h2 id="莫队"><a href="#莫队" class="headerlink" title="莫队"></a>莫队</h2><p>将序列分块，将询问按左端点所在块为第一关键字、右端点为第二关键字排序。依次处理询问，维护一个初始为空的区间，每次将维护的区间按需插入或删除若干元素，得到当前的询问区间。</p>
<p>设块大小为 $l$。维护的区间的左端点的移动不超过 $ml + 2n$， 右端点的移动不超过 $2n \left \lceil nl \right \rceil$ ，取 $l=\left\lceil n\sqrt m\right\rceil$ 得最优复杂度 $O(n\sqrt m)$。</p>
<p>有时无法进行删除操作，这时可以只从某个块的左端点开 始维护区间，移动右端点并在右端插入相应的元素。移动到每个询问的右端点时，将左端未插入的元素插入，得到答案后再撤销左端的插入。 </p>
<p>这样就不用进行删除操作，但是至少要支持从两端插入。</p>
<h2 id="简单操作"><a href="#简单操作" class="headerlink" title="简单操作"></a>简单操作</h2><p>$O(\sqrt n)-O(1)$或$O(1)-O(\sqrt n)$</p>
<ul>
<li>序列单点修改，区间和 </li>
<li>序列区间加，查询单点 </li>
<li>集合插入，查询 $k$ 小</li>
</ul>
<center> <a href="./download.zip">附件下载 </center>

]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>道路和航线</title>
    <url>/2020/09/15/%E9%81%93%E8%B7%AF%E5%92%8C%E8%88%AA%E7%BA%BF/</url>
    <content><![CDATA[<h1 id="道路和航线"><a href="#道路和航线" class="headerlink" title="道路和航线"></a><a href="https://ac.nowcoder.com/acm/problem/50381" target="_blank" rel="noopener">道路和航线</a></h1><p>本质就是一个最短路，有负边，题目保证无环</p>
<p>$SPFA$直接跑的正确性就不用证明了</p>
<p>这道题卡掉了朴素的$SPFA$，用双端队列优化即可？</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> __read()</span><br><span class="line">&#123;</span><br><span class="line">    int x(0), t(1);</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">o</span> <span class="params">(getchar())</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (o &lt; <span class="string">'0'</span> || o &gt; <span class="string">'9'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="string">'-'</span>) t = <span class="number">-1</span>;</span><br><span class="line">        o = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; o &gt;= <span class="string">'0'</span> &amp;&amp; o &lt;= <span class="string">'9'</span>; o = getchar()) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (o ^ <span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> x * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, P, R, S, cur, dis[maxn];</span><br><span class="line"><span class="keyword">int</span> hed[maxn], edg[maxn], nxt[maxn], cst[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    nxt[++cur] = hed[u];</span><br><span class="line">    hed[u] = cur;</span><br><span class="line">    edg[cur] = v;</span><br><span class="line">    cst[cur] = w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">SPFA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">deque</span> &lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    Q.push_front(S);</span><br><span class="line">    dis[S] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> now = Q.front();</span><br><span class="line">        Q.pop_front();</span><br><span class="line">        vis[now] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = hed[now]; i; i = nxt[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dis[edg[i]] &lt;= cst[i] + dis[now]) <span class="keyword">continue</span>;</span><br><span class="line">            dis[edg[i]] = cst[i] + dis[now];</span><br><span class="line">            <span class="keyword">if</span> (vis[edg[i]]) <span class="keyword">continue</span>;</span><br><span class="line">            vis[edg[i]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (Q.empty() || dis[edg[i]] &lt;= dis[Q.front()]) Q.push_front(edg[i]);</span><br><span class="line">            <span class="keyword">else</span> Q.push_back(edg[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T = __read(), R = __read(), P = __read(), S = __read();</span><br><span class="line">    <span class="keyword">while</span> (R--) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = __read(), b = __read(), c = __read();</span><br><span class="line">        AddEdge(a, b, c), AddEdge(b, a, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (P--) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = __read(), b = __read(), c = __read();</span><br><span class="line">        AddEdge(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span> (dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dis);</span><br><span class="line">    SPFA();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= T; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dis[i] == inf) <span class="built_in">puts</span>(<span class="string">"NO PATH"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span> (<span class="string">"%d\n"</span>, dis[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
</search>
